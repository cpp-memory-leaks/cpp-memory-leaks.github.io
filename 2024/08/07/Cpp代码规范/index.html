<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>C++代码规范 | Stack Overflow</title><meta name="author" content="OQS"><meta name="copyright" content="OQS"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="C++代码规范"><meta name="application-name" content="C++代码规范"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="C++代码规范"><meta property="og:url" content="https://cpp-memory-leaks.github.io/2024/08/07/Cpp%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/index.html"><meta property="og:site_name" content="Stack Overflow"><meta property="og:description" content="1.  概述命名，是计算机史上最难的问题之一，有很多书本都有专门的章节讨论命名规范的问题，鄙人写的总结，是作为一名刚毕业的黄毛小子从刚工作开始积累的，可能没有那些名著写的那么详细，但是贵在真实，我觉得还是有点使用价值的。 我觉得给代码命名有三要：  要有区分度 要有辨识度 要够详细（最少的字表达最清"><meta property="og:locale" content="en"><meta property="og:image" content="https://cpp-memory-leaks.github.io/img/cpp_default_cover.png"><meta property="article:author" content="OQS"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cpp-memory-leaks.github.io/img/cpp_default_cover.png"><meta name="description" content="1.  概述命名，是计算机史上最难的问题之一，有很多书本都有专门的章节讨论命名规范的问题，鄙人写的总结，是作为一名刚毕业的黄毛小子从刚工作开始积累的，可能没有那些名著写的那么详细，但是贵在真实，我觉得还是有点使用价值的。 我觉得给代码命名有三要：  要有区分度 要有辨识度 要够详细（最少的字表达最清"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://cpp-memory-leaks.github.io/2024/08/07/Cpp%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"Author: OQS","link":"Link: ","source":"Source: Stack Overflow","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.","copySuccess":"Copy success, copy and reprint please mark the address of this article"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Stack Overflow',
  title: 'C++代码规范',
  postAI: '',
  pageFillDescription: '1.  概述, 2.  头文件, 2.1   头文件保护, 2.2  前置声明, 2.3  内联函数, 2.4  incude的路径及次序, 3. 作用域, 3.1  命名空间, 3.2  非成员函数、静态成员函数和全局函数, 3.3  局部变量, 4. 类, 4.1  构造函数的职责, 4.2  初始化, 4.3  显式构造函数, 4.4  结构体 VS类, 4.5  接口, 4.6  继承, 4.7  多重继承, 4.8  声明顺序, 4.9  存取控制, 5. 函数, 5.1  参数, 5.2  编写简短函数, 6.  其他C++特性, 6.1  异常, 6.2 类型转换, 6.3  前置自增和自减, 6.4  const用法, 6.5   预处理宏, 6.6  sieof, 6.7  auto, 6.8  lambda表达式, 7.  命名约定, 7.1  通用命名约定, 7.2  文件命名, 7.3  类型命名, 7.4  变量命名, 7.5  常量命名, 7.6  函数命名, 7.7   命名空间命名, 7.8  枚举命名, 7.9   结构体命名, 7.10   获取器和设置器命名, 7.11  界面控件命名, 8. 注释, 8.1  注释风格, 8.2  头文件注释, 8.3  类注释, 8.4  函数注释, 8.5  变量注释, 8.6  实现注释, 8.7  枚举和结构体注释, 8.8   TODO注释, 9. 格式, 9.1  行长度, 9.2  文件编码, 9.3  缩进, 9.4  大括号, 9.5  函数调用, 9.6  函数声明与定义, 9.7  条件语句, 9.8  布尔表达式, 9.9  switch-case语句, 9.10  指针和引用表达式, 9.11  预处理指令, 9.12  构造函数初始值列表, 9.13  类格式, 10  完结撒花概述命名是计算机史上最难的问题之一有很多书本都有专门的章节讨论命名规范的问题鄙人写的总结是作为一名刚毕业的黄毛小子从刚工作开始积累的可能没有那些名著写的那么详细但是贵在真实我觉得还是有点使用价值的我觉得给代码命名有三要要有区分度要有辨识度要够详细最少的字表达最清楚的意思不要造字你不是仓颉英语里面有约定俗成的名称缩写如不要为了规范而规范目的不影响理解不产生歧义不增加维护成本足以旨在提高代码的可读性可维护性特此制定本规范参考以及等规范基础上结合项目开发经验汇总整理成本规范头文件头文件保护所有头文件都应该使用防止头文件被重复包含命名格式为例如前置声明前置声明是类函数和模板的纯粹声明没伴随着其定义在头文件中进行前置声明可以减少的数量避免多重包含减少头文件展开的次数有效的提高编译效率对于库工程使用前置声明可以减少内部类的导出注意前置类型的类是不完全类型只能定义指向该类型的指针或引用或者声明但不能定义以不完全类型作为参数或者返回类型的函数使用前置声明形式代替库工程不希望导出的内部类才使用前置声明内联函数当函数被声明为内联函数之后编译器会将其内联展开而不是按通常的函数调用机制进行调用只要当函数只有行甚至更少时才将其定义为内联函数只有内联的函数体较小内联该函数才可以令目标代码更加高效对于存取函数以及其他函数比较短性能关键的函数鼓励使用内联注意不要内联包含循环或语句的函数可能导致增加代码大小的路径及次序项目内的头文件按照项目源代码目录树结构排列头文件包含顺序项目内头文件其他库头文件库库库通过空行分隔相关头文件项目内头文件其他库头文件库头文件库头文件库头文件作用域命名空间命名空间将全局作用域细分为独立的具名的作用域可以有效防止全局作用域的命名冲突举例来说两个不同项目的全局作用域都有一个类这样在编译或运行时会造成冲突如果每个项目将代码置于不同命名空间中和作为不同符号自然不会冲突命名方式参考命名空间命名使用方式如下全局定义宏包括了以下所有项目内开发头文件均包含以下内容命名空间定义命名空间开始命名空间结束命名空间修饰符根据全局定义宏文件头文件以及源文件遵循以下规则编写文件所有声明前置声明除外都置于命名空间中文件函数定义都至于命名空间中结论不建议使用指示引入整个命名空间的标识符号在和文件的函数方法或者类中可以使用声明在文件中文件的话必须在函数方法或类的内部使用不建议污染命名空间不要在头文件中使用命名空间别名因为头文件的别名对包含了该头文件的所有人可见所以递归包含到其他头文件里使用别名缩短常用的命名空间可以在文件文件的话必须在函数方法或类的内部使用否则污染命名空间在文件里以下别名在所有包含了该头文件的文件中生效在函数方法使用命名别名限制在函数中非成员函数静态成员函数和全局函数使用静态成员函数或命名空间内的非成员函数尽量不要用裸的全局函数将一些列函数直接至于命名空间不要用类的静态函数模拟出命名空间的效果类的静态方法应该和类的实例或数据紧密相关推荐不推荐类的内部并没有静态变量类的实体也没具体功能局部变量尽量将函数变量尽可能置于最小作用域内并在变量声明时进行初始化不推荐初始化和声明分离推荐初始化时声明不推荐用花括号初始化更好推荐一开始就初始化属于和语句的变量尽量在这些语句中正常地声明这样变量的作用域就被限制在这些语句中了如在作用域内声明如果变量是一个对象则不适用该方法低效的实现构造函数和析构函数分别调用次应该作用域外声明构造函数和析构函数只调用次类构造函数的职责构造函数不得调用虚函数如果在构造函数内调用了自身的虚函数这类调用是不会重定向到子类的虚函数实现的即当前没有子类化实现存在隐患构造函数不能报告一个非致命错误即构造函数必须成功不然会获得一个初始化失败的对象有可能进入不正常的状态如果对象需要进行初始化考虑使用明确的方法或使用工厂模式方法形式需要在类的注释里说明用法不推荐容易误用工厂方法功能逻辑初始化如果类中定义了成员变量则必须在类中为每个类提供初始化函数或定义一个构造函数若未声明构造函数则编译器会生成一个默认的构造函数这有可能导致某些成员未被初始化或初始化未不恰当的值所以确保构造函数将对象的每一个成员变量进行了初始化且初始化顺序和声明顺序保持一致不推荐写法会导致多调用赋值操作函数降低效率这些是赋值操作而非初始化推荐写法只调用拷贝构造函数这些是初始化操作或者在类的成员变量声明时进行初始化不需要对变量进行初始化重复操作会覆盖初值在声明时就初始化成员变量显式构造函数对于单个参数的构造函数不要定义为隐式类型转换使用关键字隐式类型转换即允许某种类型称作源类型的对象被用于需要另一种类型称作目的类型例如将一个类型的参数传递给需要类型的函数通常只有一个参数的构造函数被看作是一种隐式转换除了单参数构造函数外也适用于除第一个参数以外的其他参数都具有默认参数的构造函数例如拷贝和移动构造函数不需要被标记为因为它们并不进行类型转换以下都需要进行进行显示转换不需要使用拷贝构造移动构造当设计目的用于其他类型进行透明封装的类来说隐式类型转换是合适的例如和结构体类在中和关键词几乎含义一样对两个关键字进行进一步规定是用来定义包含数据的被动式对象也可以包含相关的常量但除了存取数据成员以外没有别的操作函数功能并且存取功能通过直接访问位域而非函数调用除了构造函数析构函数初始化数据重置数据数据对比操作符重载等类似用于设定数据成员的函数外不能提供其他功能函数如果需要更多函数功能使用代替接口当一个类满足以下要求时称之为纯接口类应以为开头命名如只有纯虚函数和静态函数析构函数除外没有定义任何构造函数如果有也不能带有参数并且必须为如果它是一个子类也只能从满足上述条件的类继承基类为非接口类错误基类非接口类只有纯虚函数继承于接口类才能定义为接口类以为前缀可以提醒该类为纯接口类这一点对于多重继承尤其重要由于接口类不能被直接实例化为确保接口类的所有实现可被正确销毁必须为之声明虚析构函数继承当子类继承基类时子类包含了父基类所有数据及操作的定义继承主要用于两种场景实现继承子类继承父类的实现代码接口继承子类仅继承父类的接口名称尽量使用继承不要使用继承而应该替换成把类的实例作为成员对象的方式避免过度使用继承要尽量做到只在是一种的情况下使用继承例如是是一种控件继承于禁止应该以类的成员变量形式如果类确定存在继承关系作为基类应该将析构函数声明为相反当类的设计目的不是作为基类或不具有多态性就不将析构函数声明为而当类中存在虚函数则析构函数也应该声明为注意析构函数与构造函数相同也不应该调用虚函数或者发生错误作为基类必须将析构函数声明为类中存在函数必须将析构函数声明为定义虚函数析构函数声明为多重继承只有以下情况允许多重继承只有一个基类是非抽象类其他基类都是以为前缀的纯接口类继承顺序应从非抽象类再到纯接口类的顺序进行继承错误和都是非抽象类正确为非抽象类为纯接口类声明顺序类的访问控制区段的声明为如果某区段没有内容可以不声明注释方式参考注释每个区段内的声明通常按以下顺序和枚举常量构造函数析构函数成员函数包含静态成员函数槽函数公有继承后跟信号数据成员包含静态数据成员公有成员成员函数包含静态成员函数公有槽函数信号保护成员保护槽函数私有函数私有槽函数私有成员友元类存取控制将所有数据成员声明为并根据需要提供响应的存取函数静态常量数据成员可以不是私有成员存取函数一般在头文件中定义为内联函数函数函数命名规则参考函数命名参数函数的参数顺序为输入参数在前输出参数包含输入输出参数在后中的函数参数可能是输入参数也可能是输出参数或者是输入输出参数输入参数通常是值传递或者引用或指针输出参数或输入输出参数则为非指针或引用更多说明参考用法在加入新参数时不要因为它们时新参数就置于参数列表最后而是仍然要按照输入参数在前输入参数在后的原则内置类型输入参数或者的迭代器用值传递作为输出参数用非指针形式传入当输入参数为对象则用引用传递推荐直观看出输入输出参数注意这一条不是硬性规定属于推荐写法实际情况复杂时可以进行更改编写简短函数函数的编写尽量简练目的是使函数实现的逻辑结构化清晰化便于阅读与维护如果函数行数太多超过行后成为长函数可以考虑将长函数拆分成几个短函数是函数尽量简短便于阅读和维护注意长函数按照具体情况而定例如对于部分和逻辑分支过长就不遵行本条规定其他特性异常禁止异常机制所有错误都应该通过错误值在函数之间传递并做出相应判断而不应该通过异常进行错误处理例外在接管语言本身抛出的异常例如失败第三方库例如抛出的异常时可以使用异常机制面对异常首先考虑是否为操作错误例如参数范围问题应该在代码进行入参检测例如库中出现私有类指针为野指针应该从析构问题解决这些问题都不应该从接异常解决类型转换使用的类型转换如而不是使用或等转换形式即不要使用风格进行类型转换而应该使用风格用替代风格的值转换或某个类的指针需要明确向上转换为父类指针用去掉限定符用指针类型和整型和其他类型指针进行转换用转换存在继承关系的对象前置自增和自减对于迭代器和其他模板类型使用前缀形式的自增自减运算符对于简单数值非对象两种都无所谓在不考虑返回值的情况前置自增通常要比后置自增效率更高因为后置自增或自减需要对表达式的值进行一次拷贝如果是迭代器或其他非数值类型拷贝的代价比较大所以推荐使用前置自增推荐效率更高不推荐需要进行多次拷贝构造简单数值内置类型两者均可更推荐保证习惯一致用法变量数据成员函数和参数为编译时进行类型检测增加了一道屏障便于尽早发现问题参考参数因此尽可能的情况下使用参考访问函数函数传入不会修改的参数未调用非函数返回引用构造之后不会修改的值如果函数不会修改传入的引用或指针类型参数该参数应声明为尽可能将函数声明为访问函数应该总是其他不会修改任何数据成员未调用非函数返回数据成员为指针或引用也应该声明成如果数据成员在对象构造之后不再发生变化可将其定义未预处理宏宏意味着你和编译器看到的代码时不同的这可能会导致异常行为而且宏具有全局作用域尽量以内联函数枚举和常量代替宏定义命名规则参考常量命名替换替换被累加两次被累加一次替换尽可能用代替使用时因为当代码中变量类型改变时会自动更新当用处理不涉及任何变量的代码比如处理来自外部或内部的数据格式时就不适用了推荐当改成其他类型时不影响运行不推荐改为其他类型未做修改可能导致不适用情况中若变量被声明为类型就会被自动匹配成初始化表达式的类型用绕过繁琐的类型名只要可读性好就可以使用但不要用在局部变量之外的地方不要用在初始化列表会导致歧义同时要注意区分和涉及模板类或命名空间时类型名会很复杂修改为显得直观因为一般是迭代器变量即的迭代器没有的话我们不得不在同一个表达式出现两次类型名使用就简单且不会有歧义不推荐代码不能直观看出是何种类型创建一份的拷贝是的一个引用不要用在初始化列表是是并非表达式表达式是创建匿名函数对象的一种简易途径常用于把函数当参数传递例如当变量需要捕获识禁止使用通用捕获将所有的捕获都显式写出来增加可读性使用引用捕获时变量名和之间不留空格不推荐使用默认捕获推荐显式捕获写出来和不留空格表达式用于参数传递时如果函数体超过五行应当将表达式转换为对象如果是作为的槽函数则改用函数的形式命名约定命名的风格能让我们在不需要去查找类型声明的条件下快速了解某个名字代表的含义类型变量函数常量宏信号槽函数等等通用命名约定名称由字母数字以及下划线组合而成且第一位不能为数字小驼峰命名方式尽量使用描述性的命名少用缩写除了一些广泛接受的缩写例如表示迭代器用表示模板参数无缩写是常见的缩写是都知道的概念不清楚作用和意义缩写不知道代表何种意思是何种意思可能出现歧义缩写若干字母文件命名文件命名使用大驼峰命名方式定义类和文件名一般成对出现文件名说明作用如存放关于的声明命名空间定义命名空间开始命名空间结束命名空间修饰符文件名和类名一一对应成对存在类型命名类型命名的每个单词首字母都是大写不包含下划线大驼峰命名方式所有类型命名类结构体类型定义枚举类型模板参数均使用本约定类和结构体类型定义别名枚举类型模板参数变量命名变量包含函数参数和数据成员名一律用小驼峰命名方式每行一个变量单字符的变量只在循环计数中使用对于不同作用域的变量遵循以下规则类成员变量须在变量名前加前缀局部变量等到需要使用时再定义且定义是必须要初始化整数为实数用指针用字符串用全局变量命名时须在变量前加前缀静态变量名以开头前缀说明示例无局部变量类的成员变量类的静态成员变量静态变量外部全局变量静态全局变量进程间共享的数据段全局变量常量命名常量不含前缀且应该大写单词间由下滑线包含以及宏定义例如不推荐写法命名方式按常量命名规则函数命名函数命名以及函数参数都使用小驼峰命名方式函数名时动词或含有动词的短语函数参数若非基础数据类型使用对象引用例如基础类型迭代器值传递非基础类型引用传递当函数为信号或者槽函数时应分别在前加上和前缀命名空间命名命名空间的名称是名词用小写字母命名每个单词以下划线分割例如枚举命名枚举名和枚举值都是名词和常量或宏规则一致枚举值每个字母均为大写单词之间以下划线间隔枚举名为大驼峰命名方式例如枚举名枚举值结构体命名结构体中只定义变量不定义函数需要定义函数的结构体转换成类实现结构体名是名词每个单词以大写字母开头大驼峰命名方式结构体成员是名词以小驼峰命名方式例如获取器和设置器命名获取器和设置器都是根据约定俗成的命名规则非布尔型的获取器或者布尔型的获取器设置器界面控件命名控件命名应以控件类型结尾以说明控件的类型例如界面中有且仅有一种该类型控件界面中出现多种重复的控件应将前面补充说明注释一般情况下源程序有效注释量必须在以上不易理解的地方都需加上注释需要简单精炼注释风格头文件注释风格需要兼容注释方式便于生成说明文档源文件注释使用或都可以头文件注释头文件注释包括版权说明版本号作者生成日期描述信息等类注释类注释包括描述信息有必要时需将使用方法加到注释中简单类只需要包含简要说明信息即可如下类描述信息当类需要添加实例代码时候按以下方式进行备注类描述信息示例代码函数注释函数注释主要包括描述信息参数信息返回值以及返回值说明有必要时加入注解信息函数名函数简介形参参数说明返回说明非必要返回值说明非必要返回值说明非必要注释信息变量注释类的数据成员变量按需进行注释全局变量需要注释说明含义及用途变量注释置于变量的上方回归测试用例总数实现注释对于实现代码中巧妙的隐晦的重要的地方加以注释注意后跟一个空格巧妙或复杂的代码在代码块上方注释例如将结果除以考虑到包含加法的进位枚举和结构体注释枚举注释需要对枚举枚举值进行说明结构体注释需要对结构体成员变量进行说明日志类型输出输出输出输出输出输出自定义颜色红色分量绿色分量蓝色分量注释对于临时的短期的方案或计划中但未完成的代码或已实现功能但待优化的代码使用注释注释需要作者日期利于后期检索避免查找困难例如计划但未完成实现相关功能临时方案待优化格式行长度较长的语句字符要分成多行书写长表达式要在较低优先级操作符处划分新行操作符放在新行之首逗号放在一行的结束划分出的新行要进行适当的缩进使排版整齐语句可读例如操作符放在新行之首后一行与第一个实参对齐文件编码为了统一文件编码避免开发过程中文件编码混乱问题文件保存过程中统一使用无签名编码编码转换时默认在中转换下载插件选择第一个点击下载关闭并重启安装插件缩进使用个空格进行代码缩进禁止使用制表符大括号大括号的总结来说有两种使用情况分别是跟在语句后面空一格或者独占一行独占一行必须独占一行情况主要是定义的情况类定义结构体定义枚举定义函数定义即可独占一行或者空一格形式主要是代码逻辑语句循环语句和循环语句函数调用函数调用要么在一行写完调用要么在圆括号里对参数分行要么参数另起一行且缩进四格例如正常情况同一行放不下换新行且和第一个实参对齐左圆括号后和右圆括号前不留空格模拟层次多的情况空格缩进如果一些参数本身就是略复杂的表达式那么可以直接创建临时变量描述该表达式并传递给函数也可以将某个参数独立成行添加注释增加可读性如果一系列的参数本身就有一定的结构可以酌情地按其结构来决定参数格式通过矩阵转换函数声明与定义返回类型和函数名放在同一行参数在放不下时对形参分行分别单独占一行例如返回值函数名形参在同一行独占一行独占一行形参换行第一个参数都放不下换新行空格缩进空格缩进未被使用参数或者根据上下文很容易看出用途参数可以省略参数名但是尽量不要省略参数名继承于的事件的函数事件参数未被使用可以省略参数名这种情况大多是因为继承重写事件而省略参数操作需要移除拷贝构造函数或者是赋值操作函数可以省略参数名接口中形参恒有命名不推荐省略会不清楚变量的作用推荐说明变量作用并消除警告条件语句对基本条件语句不在圆括号内使用空格后面空一格前空一格或换行独立一行即不跟或者例如缩进四格或另起一行如果能增强可读性简短的条件语句允许写在同一行只有当语句简单并且没有使用子句时使用不允许当有分支时块却写在同一行如果语句中某个语句使用大括号的话其他分支也必须要使用不可以这样子有大括号却没有不可以这样子有大括号却没有只要其中一个分支用了大括号两个分支都要用上大括号布尔表达式如果一个布尔表达式过长断行方式要统一为逻辑操作符放在新行的开头但逻辑复杂时考虑增加圆括号增加可读性加入圆括号增加可读性操作符放在开头对齐第一个参数语句循环和语句的可以与关键词在同一行也可以另起单独一行与对齐后续代码不作展示说明语句中的块必须要大括号进行分段以表明之间不是连在一起的应该总是包含一个匹配可以在同一行也可以另起单独一行与对齐空格缩进四格空格缩进八格可以在同一行也可以另起单独一行与对齐如果不可能到可以尝试添加语句指针和引用表达式句点或箭头前后不要有空格指针地址操作符之后不能有空格例如在声明指针变量或参数时星号与类型或变量名紧挨都可以推荐空格前置推荐空格后置不推荐在多重声明中不能使用或不推荐两边都有空格不推荐两边都有空格预处理指令预处理指令不要缩进从行首开始推荐指令从行首开始正确从行首开始不推荐指令缩进差应该放在行开头差不要缩进构造函数初始值列表构造函数初始化列表放在同一行或按四格缩进并排多行如果所有变量能放在同一行如果不能放在同一行必须置于冒号后并缩进个空格如果初始化列表需要置于多行将每一个成员放在单独的一行并逐行对齐缩进个空格类格式访问控制块关键词的声明不需要缩进类声明得基本格式如下注意没有缩进标准的空格缩进四格注意事项所有基类名应在列限制下尽量与子类名放在同一行访问控制块关键词没有缩进关键词后不要保留空行除第一个关键词外其他关键词前要空一行关于声明顺序的规则请参考声明顺序一节完结撒花正确性稳定性可测试性可读性全局效率局部效率个人习惯正确性指程序要实现设计要求的功能稳定性安全性指程序稳定可靠安全可测试性指程序要具有良好的可测试性规范可读性指程序书写风格命名规则等要符合规范全局效率指软件系统的整体效率局部效率指某个模块子模块函数的本身效率个人表达方式个人方便性指个人编程习惯',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-08-23 00:00:23',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Stack Overflow" type="application/atom+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://cpp-memory-leaks.github.io" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/cpp-memory-leaks" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Stack Overflow</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> Search</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="微信" src="/null"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="/null"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> Newest Comments</span></div><div class="aside-list"><span>loading...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">August 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">March 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">January 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">December 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">November 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">August 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BB%8F%E9%AA%8C/" itemprop="url">经验</a></span><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">C++代码规范</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-08-07T10:57:16.000Z" title="Created 2024-08-07 18:57:16">2024-08-07</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-08-22T16:00:23.215Z" title="Updated 2025-08-23 00:00:23">2025-08-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为深圳"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>深圳</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/img/cpp_default_cover.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://cpp-memory-leaks.github.io/2024/08/07/Cpp%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"><header><a class="post-meta-categories" href="/categories/%E7%BB%8F%E9%AA%8C/" itemprop="url">经验</a><h1 id="CrawlerTitle" itemprop="name headline">C++代码规范</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">OQS</span><time itemprop="dateCreated datePublished" datetime="2024-08-07T10:57:16.000Z" title="Created 2024-08-07 18:57:16">2024-08-07</time><time itemprop="dateCreated datePublished" datetime="2025-08-22T16:00:23.215Z" title="Updated 2025-08-23 00:00:23">2025-08-23</time></header><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.  概述"></a>1.  <strong>概述</strong></h2><p>命名，是计算机史上最难的问题之一，有很多书本都有专门的章节讨论命名规范的问题，鄙人写的总结，是作为一名刚毕业的黄毛小子从刚工作开始积累的，可能没有那些名著写的那么详细，但是贵在真实，我觉得还是有点使用价值的。</p>
<p>我觉得给代码命名有三要：</p>
<ol>
<li>要有区分度</li>
<li>要有辨识度</li>
<li>要够详细（最少的字表达最清楚的意思）</li>
</ol>
<p><strong>不要造字</strong>，你不是仓颉，英语里面有约定俗成的名称缩写，如info-&gt;infomation。</p>
<p><strong>不要为了规范而规范。</strong></p>
<p>目的：<strong>不影响理解、不产生歧义、不增加维护成本足以</strong></p>
<p>旨在<strong>提高代码的可读性、可维护性</strong>，特此制定本规范。参考《Googe C++ Stye Guide》以及《Effective C++》等规范基础上，结合项目开发经验，汇总整理成本规范。</p>
<h2 id="2-头文件"><a href="#2-头文件" class="headerlink" title="2.  头文件"></a>2.  <strong>头文件</strong></h2><h3 id="2-1-头文件保护"><a href="#2-1-头文件保护" class="headerlink" title="2.1   头文件保护"></a>2.1   <strong>头文件保护</strong></h3><p>所有头文件都应该使用**#define**防止头文件被重复包含，命名格式为<FieName>_H，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-前置声明"><a href="#2-2-前置声明" class="headerlink" title="2.2  前置声明"></a>2.2  <strong>前置声明</strong></h3><p>“前置声明”是类、函数和模板的纯粹声明，没伴随着其定义。</p>
<p>在头文件中进行前置声明，可以减少**#incude**的数量，避免多重包含，减少头文件展开的次数，有效的提高编译效率。对于库工程使用前置声明，可以减少内部类的导出。</p>
<p><strong>注意：前置类型的类是不完全类型，只能定义指向该类型的指针或引用，或者声明(但不能定义)以不完全类型作为参数或者返回类型的函数。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incude <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="comment">// #incude &lt;QJsonVaue&gt;</span></span><br><span class="line"><span class="comment">// #incude &lt;QJsonObject&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用前置声明形式代替</span></span><br><span class="line">cass QJsonVaue;</span><br><span class="line">cass QJsonObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 库工程不希望导出的内部类才使用前置声明</span></span><br><span class="line">cass IDictionaryPrivate;</span><br><span class="line">cass SVSEMSHARE_EXPORT IDictionary : pubic QObject</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"></span><br><span class="line">pubic:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> QString&amp; key, <span class="type">const</span> QJsonVaue&amp; vaue)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> QJsonObject&amp; vaus)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-内联函数"><a href="#2-3-内联函数" class="headerlink" title="2.3  内联函数"></a>2.3  <strong>内联函数</strong></h3><p>当函数被声明为内联函数之后，编译器会将其内联展开，而不是按通常的函数调用机制进行调用。</p>
<p><strong>只要当函数只有10行甚至更少时才将其定义为内联函数</strong>，只有内联的函数体较小，内联该函数才可以令目标代码更加高效。对于存取函数以及其他函数比较短，性能关键的函数，鼓励使用内联。</p>
<p><strong>注意：不要内联包含循环或switch语句的函数，可能导致增加代码大小。</strong></p>
<h3 id="2-4-incude的路径及次序"><a href="#2-4-incude的路径及次序" class="headerlink" title="2.4  #incude的路径及次序"></a>2.4  <strong>#incude的路径及次序</strong></h3><p>项目内的头文件按照项目源代码目录树结构排列，头文件包含顺序<strong>项目内头文件</strong>、<strong>其他库头文件</strong>、<strong>Qt库</strong>、<strong>C++库</strong>、C库，通过空行分隔相关头文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 项目内头文件</span></span><br><span class="line"><span class="meta">#incude <span class="string">&quot;Base/NameSpace.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他库头文件</span></span><br><span class="line"><span class="meta">#incude <span class="string">&quot;foo/bar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Qt库头文件</span></span><br><span class="line"><span class="meta">#incude <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++库头文件</span></span><br><span class="line"><span class="meta">#incude <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C库头文件</span></span><br><span class="line"><span class="meta">#incude <span class="string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure>



<h2 id="3-作用域"><a href="#3-作用域" class="headerlink" title="3. 作用域"></a>3. <strong>作用域</strong></h2><h3 id="3-1-命名空间"><a href="#3-1-命名空间" class="headerlink" title="3.1  命名空间"></a>3.1  <strong>命名空间</strong></h3><p>命名空间将全局作用域细分为独立的、具名的作用域，可以有效防止全局作用域的命名冲突。举例来说，两个不同项目的全局作用域都有一个类Foo，这样在编译或运行时会造成冲突。如果每个项目将代码置于不同命名空间中，project1::Foo和project2::Foo作为不同符号自然不会冲突。命名方式参考<a href="#_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%91%BD%E5%90%8D">7.7 命名空间命名</a>，使用方式如下：</p>
<p>全局定义宏包括了以下，所有项目内开发头文件均包含以下内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NameSpace.h</span></span><br><span class="line"><span class="comment">/** 命名空间定义</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIQTEK_NAMESPACE ciqtek</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 命名空间开始</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEGIN_NAMESPACE_CIQTEK namespace CIQTEK_NAMESPACE &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 命名空间结束</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> END_NAMESPACE_CIQTEK &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 命名空间修饰符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIQTEK_QUAIFIER     ::CIQTEK_NAMESPACE::</span></span><br></pre></td></tr></table></figure>

<p>根据全局定义宏文件，头文件以及源文件遵循以下规则编写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h文件</span></span><br><span class="line">BEGIN_NAMESPACE_CIQTEK</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有声明(前置声明除外)都置于命名空间中</span></span><br><span class="line">cass MyCass</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">END_NAMESPACE_CIQTEK</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp文件</span></span><br><span class="line">BEGIN_NAMESPACE_CIQTEK</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义都至于命名空间中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyCass::Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BEGIN_NAMESPACE_CIQTEK</span><br></pre></td></tr></table></figure>

<p><strong>结论：</strong></p>
<p>不建议使用using指示引入整个命名空间的标识符号，在.cpp和.h文件的函数、方法或者类中，可以使用using声明；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在.cpp文件中</span></span><br><span class="line"><span class="comment">// .h文件的话,必须在函数,方法或类的内部使用</span></span><br><span class="line"><span class="keyword">using</span> ::foo::bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不建议 -- 污染命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> foo;</span><br></pre></td></tr></table></figure>

<p><strong>不要在头文件中使用命名空间别名</strong>，因为头文件的别名对包含了该头文件的所有人可见，所以递归包含到其他头文件里；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用别名缩短常用的命名空间——可以在.cpp文件</span></span><br><span class="line"><span class="comment">// .h文件的话,必须在函数,方法或类的内部使用,否则污染命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> fbz = ::foo::bar::baz;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在.h文件里</span></span><br><span class="line"><span class="keyword">namespace</span> ibrarian &#123;</span><br><span class="line"><span class="comment">// 以下别名在所有包含了该头文件的文件中生效</span></span><br><span class="line"><span class="keyword">namespace</span> pd_s = ::pipeine_diagnostics::sidetabe;</span><br><span class="line"></span><br><span class="line"><span class="function">inine <span class="type">void</span> <span class="title">my_inine_function</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 在函数(方法)使用命名别名,限制在函数中</span></span><br><span class="line"><span class="keyword">namespace</span> fbz = ::foo::bar::baz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace ibrarian</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-非成员函数、静态成员函数和全局函数"><a href="#3-2-非成员函数、静态成员函数和全局函数" class="headerlink" title="3.2  非成员函数、静态成员函数和全局函数"></a>3.2  <strong>非成员函数、静态成员函数和全局函数</strong></h3><p>使用静态成员函数或命名空间内的非成员函数，尽量不要用裸的全局函数。将一些列函数直接至于命名空间，不要用类的静态函数模拟出命名空间的效果，类的静态方法应该和类的实例或数据紧密相关。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="keyword">namespace</span> foo_bar &#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;  <span class="comment">// namespace foo_bar</span></span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐,类的内部并没有静态变量,类的实体也没具体功能</span></span><br><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line">cass FooBar </span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-局部变量"><a href="#3-3-局部变量" class="headerlink" title="3.3  局部变量"></a>3.3  <strong>局部变量</strong></h3><p>尽量将函数变量<strong>尽可能置于最小作用域内，并在变量声明时进行初始化</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line">i = <span class="built_in">f</span>(); <span class="comment">// 不推荐——初始化和声明分离</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> j = <span class="built_in">g</span>(); <span class="comment">// 推荐——初始化时声明</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">// 不推荐——用花括号初始化更好</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 推荐——v 一开始就初始化</span></span><br></pre></td></tr></table></figure>

<p>属于whie和for语句的变量尽量在这些语句中正常地声明，这样变量的作用域就被限制在这些语句中了，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在作用域内声明</span></span><br><span class="line"><span class="built_in">whie</span> (<span class="type">const</span> <span class="type">char</span>* p = <span class="built_in">strchr</span>(str, <span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">str = p + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果变量是一个对象,则不适用该方法</span></span><br><span class="line"><span class="comment">// 低效的实现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    Foo f;                  <span class="comment">// 构造函数和析构函数分别调用 1000000 次!</span></span><br><span class="line">    f.<span class="built_in">DoSomething</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应该作用域外声明</span></span><br><span class="line">Foo f;                      <span class="comment">// 构造函数和析构函数只调用 1 次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    f.<span class="built_in">DoSomething</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-类"><a href="#4-类" class="headerlink" title="4. 类"></a>4. <strong>类</strong></h2><h3 id="4-1-构造函数的职责"><a href="#4-1-构造函数的职责" class="headerlink" title="4.1  构造函数的职责"></a>4.1  <strong>构造函数的职责</strong></h3><p><strong>构造函数不得调用虚函数</strong>，如果在构造函数内调用了自身的虚函数，这类调用是不会重定向到子类的虚函数实现的，即当前没有子类化实现，存在隐患。<strong>构造函数不能报告一个非致命错误</strong>，即<strong>构造函数必须成功</strong>，不然会获得一个初始化失败的对象，有可能进入不正常的状态。</p>
<p>如果对象需要进行初始化，考虑使用明确的<strong>init()<strong>方法或使用</strong>工厂模式</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">cass Foo </span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="function">boo <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init方法形式, 需要在类的注释里说明用法</span></span><br><span class="line">&#123;</span><br><span class="line">    Foo *foo = <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line">    <span class="keyword">if</span> (!foo-&gt;<span class="built_in">init</span>()) &#123;</span><br><span class="line">        deete foo;</span><br><span class="line">        foo = nuptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐,容易误用 — 工厂方法</span></span><br><span class="line">cass Foo </span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="function"><span class="type">static</span> Foo *<span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Foo *foo = <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line">        <span class="keyword">if</span> (!foo-&gt;<span class="built_in">init</span>()) &#123;</span><br><span class="line">            deete foo;</span><br><span class="line">            foo = nuptr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> foo;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    Foo *foo = Foo::<span class="built_in">create</span>();</span><br><span class="line">    <span class="keyword">if</span>(nuptr != foo) &#123; <span class="comment">// 功能逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-初始化"><a href="#4-2-初始化" class="headerlink" title="4.2  初始化"></a>4.2  <strong>初始化</strong></h3><p>如果类中定义了成员变量，则必须在类中为每个类提供初始化函数或定义一个构造函数。若未声明构造函数，则编译器会生成一个默认的构造函数，这有可能导致某些成员未被初始化或初始化未不恰当的值。</p>
<p>所以，<strong>确保构造函数将对象的每一个成员变量进行了初始化，且初始化顺序和声明顺序保持一致。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">cass PhoneNumber &#123; ... &#125;;</span><br><span class="line">cass ABEntry </span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="built_in">ABEntry</span>(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> std::string &amp;address,</span><br><span class="line">            <span class="type">const</span> std::ist&lt;PhoneNumber&gt;&amp; phones);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;</span><br><span class="line">    std::string theAddress;</span><br><span class="line">    std::ist&lt;PhoneNumber&gt; thePhones;</span><br><span class="line">    <span class="type">int</span> numTimesConsuted;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐写法 —— 会导致多调用赋值操作函数降低效率</span></span><br><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> std::string &amp;address,</span><br><span class="line">                 <span class="type">const</span> std::ist&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">&#123;</span><br><span class="line">    theName = name;             <span class="comment">// 这些是赋值操作</span></span><br><span class="line">    theAddress = address;       <span class="comment">// 而非初始化</span></span><br><span class="line">    thePhones = phones;</span><br><span class="line">    numTimesConsuted = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐写法 —— 只调用拷贝构造函数</span></span><br><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> std::string &amp;address,</span><br><span class="line">                 <span class="type">const</span> std::ist&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">    : <span class="built_in">theName</span>(name),            <span class="comment">// 这些是初始化操作</span></span><br><span class="line">      <span class="built_in">theAddress</span>(address),</span><br><span class="line">      <span class="built_in">thePhones</span>(phones),</span><br><span class="line">      <span class="built_in">numTimesConsuted</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者在类的成员变量声明时进行初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cass PhoneNumber &#123; ... &#125;;</span><br><span class="line">cass ABEntry </span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="comment">// 不需要对变量进行初始化</span></span><br><span class="line">    <span class="built_in">ABEntry</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">ABEntry</span>(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> std::string &amp;address,</span><br><span class="line">            <span class="type">const</span> std::ist&lt;PhoneNumber&gt;&amp; phones) </span><br><span class="line">    : <span class="built_in">theName</span>(name), <span class="built_in">theAddress</span>(address),      <span class="comment">// 重复操作,会覆盖初值</span></span><br><span class="line">      <span class="built_in">thePhones</span>(phones), <span class="built_in">numTimesConsuted</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 在声明时就初始化成员变量</span></span><br><span class="line">    std::string theName&#123;<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">    std::string theAddress&#123;<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">    std::ist&lt;PhoneNumber&gt; thePhones&#123;&#125;;</span><br><span class="line">    <span class="type">int</span> numTimesConsuted = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-显式构造函数"><a href="#4-3-显式构造函数" class="headerlink" title="4.3  显式构造函数"></a>4.3  <strong>显式构造函数</strong></h3><p>对于单个参数的构造函数，不要定义为隐式类型转换，使用C++关键字<strong>expicit</strong>。</p>
<p><strong>隐式类型转换：</strong>即允许某种类型(称作 源类型)的对象被用于需要另一种类型(称作 目的类型)。例如将一个int类型的参数传递给需要doube类型的函数。通常只有一个参数的构造函数，被看作是一种隐式转换。</p>
<p>除了单参数构造函数外，也适用于除第一个参数以外的其他参数都具有默认参数的构造函数，例如Foo::Foo(string name, int id &#x3D; 42)。<strong>拷贝和移动构造函数</strong>不需要被标记为expicit，因为它们并不进行类型转换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cass Foo </span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="comment">// 以下都需要进行expicit进行显示转换</span></span><br><span class="line">    <span class="function">expicit <span class="title">Foo</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a)</span></span>;</span><br><span class="line">    <span class="function">expicit <span class="title">Foo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> a, <span class="type">const</span> <span class="type">int</span> b = <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 不需要使用expicit</span></span><br><span class="line"><span class="built_in">Foo</span>(<span class="type">const</span> <span class="type">int</span> a, <span class="type">const</span> foat b);</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;);        <span class="comment">// 拷贝构造</span></span><br><span class="line">    <span class="built_in">Foo</span>(Foo&amp;&amp;);             <span class="comment">// 移动构造</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当设计目的用于其他类型进行透明封装的类来说，隐式类型转换是合适的，例如QJsonVaue和QVariant。</p>
<h3 id="4-4-结构体-VS类"><a href="#4-4-结构体-VS类" class="headerlink" title="4.4  结构体 VS类"></a>4.4  结构体 VS类</h3><p>在C++中struct和cass关键词几乎含义一样。对两个关键字进行进一步规定是，<strong>struct用来定义包含数据的被动式对象，也可以包含相关的常量</strong>。但除了存取数据成员以外，没有别的操作函数功能。并且<strong>存取功能通过直接访问位域，而非函数调用</strong>。除了构<strong>造函数、析构函数、initiaize初始化数据、reset重置数据、operator&#x3D;&#x3D;数据对比操作符重载等</strong>类似用于设定数据成员的函数外，不能提供其他功能函数<strong>。</strong>如果需要更多函数功能，使用cass代替struct。</p>
<h3 id="4-5-接口"><a href="#4-5-接口" class="headerlink" title="4.5  接口"></a>4.5  <strong>接口</strong></h3><p>当一个类满足以下要求时，称之为纯接口。类应以I为开头命名，如IFoo。</p>
<ul>
<li>只有纯虚函数(“&#x3D;0”)和静态函数(析构函数除外)；</li>
<li>没有定义任何构造函数。如果有，也不能带有参数，并且必须为<strong>protected</strong>；</li>
<li>如果它是一个子类，也只能从满足上述条件的类继承。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类为非接口类</span></span><br><span class="line">cass Foo</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误 —— 基类非接口类</span></span><br><span class="line">cass IBar : pubic Foo</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="function">virtua <span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有纯虚函数 </span></span><br><span class="line">cass IProcessCommunicationCaback</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="function">virtua <span class="type">void</span> <span class="title">onConnected</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function">virtua <span class="type">void</span> <span class="title">onDisconnected</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承于接口类才能定义为接口类</span></span><br><span class="line">cass IBar : pubic IProcessCommunicationCaback</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="function">virtua <span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以I为前缀可以提醒该类为纯接口类，这一点对于<strong>多重继承</strong>尤其重要。</p>
<p>​    由于接口类不能被直接实例化，为确保接口类的所有实现可被正确销毁，必须为之声明<strong>虚析构函数</strong>。</p>
<h3 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6  继承"></a>4.6  继承</h3><p>当子类继承基类时，子类包含了父基类所有数据及操作的定义。继承主要用于两种场景：实现继承，子类继承父类的实现代码；接口继承，子类仅继承父类的接口名称。</p>
<p><strong>尽量使用pubic继承，不要使用private继承，而应该替换成把类的实例作为成员对象的方式</strong>。避免过度使用继承，要尽量做到只在“是一种”的情况下使用继承，例如QFrame是“是一种”控件，QFrame继承于QWidget。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cass Foo </span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cass Bar : <span class="keyword">private</span> Foo <span class="comment">// 禁止</span></span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; <span class="built_in">foo</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cass Bar</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; f.<span class="built_in">foo</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Foo f&#123;&#125;;    <span class="comment">// 应该以类的成员变量形式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果类确定存在继承关系，作为基类应该将<strong>析构函数</strong>声明为virtua。相反，当类的设计目的不是作为基类，或不具有多态性，就不将析构函数声明为<strong>virtua</strong>。而当类中存在虚函数，则析构函数也应该声明为<strong>virtua</strong>。</p>
<p><strong>注意：析构函数与构造函数相同，也不应该调用虚函数或者发生错误。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为基类,必须将析构函数声明为virtua</span></span><br><span class="line">cass Base</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    virtua ~<span class="built_in">Base</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cass Derived : pubic Base</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类中存在virtua函数,必须将析构函数声明为virtua</span></span><br><span class="line">cass Foo</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    virtua ~<span class="built_in">Foo</span>();       <span class="comment">// 定义虚函数foo,析构函数声明为virtua</span></span><br><span class="line">    <span class="function">virtua <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-7-多重继承"><a href="#4-7-多重继承" class="headerlink" title="4.7  多重继承"></a>4.7  多重继承</h3><p>只有以下情况允许多重继承：<strong>只有一个基类是非抽象类，其他基类都是以I为前缀的纯接口类。</strong>继承顺序应从非抽象类，再到纯接口类的顺序进行继承。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">cass Foo</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cass Bar</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cass IBar</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="function">virtua <span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误 —— Foo和Bar都是非抽象类</span></span><br><span class="line">cass Baz : pubic Foo, pubic Bar</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确 —— Foo为非抽象类,IBar为纯接口类</span></span><br><span class="line">cass Baz : pubic Foo, pubic IBar</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-8-声明顺序"><a href="#4-8-声明顺序" class="headerlink" title="4.8  声明顺序"></a>4.8  声明顺序</h3><p>类的访问控制区段的声明为：pubic:、protected:、private:。如果某区段没有内容可以不声明，注释方式参考<a href="#_%E6%B3%A8%E9%87%8A">8. 注释</a>。每个区段内的声明通常按以下顺序：</p>
<ul>
<li>typedefs和枚举</li>
<li>常量</li>
<li>构造函数</li>
<li>析构函数</li>
<li>成员函数，包含静态成员函数</li>
<li>槽函数(公有继承后跟信号)</li>
<li>数据成员，包含静态数据成员</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">cass Foo : pubic QObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Q_OBJECT</span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(<span class="type">int</span> m_foo READ foo)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">pubic:</span></span><br><span class="line"><span class="function">    // 公有成员</span></span><br><span class="line"><span class="function">    Foo();</span></span><br><span class="line">    ~<span class="built_in">Foo</span>();</span><br><span class="line">    <span class="comment">// 成员函数，包含静态成员函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">pubic Q_SOTS:</span><br><span class="line">    <span class="comment">// 公有槽函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sotFoo</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">Q_SIGNAS:</span><br><span class="line">    <span class="comment">// 信号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">signaFoo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 保护成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Q_SOTS:</span><br><span class="line">    <span class="comment">// 保护槽函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sotBar</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">baz</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> Q_SOTS:</span><br><span class="line">    <span class="comment">// 私有槽函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sotBar</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有成员,友元类</span></span><br><span class="line">    <span class="type">int</span> m_foo;</span><br><span class="line">    <span class="keyword">friend</span> cass faz;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-9-存取控制"><a href="#4-9-存取控制" class="headerlink" title="4.9  存取控制"></a>4.9  <strong>存取控制</strong></h3><p>将<strong>所有数据成员</strong>声明为<strong>private</strong>，并根据需要提供响应的存取函数。静态常量数据成员可以不是私有成员。</p>
<p>存取函数一般在头文件中定义为内联函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cass Foo</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="function">inine <span class="type">int</span> <span class="title">getBar</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">inine <span class="type">void</span> <span class="title">setBar</span><span class="params">(<span class="type">const</span> <span class="type">int</span> vaue)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_bar;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="5-函数"><a href="#5-函数" class="headerlink" title="5. 函数"></a>5. <strong>函数</strong></h2><p>函数命名规则参考<a href="#_%E5%87%BD%E6%95%B0%E5%91%BD%E5%90%8D">7.6函数命名</a>。</p>
<h3 id="5-1-参数"><a href="#5-1-参数" class="headerlink" title="5.1  参数"></a>5.1  <strong>参数</strong></h3><p>函数的参数顺序为：输入参数在前，输出参数包含输入输出参数在后</p>
<p>C&#x2F;C++中的函数参数可能是输入参数，也可能是输出参数，或者是输入输出参数。输入参数通常是<strong>const值传递</strong>或者const引用或指针*，输出参数或输入输出参数则为<strong>非const指针或引用</strong>。更多说明参考<a href="#_const%E7%94%A8%E6%B3%95">6.4 const用法</a>。</p>
<p>在加入新参数时不要因为它们时新参数就置于参数列表最后，而是仍然要按照输入参数在前，输入参数在后的原则。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cass Foo</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="comment">// 内置类型输入参数或者ST的迭代器,用const值传递</span></span><br><span class="line">    <span class="comment">// baz作为输出参数用非const指针形式传入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> <span class="type">int</span> bar, foat *baz)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *bar, foat *baz)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> std::vector::iterator iter, foat *baz)</span></span>;</span><br><span class="line">    <span class="comment">// 当输入参数为对象,则用const引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> std::string&amp; bar, foat *baz)</span></span>;<span class="comment">// 推荐—直观看出输入/输出参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> std::string&amp; bar, foat &amp;baz)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意：这一条不是硬性规定，属于推荐写法，实际情况复杂时，可以进行更改。</strong></p>
<h3 id="5-2-编写简短函数"><a href="#5-2-编写简短函数" class="headerlink" title="5.2  编写简短函数"></a>5.2  <strong>编写简短函数</strong></h3><p>函数的编写尽量简练。目的是使函数实现的逻辑结构化、清晰化，便于阅读与维护。</p>
<p>如果函数行数太多(超过40行，后成为长函数)，可以考虑将长函数拆分成几个短函数，是函数尽量简短，便于阅读和维护。</p>
<p><strong>注意：长函数按照具体情况而定，例如对于部分if和switch逻辑，分支过长就不遵行本条规定。</strong></p>
<h2 id="6-其他C-特性"><a href="#6-其他C-特性" class="headerlink" title="6.  其他C++特性"></a>6.  <strong>其他C++特性</strong></h2><h3 id="6-1-异常"><a href="#6-1-异常" class="headerlink" title="6.1  异常"></a>6.1  <strong>异常</strong></h3><p><strong>禁止C++异常机制</strong>，所有错误都应该通过错误值在函数之间传递并做出相应判断，而不应该通过异常进行错误处理。<strong>例外：在接管C++语言本身抛出的异常(例如new失败、ST)、第三方库(例如Qt)抛出的异常时，可以使用异常机制</strong>。</p>
<p>面对异常首先考虑是否为操作错误，例如参数范围问题，应该在代码进行入参检测；例如Qt库中出现私有类指针为野指针，应该从析构问题解决；这些问题都不应该从接异常解决。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> en = ...;</span><br><span class="line"><span class="type">char</span> *p = nuptr;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">char</span>[en];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (bad_aoc) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-类型转换"><a href="#6-2-类型转换" class="headerlink" title="6.2 类型转换"></a>6.2 <strong>类型转换</strong></h3><p>使用C++的类型转换，如static_cast&lt;&gt;()。而不是使用int y &#x3D; (int)x或int y &#x3D; int(x)等转换形式。即<strong>不要使用C风格进行类型转换，而应该使用C++风格</strong>。</p>
<ul>
<li>用static_cast替代C风格的值转换，或某个类的指针需要明确向上转换为父类指针；</li>
<li>用const_cast去掉const限定符；</li>
<li>用reinterpret_cast指针类型和整型和其他类型指针进行转换；</li>
<li>用dynamic_cast转换存在继承关系的对象。</li>
</ul>
<h3 id="6-3-前置自增和自减"><a href="#6-3-前置自增和自减" class="headerlink" title="6.3  前置自增和自减"></a>6.3  <strong>前置自增和自减</strong></h3><p>**对于迭代器和其他模板类型使用前缀形式(++i)*的自增、自减运算符，对于简单数值(非对象)，两种都无所谓**。在不考虑返回值的情况，前置自增(++i)通常要比后置自增(i++)效率更高。因为后置自增(或自减)需要对表达式的值i进行一次拷贝。如果i是迭代器或其他非数值类型，拷贝的代价比较大。所以推荐使用前置自增。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector vec;</span><br><span class="line"><span class="keyword">for</span>(std::vector::iterator iter = vec.<span class="built_in">begin</span>();</span><br><span class="line">    iter != vec.<span class="built_in">end</span>(); ++iter); <span class="comment">// 推荐 —— 效率更高</span></span><br><span class="line"><span class="keyword">for</span>(std::vector::iterator iter = vec.<span class="built_in">begin</span>();</span><br><span class="line">    iter != vec.<span class="built_in">end</span>(); iter++); <span class="comment">// 不推荐 —— 需要进行多次拷贝构造</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 简单数值(内置类型),两者均可</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++); </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i); <span class="comment">// 更推荐,保证习惯一致</span></span><br></pre></td></tr></table></figure>

<h3 id="6-4-const用法"><a href="#6-4-const用法" class="headerlink" title="6.4  const用法"></a>6.4  <strong>const用法</strong></h3><p>const变量、数据成员、函数和参数为编译时进行类型检测增加了一道屏障，便于尽早发现问题，参考<a href="#_%E5%8F%82%E6%95%B0">5.1 参数</a>。因此尽可能的情况下使用const，参考：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cass Bar&#123;&#125;;</span><br><span class="line">cass Foo</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getBar</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_bar; &#125; <span class="comment">// 访问函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setBar</span><span class="params">(<span class="type">const</span> <span class="type">int</span> b)</span></span>; &#123; m_bar = b &#125;; <span class="comment">// 函数传入不会修改的参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sum</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">getBar</span>() + m_CONST_VAUE; &#125; <span class="comment">// 未调用非const函数</span></span><br><span class="line"><span class="function"><span class="type">const</span> Bar&amp; <span class="title">getCBar</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_cBar; &#125; <span class="comment">// 返回const引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_bar;</span><br><span class="line">Bar m_cBar;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> m_CONST_VAUE = <span class="number">10</span>; <span class="comment">// 构造之后不会修改的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果函数不会修改传入的引用或指针类型参数，该参数应声明为const；</li>
<li>尽可能将函数声明为const。访问函数应该总是const。其他不会修改任何数据成员，未调用非const函数，返回数据成员为指针或引用也应该声明成const；</li>
<li>如果数据成员在对象构造之后不再发生变化，可将其定义未const。</li>
</ul>
<h3 id="6-5-预处理宏"><a href="#6-5-预处理宏" class="headerlink" title="6.5   预处理宏"></a>6.5   <strong>预处理宏</strong></h3><p>宏意味着你和编译器看到的代码时不同的，这可能会导致异常行为，而且宏具有全局作用域。尽量<strong>以内联函数、枚举和常量代替宏定义</strong>。命名规则参考<a href="#_%E5%B8%B8%E9%87%8F%E5%91%BD%E5%90%8D">7.5 常量命名</a>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const替换#define</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASPECT_RATIO 1.653</span></span><br><span class="line"><span class="type">const</span> doube ASPECT_RATIO = <span class="number">1.653</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AUTHOR_NAME <span class="string">&quot;Scott Meyers&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> std::string <span class="title">AUTHOR_NAME</span><span class="params">(<span class="string">&quot;Scott Meyers&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inine替换#define</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CA_WITH_MAX(a,b) f((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">CA_WITH_MAX</span>(++a, b);       <span class="comment">// a被累加两次</span></span><br><span class="line"><span class="built_in">CA_WITH_MAX</span>(++a, b + <span class="number">10</span>);  <span class="comment">// a被累加一次</span></span><br><span class="line"><span class="function">tempate&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">inine <span class="type">void</span> <span class="title">caWithMax</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// enum替换#define</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_TURNS 5</span></span><br><span class="line">cass CostEstimate </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> scores[NUM_TURNS];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cass CostEstimate </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; NumTurns = <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="type">int</span> scores[NumTurns];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-6-sieof"><a href="#6-6-sieof" class="headerlink" title="6.6  sieof"></a>6.6  <strong>sieof</strong></h3><p>尽可能用sizeof(varname)代替sizeof(type)。使用sizeof(varname)时因为当代码中变量类型改变时会自动更新。当用sizeof(type)处理不涉及任何变量的代码，比如处理来自外部或内部的数据格式时，sizeof(varname)就不适用了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Struct data;</span><br><span class="line"><span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="built_in">sizeof</span>(data));     <span class="comment">// 推荐 —— 当data改成其他类型时不影响运行</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="built_in">sizeof</span>(Struct));   <span class="comment">// 不推荐 —— 改为其他类型未做修改可能导致BUG</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不适用sizeof(varname)情况</span></span><br><span class="line"><span class="keyword">if</span> (raw_size &lt; <span class="built_in">sizeof</span>(<span class="type">int</span>)) &#123;</span><br><span class="line">    <span class="built_in">OG</span>(ERROR) &lt;&lt; <span class="string">&quot;compressed record not big enough for count:&quot;</span> &lt;&lt; raw_size;</span><br><span class="line">    <span class="keyword">return</span> fase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-7-auto"><a href="#6-7-auto" class="headerlink" title="6.7  auto"></a>6.7  <strong>auto</strong></h3><p>C++11中，若变量被声明为auto，类型就会被自动匹配成初始化表达式的类型。用auto绕过繁琐的类型名，只要可读性好就可以使用，但不要用在局部变量之外的地方。<strong>auto不要用在初始化列表</strong>，会导致歧义，同时要注意区分*<em>auto</em>和const* *<strong>auto</strong>&amp;*。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 涉及模板类或命名空间时,类型名会很复杂</span></span><br><span class="line">sparse_hash_map&lt;string, <span class="type">int</span>&gt;::iterator iter = m.<span class="built_in">find</span>(va);</span><br><span class="line"><span class="comment">// 修改为auto显得直观(因为iter一般是迭代器变量,即m的迭代器)</span></span><br><span class="line"><span class="keyword">auto</span> iter = m.<span class="built_in">find</span>(va);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有auto的话，我们不得不在同一个表达式出现两次类型名</span></span><br><span class="line">diagnostics::ErrorStatus* status = <span class="keyword">new</span> diagnostics::<span class="built_in">ErrorStatus</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line"><span class="comment">// 使用auto就简单且不会有歧义</span></span><br><span class="line"><span class="keyword">auto</span> status = <span class="keyword">new</span> diagnostics::<span class="built_in">ErrorStatus</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> i = x.<span class="built_in">ookup</span>(key); <span class="comment">// 不推荐 —— 代码不能直观看出i是何种类型</span></span><br><span class="line">vector&lt;string&gt; v;</span><br><span class="line"><span class="keyword">auto</span> s1 = v[<span class="number">0</span>]; <span class="comment">// 创建一份v[0]的拷贝</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; s2 = v[<span class="number">0</span>]; <span class="comment">// s2是v[0]的一个引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// auto不要用在初始化列表</span></span><br><span class="line"><span class="keyword">auto</span> d = &#123;<span class="number">1.23</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> d&#123;<span class="number">1.23</span>&#125;;           <span class="comment">// d是std::initiazer_ist&lt;doube&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> d = doube&#123;<span class="number">1.23</span>&#125;;  <span class="comment">// d是doube,并非std::initiazer_ist</span></span><br></pre></td></tr></table></figure>

<h3 id="6-8-lambda表达式"><a href="#6-8-lambda表达式" class="headerlink" title="6.8  lambda表达式"></a>6.8  <strong>lambda表达式</strong></h3><p>ambda表达式是创建匿名函数对象的一种简易途径，常用于把函数当参数传递，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Weight</span>(x) &lt; <span class="built_in">Weight</span>(y);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当ambda变量需要捕获识，<strong>禁止使用通用捕获，将所有的捕获都显式写出来</strong>，增加可读性。使用引用捕获时，变量名和&amp;之间不留空格</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">[=](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x + n; &#125;    <span class="comment">// 不推荐—使用默认捕获</span></span><br><span class="line">[n](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x + n; &#125;    <span class="comment">// 推荐—显式捕获n写出来</span></span><br><span class="line">[&amp;n](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x + n; &#125;    <span class="comment">// &amp;和n不留空格</span></span><br></pre></td></tr></table></figure>

<p>ambda表达式用于参数传递时，如果函数体超过五行，应当将ambda表达式转换为std::function对象；如果是作为connect的槽函数，则改用函数的形式。</p>
<h2 id="7-命名约定"><a href="#7-命名约定" class="headerlink" title="7.  命名约定"></a>7.  <strong>命名约定</strong></h2><p>命名的风格能让我们在不需要去查找类型声明的条件下快速了解某个名字代表的含义：<strong>类型、变量、函数、常量、宏、信号、槽函数</strong>等等。</p>
<h3 id="7-1-通用命名约定"><a href="#7-1-通用命名约定" class="headerlink" title="7.1  通用命名约定"></a>7.1  <strong>通用命名约定</strong></h3><p>名称由<strong>字母、数字以及下划线组合而成，且第一位不能为数字，小驼峰命名方式</strong>。</p>
<p>尽量使用描述性的命名，少用缩写(除了一些广泛接受的缩写，例如iter表示迭代器、用T表示模板参数)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> priceCountReader;       <span class="comment">// 无缩写</span></span><br><span class="line"><span class="type">int</span> numError;               <span class="comment">// &quot;num&quot;是常见的缩写</span></span><br><span class="line"><span class="type">int</span> numDNSConnection;       <span class="comment">// DNS是都知道的概念</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;                      <span class="comment">// 不清楚作用和意义</span></span><br><span class="line"><span class="type">int</span> nCompConns;             <span class="comment">// 缩写不知道代表何种意思</span></span><br><span class="line"><span class="type">int</span> wgcConnections;         <span class="comment">// &quot;wgc&quot;是何种意思</span></span><br><span class="line"><span class="type">int</span> pcReader;               <span class="comment">// &quot;pc&quot;可能出现歧义</span></span><br><span class="line"><span class="type">int</span> cstmrID;                <span class="comment">// 缩写若干字母</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2-文件命名"><a href="#7-2-文件命名" class="headerlink" title="7.2  文件命名"></a>7.2  <strong>文件命名</strong></h3><p>文件命名<strong>使用大驼峰命名方式，定义类和文件名一般成对出现</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NameSpace.h</span></span><br><span class="line"><span class="comment">// 文件名说明作用,如NameSpace.h存放关于NameSpace的声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 命名空间定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIQTEK_NAMESPACE ciqtek</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 命名空间开始</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEGIN_NAMESPACE_CIQTEK namespace CIQTEK_NAMESPACE &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 命名空间结束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> END_NAMESPACE_CIQTEK &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 命名空间修饰符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIQTEK_QUAIFIER     ::CIQTEK_NAMESPACE::</span></span><br><span class="line"><span class="comment">// AgorithmAutogamma.h</span></span><br><span class="line"><span class="comment">// 文件名和类名一一对应,成对存在</span></span><br><span class="line">cass AgorithmAutogamma</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-类型命名"><a href="#7-3-类型命名" class="headerlink" title="7.3  类型命名"></a>7.3  <strong>类型命名</strong></h3><p>类型命名的<strong>每个单词首字母都是大写，不包含下划线，大驼峰命名方式</strong>。所有类型命名——类、结构体、类型定义(typedef)、枚举、类型模板参数均使用本约定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类和结构体</span></span><br><span class="line">cass UrTabe &#123;&#125;;</span><br><span class="line">cass UrTabeTester &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UrTabeProperties</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> hash_map&lt;UrTabeProperties *, string&gt; PropertiesMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// using 别名</span></span><br><span class="line"><span class="keyword">using</span> PropertiesMap = hash_map&lt;UrTabeProperties *, string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">UrTabeErrors</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型模板参数</span></span><br><span class="line"><span class="function">tempate&lt;<span class="keyword">typename</span> UrInfo&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setUr</span><span class="params">(<span class="type">const</span> UrInfo&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-变量命名"><a href="#7-4-变量命名" class="headerlink" title="7.4  变量命名"></a>7.4  <strong>变量命名</strong></h3><p>变量(包含函数参数)和数据成员名<strong>一律用小驼峰命名方式，每行一个变量，单字符的变量只在循环计数中使用</strong>。对于不同作用域的变量遵循以下规则：</p>
<ul>
<li>类成员变量须在变量名前加m_前缀。</li>
<li>局部变量等到需要使用时再定义，且定义是必须要初始化，整数为0，实数用0.0，指针用nuptr，字符(串)用’\0’。</li>
<li>全局变量命名时须在变量前加g_前缀。</li>
<li>静态变量名以s_开头。</li>
</ul>
<table>
<thead>
<tr>
<th>前缀</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>无</td>
<td>局部变量(oca)</td>
<td>odVaue</td>
</tr>
<tr>
<td>m_</td>
<td>类的成员变量(member)</td>
<td>int m_width</td>
</tr>
<tr>
<td>ms_</td>
<td>类的静态成员变量(static member)</td>
<td>static int ms_initVaue</td>
</tr>
<tr>
<td>s_</td>
<td>静态变量(static)</td>
<td>static int s_initVaue</td>
</tr>
<tr>
<td>g_</td>
<td>外部全局变量</td>
<td>int g_maxCount</td>
</tr>
<tr>
<td>sg_</td>
<td>静态全局变量(static goba)</td>
<td>static int sg_exampe</td>
</tr>
<tr>
<td>gg_</td>
<td>进程间共享的数据段全局变量(goba goba)</td>
<td>int gg_shareVaue</td>
</tr>
</tbody></table>
<h3 id="7-5-常量命名"><a href="#7-5-常量命名" class="headerlink" title="7.5  常量命名"></a>7.5  <strong>常量命名</strong></h3><p>常量*<em>不含前缀且应该大写，单词间由下滑线，包含constexpr</em>、const以及宏定义。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> DAYS_IN_AWEEK = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> DAYS_IN_AWEEK = <span class="number">7</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DAYS_IN_AWEEK 7 <span class="comment">// 不推荐写法,命名方式按常量命名规则</span></span></span><br></pre></td></tr></table></figure>

<h3 id="7-6-函数命名"><a href="#7-6-函数命名" class="headerlink" title="7.6  函数命名"></a>7.6  <strong>函数命名</strong></h3><p>函数命名以及函数参数<strong>都使用小驼峰命名方式，函数名时动词或含有动词的短语，函数参数若非基础数据类型，使用对象引用</strong>。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getVaue</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setVaue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> vaue)</span></span>;         <span class="comment">// 基础类型(迭代器)值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setCoor</span><span class="params">(<span class="type">const</span> QCoor&amp; newCoor)</span></span>;  <span class="comment">// 非基础类型引用传递</span></span><br></pre></td></tr></table></figure>

<p><em>当函数为信号或者槽函数时，应分别在前加上signa*\和sot前缀。</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">signaogWritten</span><span class="params">(<span class="type">const</span> ogeve &amp;eve, <span class="type">const</span> QString &amp;og)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sotogWrite</span><span class="params">(<span class="type">const</span> ogeve &amp;eve, <span class="type">const</span> QString &amp;og)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="7-7-命名空间命名"><a href="#7-7-命名空间命名" class="headerlink" title="7.7   命名空间命名"></a>7.7   <strong>命名空间命名</strong></h3><p>命名空间的名称是名词，<strong>用小写字母命名</strong>，每个单词以下划线分割，例如：ciqtek。</p>
<h3 id="7-8-枚举命名"><a href="#7-8-枚举命名" class="headerlink" title="7.8  枚举命名"></a>7.8  <strong>枚举命名</strong></h3><p>枚举名和枚举值<strong>都是名词</strong>，和常量或宏规则一致，<strong>枚举值每个字母均为大写，单词之间以下划线间隔，枚举名为大驼峰命名方式</strong>。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyCoor</span> <span class="comment">// 枚举名</span></span><br><span class="line">&#123;</span><br><span class="line">    WHITE, <span class="comment">// 枚举值</span></span><br><span class="line">BACK,</span><br><span class="line">SKY_BUE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="7-9-结构体命名"><a href="#7-9-结构体命名" class="headerlink" title="7.9   结构体命名"></a>7.9   <strong>结构体命名</strong></h3><p>结构体中只定义变量，不定义函数。需要定义函数的结构体，转换成类实现。</p>
<p><strong>结构体名</strong>是名词，<strong>每个单词以大写字母开头，大驼峰命名方式</strong>。<strong>结构体成员</strong>是名词，以<strong>小驼峰命名方式</strong>，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyCoor</span></span><br><span class="line">&#123;</span><br><span class="line">    boo isMyCoor;</span><br><span class="line">    <span class="type">int</span> white;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="7-10-获取器和设置器命名"><a href="#7-10-获取器和设置器命名" class="headerlink" title="7.10   获取器和设置器命名"></a>7.10   <strong>获取器和设置器命名</strong></h3><p>获取器和设置器都是根据约定俗成的命名规则：</p>
<ul>
<li>非布尔型的获取器**coor()<strong>或者</strong>getCoor()**；</li>
<li>布尔型的获取器**isChecked()**；</li>
<li>设置器**Coor(const Coor&amp; newCoor)**。</li>
</ul>
<h3 id="7-11-界面控件命名"><a href="#7-11-界面控件命名" class="headerlink" title="7.11  界面控件命名"></a>7.11  <strong>界面控件命名</strong></h3><p>控件命名应以控件类型结尾，以说明控件的类型，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 界面中有且仅有一种该类型控件</span></span><br><span class="line">QPainTextEdit *textEdit;</span><br><span class="line">Qabe *abe;</span><br><span class="line">QineEdit *ineEdit;</span><br><span class="line"><span class="comment">// 界面中出现多种重复的控件,应将前面补充说明</span></span><br><span class="line">Qabe *contentsabe;</span><br><span class="line">QPushButton *findButton;</span><br><span class="line">QTooBar *fieTooBar;</span><br><span class="line">QComboBox *caseComboBox;</span><br><span class="line">QSpinBox *maxVisibeSpinBox;</span><br><span class="line">QCheckBox *wrapCheckBox;</span><br></pre></td></tr></table></figure>



<h2 id="8-注释"><a href="#8-注释" class="headerlink" title="8. 注释"></a>8. <strong>注释</strong></h2><p>一般情况下源程序有效注释量必须在20%以上，不易理解的地方都需加上注释，需要简单精炼。</p>
<h3 id="8-1-注释风格"><a href="#8-1-注释风格" class="headerlink" title="8.1  注释风格"></a>8.1  <strong>注释风格</strong></h3><p>头文件注释风格需要兼容Doxygen注释方式，便于生成说明文档。源文件注释使用&#x2F;&#x2F;或&#x2F;* *&#x2F;都可以。</p>
<h3 id="8-2-头文件注释"><a href="#8-2-头文件注释" class="headerlink" title="8.2  头文件注释"></a>8.2  <strong>头文件注释</strong></h3><p>头文件注释包括<strong>版权说明、版本号、作者、生成日期、描述信息</strong>等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">**Copyright(C), 2021-2022, Ciqtek Technoogy.</span></span><br><span class="line"><span class="comment">**Version:     1.0</span></span><br><span class="line"><span class="comment">**Author:      dingyy</span></span><br><span class="line"><span class="comment">**Date:        $DATE$</span></span><br><span class="line"><span class="comment">**Description: </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="8-3-类注释"><a href="#8-3-类注释" class="headerlink" title="8.3  类注释"></a>8.3  <strong>类注释</strong></h3><p>类注释<strong>包括描述信息，有必要时需将使用方法加到注释中</strong>。</p>
<p>简单类只需要包含简要说明信息即可，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief    类描述信息</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>当类需要添加实例代码时候，按以下方式进行备注：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief    类描述信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   Exampe of usage:</span></span><br><span class="line"><span class="comment"> *   @code</span></span><br><span class="line"><span class="comment"> *       示例代码</span></span><br><span class="line"><span class="comment"> *   @endcode</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="8-4-函数注释"><a href="#8-4-函数注释" class="headerlink" title="8.4  函数注释"></a>8.4  <strong>函数注释</strong></h3><p>函数注释主要<strong>包括描述信息、参数信息、返回值以及返回值说明，有必要时加入注解信息</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief          函数名 函数简介</span></span><br><span class="line"><span class="comment"> * @param          形参 参数说明</span></span><br><span class="line"><span class="comment"> * @return         返回说明</span></span><br><span class="line"><span class="comment"> *   @retva 0     (非必要)返回值说明</span></span><br><span class="line"><span class="comment"> *   @retva 1     (非必要)返回值说明</span></span><br><span class="line"><span class="comment"> * @note           (非必要)注释信息</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="8-5-变量注释"><a href="#8-5-变量注释" class="headerlink" title="8.5  变量注释"></a>8.5  <strong>变量注释</strong></h3><p>类的数据成员变量按需进行注释，<strong>全局变量需要注释说明含义及用途</strong>。变量注释<strong>置于变量的上方</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 回归测试用例总数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_TEST_CASES = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<h3 id="8-6-实现注释"><a href="#8-6-实现注释" class="headerlink" title="8.6  实现注释"></a>8.6  <strong>实现注释</strong></h3><p>对于实现代码中巧妙的、隐晦的、重要的地方加以注释。<strong>注意后跟一个空格</strong>。</p>
<p><strong>巧妙或复杂的代码在代码块上方注释</strong>，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将结果除以2,考虑到x包含加法的进位</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; resut-&gt;<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    x = (x &lt;&lt; <span class="number">8</span>) + (*resut)[i];</span><br><span class="line">    (*resut)[i] = x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    x &amp;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-7-枚举和结构体注释"><a href="#8-7-枚举和结构体注释" class="headerlink" title="8.7  枚举和结构体注释"></a>8.7  <strong>枚举和结构体注释</strong></h3><p>枚举注释需要对<strong>枚举、枚举值</strong>进行说明。</p>
<p>结构体注释需要对<strong>结构体、成员变量</strong>进行说明。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief     日志类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ogeve</span> </span><br><span class="line">&#123;</span><br><span class="line">    OG_EVE_TRACE = <span class="number">0</span>,             <span class="comment">///&lt; TARCE输出 </span></span><br><span class="line">    OG_EVE_DEBUG = <span class="number">10000</span>,         <span class="comment">///&lt; DEBUG输出 </span></span><br><span class="line">    OG_EVE_INFO = <span class="number">20000</span>,          <span class="comment">///&lt; INFO输出 </span></span><br><span class="line">    OG_EVE_WARN = <span class="number">30000</span>,          <span class="comment">///&lt; WARN输出 </span></span><br><span class="line">    OG_EVE_ERROR = <span class="number">40000</span>,         <span class="comment">///&lt; ERROR输出 </span></span><br><span class="line">    OG_EVE_FATA = <span class="number">50000</span>,         <span class="comment">///&lt; FATA输出 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief     自定义颜色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyCoor</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> red;        <span class="comment">///&lt; 红色分量</span></span><br><span class="line">    <span class="type">int</span> green;      <span class="comment">///&lt; 绿色分量</span></span><br><span class="line">    <span class="type">int</span> bue;       <span class="comment">///&lt; 蓝色分量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="8-8-TODO注释"><a href="#8-8-TODO注释" class="headerlink" title="8.8   TODO注释"></a>8.8   <strong>TODO注释</strong></h3><p>对于<strong>临时的、短期的方案，或计划中但未完成的代码，或已实现功能但待优化的代码</strong>使用TODO注释。TODO注释需要<strong>作者、日期</strong>利于后期检索，避免查找困难，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MyCass::test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 计划但未完成</span></span><br><span class="line"><span class="comment">// TODO - Barmaco 2022/01/18 9:59 实现xx相关功能</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO - Barmaco 2022/01/18 9:59 临时方案</span></span><br><span class="line">    <span class="keyword">return</span> (a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyCass::doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// TODO - Barmaco 2022/01/18 9:59 待优化</span></span><br><span class="line">    <span class="type">int</span> x = (x &lt;&lt; <span class="number">8</span>) + (*resut)[i];</span><br><span class="line">    (*resut)[i] = x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    x &amp;= <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="9-格式"><a href="#9-格式" class="headerlink" title="9. 格式"></a>9. <strong>格式</strong></h2><h3 id="9-1-行长度"><a href="#9-1-行长度" class="headerlink" title="9.1  行长度"></a>9.1  <strong>行长度</strong></h3><p>较长的语句(&gt;80字符)要分成多行书写，长表达式要<strong>在较低优先级操作符处划分新行，操作符放在新行之首，逗号放在一行的结束，划分出的新行要进行适当的缩进</strong>，使排版整齐，语句可读，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((taskOne &lt; taskNumber) &amp;&amp; (taskTwo &lt; taskNumber) </span><br><span class="line">    &amp;&amp; (taskThree &lt; taskNumber) &amp;&amp;(taskFour &lt; taskNumber)) &#123;</span><br><span class="line">&#125; <span class="comment">// 操作符放在新行之首</span></span><br><span class="line">boo retva = <span class="built_in">doSomething</span>(averyveryveryveryveryveryongargument1,</span><br><span class="line">                          argument2, argument3); <span class="comment">// 后一行与第一个实参对齐</span></span><br></pre></td></tr></table></figure>

<h3 id="9-2-文件编码"><a href="#9-2-文件编码" class="headerlink" title="9.2  文件编码"></a>9.2  <strong>文件编码</strong></h3><p>为了统一文件编码，避免开发过程中文件编码混乱问题，文件保存过程中，<strong><em>统一使用UTF-8无签名</em>编码</strong>。编码转换时，默认在UTF-8中转换。</p>
<p>下载VS插件Force UTF-8(No BOM)，选择第一个点击下载→关闭并重启VS安装插件。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/CodeStyle/image-20250317195151183.png" alt="image-20250317195151183"></p>
<h3 id="9-3-缩进"><a href="#9-3-缩进" class="headerlink" title="9.3  缩进"></a>9.3  <strong>缩进</strong></h3><p><strong>使用4个空格进行代码缩进，禁止使用制表符。</strong></p>
<h3 id="9-4-大括号"><a href="#9-4-大括号" class="headerlink" title="9.4  大括号"></a>9.4  大括号</h3><p>大括号的总结来说有两种使用情况，分别是{ 跟在语句后面空一格或者 { 独占一行，} 独占一行。<br>{ 必须独占一行情况，主要是定义的情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bar</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 枚举定义</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Baz</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo::foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>{ 即可独占一行，或者空一格形式，主要是代码逻辑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if语句</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for循环语句</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// while和do-while循环语句</span></span><br><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch-case</span></span><br><span class="line"><span class="keyword">switch</span> (value) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-5-函数调用"><a href="#9-5-函数调用" class="headerlink" title="9.5  函数调用"></a>9.5  函数调用</h3><p>函数调用要么在一行写完调用，要么在圆括号里对参数分行，要么参数另起一行且缩进四格。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常情况</span></span><br><span class="line"><span class="type">bool</span> retval = <span class="built_in">doSomething</span>(argument1, argument2, argument3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同一行放不下,换新行且和第一个实参对齐,左圆括号后和右圆括号前不留空格</span></span><br><span class="line"><span class="type">bool</span> retval = <span class="built_in">doSomething</span>(averyveryveryverylongargument1,</span><br><span class="line">                          argument2, argument3);</span><br><span class="line"><span class="comment">// 模拟层次多的情况</span></span><br><span class="line"><span class="keyword">if</span> (...) &#123;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        <span class="built_in">doSomething</span>(</span><br><span class="line">            argument1, argument2,  <span class="comment">// 4 空格缩进</span></span><br><span class="line">            argument3, argument4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一些参数本身就是略复杂的表达式，那么可以直接创建临时变量描述该表达式，并传递给函数。也可以将某个参数独立成行，添加注释，增加可读性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int my_heuristic = scores[x] * y + bases[x];</span><br><span class="line">bool retval = doSomething(my_heuristic, x, y, z);</span><br><span class="line"></span><br><span class="line">bool retval = doSomething(scores[x] * y + bases[x],  // Score heuristic.</span><br><span class="line">                          x, y, z);</span><br></pre></td></tr></table></figure>

<p>如果一系列的参数本身就有一定的结构，可以酌情地按其结构来决定参数格式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 3x3 矩阵转换 widget.</span></span><br><span class="line">my_widget.<span class="built_in">Transform</span>(x1, x2, x3,</span><br><span class="line">                    y1, y2, y3,</span><br><span class="line">                    z1, z2, z3);</span><br></pre></td></tr></table></figure>

<h3 id="9-6-函数声明与定义"><a href="#9-6-函数声明与定义" class="headerlink" title="9.6  函数声明与定义"></a>9.6  函数声明与定义</h3><p><strong>返回类型和函数名放在同一行，参数在放不下时，对形参分行，{ }分别单独占一行。例如：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值、函数名、形参在同一行</span></span><br><span class="line"><span class="function">ReturnType <span class="title">ClassName::FunctionName</span><span class="params">(Type par_name1, Type par_name2)</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// &#123; 独占一行</span></span><br><span class="line">    <span class="built_in">doSomething</span>();</span><br><span class="line">&#125; <span class="comment">// &#125; 独占一行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 形参换行</span></span><br><span class="line"><span class="function">ReturnType <span class="title">ClassName::ReallyLongFunctionName</span><span class="params">(Type par_name1, Type par_name2,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             Type par_name3)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数都放不下,换新行4空格缩进</span></span><br><span class="line"><span class="function">ReturnType <span class="title">LongClassName::ReallyReallyReallyLongFunctionName</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Type par_name1,  <span class="comment">// 4空格缩进</span></span></span></span><br><span class="line"><span class="params"><span class="function">    Type par_name2,</span></span></span><br><span class="line"><span class="params"><span class="function">    Type par_name3)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未被使用参数，或者根据上下文很容易看出用途参数，可以省略参数名。<strong>但是尽量不要省略参数名。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承于Qt的事件的函数,事件参数未被使用,可以省略参数名</span></span><br><span class="line"><span class="comment">// 这种情况大多是因为继承,重写事件而省略参数操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showEvent</span><span class="params">(QShowEvent *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hideEvent</span><span class="params">(QHideEvent *)</span></span>;</span><br><span class="line"><span class="comment">// 需要移除拷贝构造函数或者是赋值操作函数,可以省略参数名</span></span><br><span class="line"><span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">Foo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Foo &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口中形参恒有命名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Rotate</span><span class="params">(<span class="type">double</span> radians)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Rotate</span><span class="params">(<span class="type">double</span> radians)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Circle::Rotate</span><span class="params">(<span class="type">double</span>)</span> </span>&#123;&#125; <span class="comment">// 不推荐 —— 省略会不清楚变量的作用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Circle::Rotate</span><span class="params">(<span class="type">double</span> <span class="comment">/*radians*/</span>)</span> </span>&#123;&#125; <span class="comment">// 推荐 —— 说明变量作用并消除警告</span></span><br></pre></td></tr></table></figure>

<h3 id="9-7-条件语句"><a href="#9-7-条件语句" class="headerlink" title="9.7  条件语句"></a>9.7  条件语句</h3><p>对基本条件语句不在圆括号内使用空格，if后面空一格，{ 前空一格或换行，} 独立一行，即不跟else或者else if。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123; </span><br><span class="line">    ... <span class="comment">// 缩进四格</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;  <span class="comment">// else或else if另起一行</span></span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果能增强可读性，简短的条件语句允许写在同一行。只有当语句简单并且没有使用else子句时使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == kFoo) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line"><span class="keyword">if</span> (x == kBar) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Bar</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不允许 - 当有 ELSE 分支时 IF 块却写在同一行</span></span><br><span class="line"><span class="keyword">if</span> (x) <span class="built_in">DoThis</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">DoThat</span>();</span><br></pre></td></tr></table></figure>

<p>如果语句中某个if-else语句使用大括号的话，其他分支也必须要使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可以这样子 - IF 有大括号 ELSE 却没有</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    foo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">bar;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以这样子 - ELSE 有大括号 IF 却没有</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    foo;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要其中一个分支用了大括号, 两个分支都要用上大括号</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    foo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-8-布尔表达式"><a href="#9-8-布尔表达式" class="headerlink" title="9.8  布尔表达式"></a>9.8  布尔表达式</h3><p>如果一个布尔表达式过长，断行方式要<strong>统一为逻辑操作符放在新行的开头。</strong>但逻辑复杂时考虑增加圆括号，增加可读性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (this_one_thing &gt; this_other_thing </span><br><span class="line">    &amp;&amp; (a_third_thing == a_fourth_thing) <span class="comment">// 加入圆括号增加可读性 </span></span><br><span class="line">    &amp;&amp; yet_another &amp;&amp; last_one)          <span class="comment">// 操作符放在开头对齐第一个参数</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-9-switch-case语句"><a href="#9-9-switch-case语句" class="headerlink" title="9.9  switch-case语句"></a>9.9  switch-case语句</h3><p>循环和switch-case语句的 { 可以与关键词在同一行,也可以另起单独一行与 } 对齐。后续代码不作展示说明。<br><strong>switch语句中的case块必须要大括号进行分段，以表明case之间不是连在一起的。switch应该总是包含一个default匹配。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (var) &#123; <span class="comment">// 可以在同一行,也可以另起单独一行与&#125;对齐</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: &#123;  <span class="comment">// 空格缩进四格</span></span><br><span class="line">        ...    <span class="comment">// 空格缩进八格</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: &#123;  <span class="comment">// 可以在同一行,也可以另起单独一行与&#125;对齐</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="literal">false</span>); <span class="comment">// 如果不可能到default可以尝试添加assert语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-10-指针和引用表达式"><a href="#9-10-指针和引用表达式" class="headerlink" title="9.10  指针和引用表达式"></a>9.10  指针和引用表达式</h3><p>**句点或箭头前后不要有空格；指针&#x2F;地址操作符(*，&amp;)之后不能有空格。**例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = *p;</span><br><span class="line">p = &amp;x;</span><br><span class="line">x = r.y;</span><br><span class="line">x = r-&gt;y;</span><br></pre></td></tr></table></figure>

<p>在声明指针变量或参数时，星号与类型或变量名紧挨都可以：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐——空格前置</span></span><br><span class="line"><span class="type">char</span> *c;</span><br><span class="line"><span class="type">const</span> string &amp;str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐——空格后置</span></span><br><span class="line"><span class="type">char</span>* c;</span><br><span class="line"><span class="type">const</span> string&amp; str;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x, *y;  <span class="comment">// 不推荐——在多重声明中不能使用 &amp; 或 *</span></span><br><span class="line"><span class="type">char</span> * c;  <span class="comment">// 不推荐—— * 两边都有空格</span></span><br><span class="line"><span class="type">const</span> string &amp; str;  <span class="comment">// 不推荐—— &amp; 两边都有空格</span></span><br></pre></td></tr></table></figure>

<h3 id="9-11-预处理指令"><a href="#9-11-预处理指令" class="headerlink" title="9.11  预处理指令"></a><strong>9.11  预处理指令</strong></h3><p>预处理指令不要缩进, 从行首开始。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐 - 指令从行首开始</span></span><br><span class="line"><span class="keyword">if</span> (lopsided_score) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DISASTER_PENDING      <span class="comment">// 正确 - 从行首开始</span></span></span><br><span class="line">    <span class="built_in">DropEverything</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">BackToNormal</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐 - 指令缩进</span></span><br><span class="line"><span class="keyword">if</span> (lopsided_score) &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> DISASTER_PENDING  <span class="comment">// 差 - &quot;#if&quot; 应该放在行开头</span></span></span><br><span class="line">    <span class="built_in">DropEverything</span>();</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span>                <span class="comment">// 差 - &quot;#endif&quot; 不要缩进</span></span></span><br><span class="line">    <span class="built_in">BackToNormal</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-12-构造函数初始值列表"><a href="#9-12-构造函数初始值列表" class="headerlink" title="9.12  构造函数初始值列表"></a>9.12  <strong>构造函数初始值列表</strong></h3><p>构造函数初始化列表放在<strong>同一行或按四格缩进并排多行。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果所有变量能放在同一行:</span></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">const</span> <span class="type">int</span> var) : <span class="built_in">m_someVar</span>(var) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不能放在同一行,</span></span><br><span class="line"><span class="comment">// 必须置于冒号后, 并缩进 4 个空格</span></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">const</span> <span class="type">int</span> var)</span><br><span class="line">    : <span class="built_in">m_someVar</span>(var), <span class="built_in">m_someOtherVar</span>(var + <span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果初始化列表需要置于多行, 将每一个成员放在单独的一行</span></span><br><span class="line"><span class="comment">// 并逐行对齐</span></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">const</span> <span class="type">int</span> var)</span><br><span class="line">    : <span class="built_in">m_someVar</span>(var),             <span class="comment">// 缩进 4 个空格</span></span><br><span class="line">      <span class="built_in">m_someOtherVar</span>(var + <span class="number">1</span>) </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-13-类格式"><a href="#9-13-类格式" class="headerlink" title="9.13  类格式"></a>9.13  类格式</h3><p><strong>访问控制块关键词的声明不需要缩进。</strong><br>类声明得基本格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> OtherClass </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:      <span class="comment">// 注意没有缩进</span></span><br><span class="line">    <span class="built_in">MyClass</span>();  <span class="comment">// 标准的空格缩进四格</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">const</span> <span class="type">int</span> var)</span></span>;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someFunctionThatDoesNothing</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSomeVar</span><span class="params">(<span class="type">const</span> <span class="type">int</span> var)</span> </span>&#123; m_someVar = var; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">someVar</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_someVar; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">someInternalFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_someVar;</span><br><span class="line">    <span class="type">int</span> m_someOtherVar;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ol>
<li>所有基类名应在 80 列限制下尽量与子类名放在同一行；</li>
<li>访问控制块关键词没有缩进，关键词后不要保留空行；</li>
<li>除第一个关键词 外，其他关键词前要空一行；</li>
<li>关于声明顺序的规则请参考 4.8 声明顺序 一节</li>
</ol>
<h2 id="10-完结撒花"><a href="#10-完结撒花" class="headerlink" title="10  完结撒花"></a>10  完结撒花</h2><p> <strong>正确性 &gt; 稳定性 &gt; 可测试性 &gt; 可读性 &gt; 全局效率 &gt; 局部效率 &gt; 个人习惯。</strong></p>
<ol>
<li>正确性，指程序要实现设计 要求的功能；</li>
<li>稳定性、安全性，指程序稳定、可靠、安全；</li>
<li>可测试性，指程序要具有良好的可测试性；</li>
<li>规范&#x2F;可读性，指程序书写风格、命名规则等要符合规范；</li>
<li>全局效率，指软件系统的整体效率；</li>
<li>局部效率，指某个模块&#x2F;子模块&#x2F;函数的本身效率；</li>
<li>个人表达方式&#x2F;个人方便性，指个人编程习惯。</li>
</ol>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">OQS</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://cpp-memory-leaks.github.io/2024/08/07/Cpp%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://cpp-memory-leaks.github.io/2024/08/07/Cpp%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/')">C++代码规范</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://cpp-memory-leaks.github.io/2024/08/07/Cpp%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=C++代码规范&amp;url=https://cpp-memory-leaks.github.io/2024/08/07/Cpp%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/&amp;pic=/img/cpp_default_cover.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="/img/cpp_default_cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/11/07/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%91%87%E6%9D%86/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/cpp-memory-leaks/cpp-memory-leaks.github.io/refs/heads/master/img/qt_default_cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">自定义摇杆</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(null) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">1.  概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text">2.  头文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="toc-number">2.1.</span> <span class="toc-text">2.1   头文件保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%89%8D%E7%BD%AE%E5%A3%B0%E6%98%8E"><span class="toc-number">2.2.</span> <span class="toc-text">2.2  前置声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">2.3  内联函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-incude%E7%9A%84%E8%B7%AF%E5%BE%84%E5%8F%8A%E6%AC%A1%E5%BA%8F"><span class="toc-number">2.4.</span> <span class="toc-text">2.4  #incude的路径及次序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">3.</span> <span class="toc-text">3. 作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">3.1.</span> <span class="toc-text">3.1  命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E3%80%81%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">3.2  非成员函数、静态成员函数和全局函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">3.3.</span> <span class="toc-text">3.3  局部变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">4. 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%81%8C%E8%B4%A3"><span class="toc-number">4.1.</span> <span class="toc-text">4.1  构造函数的职责</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.2.</span> <span class="toc-text">4.2  初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%98%BE%E5%BC%8F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">4.3  显式构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E7%BB%93%E6%9E%84%E4%BD%93-VS%E7%B1%BB"><span class="toc-number">4.4.</span> <span class="toc-text">4.4  结构体 VS类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.5.</span> <span class="toc-text">4.5  接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E7%BB%A7%E6%89%BF"><span class="toc-number">4.6.</span> <span class="toc-text">4.6  继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">4.7.</span> <span class="toc-text">4.7  多重继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-%E5%A3%B0%E6%98%8E%E9%A1%BA%E5%BA%8F"><span class="toc-number">4.8.</span> <span class="toc-text">4.8  声明顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6"><span class="toc-number">4.9.</span> <span class="toc-text">4.9  存取控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">5. 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%8F%82%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">5.1  参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%BC%96%E5%86%99%E7%AE%80%E7%9F%AD%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">5.2  编写简短函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%85%B6%E4%BB%96C-%E7%89%B9%E6%80%A7"><span class="toc-number">6.</span> <span class="toc-text">6.  其他C++特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%BC%82%E5%B8%B8"><span class="toc-number">6.1.</span> <span class="toc-text">6.1  异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%89%8D%E7%BD%AE%E8%87%AA%E5%A2%9E%E5%92%8C%E8%87%AA%E5%87%8F"><span class="toc-number">6.3.</span> <span class="toc-text">6.3  前置自增和自减</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-const%E7%94%A8%E6%B3%95"><span class="toc-number">6.4.</span> <span class="toc-text">6.4  const用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E9%A2%84%E5%A4%84%E7%90%86%E5%AE%8F"><span class="toc-number">6.5.</span> <span class="toc-text">6.5   预处理宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-sieof"><span class="toc-number">6.6.</span> <span class="toc-text">6.6  sieof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-auto"><span class="toc-number">6.7.</span> <span class="toc-text">6.7  auto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">6.8.</span> <span class="toc-text">6.8  lambda表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A"><span class="toc-number">7.</span> <span class="toc-text">7.  命名约定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E9%80%9A%E7%94%A8%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A"><span class="toc-number">7.1.</span> <span class="toc-text">7.1  通用命名约定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D"><span class="toc-number">7.2.</span> <span class="toc-text">7.2  文件命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E7%B1%BB%E5%9E%8B%E5%91%BD%E5%90%8D"><span class="toc-number">7.3.</span> <span class="toc-text">7.3  类型命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D"><span class="toc-number">7.4.</span> <span class="toc-text">7.4  变量命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E5%B8%B8%E9%87%8F%E5%91%BD%E5%90%8D"><span class="toc-number">7.5.</span> <span class="toc-text">7.5  常量命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-%E5%87%BD%E6%95%B0%E5%91%BD%E5%90%8D"><span class="toc-number">7.6.</span> <span class="toc-text">7.6  函数命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%91%BD%E5%90%8D"><span class="toc-number">7.7.</span> <span class="toc-text">7.7   命名空间命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-%E6%9E%9A%E4%B8%BE%E5%91%BD%E5%90%8D"><span class="toc-number">7.8.</span> <span class="toc-text">7.8  枚举命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-9-%E7%BB%93%E6%9E%84%E4%BD%93%E5%91%BD%E5%90%8D"><span class="toc-number">7.9.</span> <span class="toc-text">7.9   结构体命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-10-%E8%8E%B7%E5%8F%96%E5%99%A8%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%99%A8%E5%91%BD%E5%90%8D"><span class="toc-number">7.10.</span> <span class="toc-text">7.10   获取器和设置器命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-11-%E7%95%8C%E9%9D%A2%E6%8E%A7%E4%BB%B6%E5%91%BD%E5%90%8D"><span class="toc-number">7.11.</span> <span class="toc-text">7.11  界面控件命名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%B3%A8%E9%87%8A"><span class="toc-number">8.</span> <span class="toc-text">8. 注释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E6%B3%A8%E9%87%8A%E9%A3%8E%E6%A0%BC"><span class="toc-number">8.1.</span> <span class="toc-text">8.1  注释风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E5%A4%B4%E6%96%87%E4%BB%B6%E6%B3%A8%E9%87%8A"><span class="toc-number">8.2.</span> <span class="toc-text">8.2  头文件注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E7%B1%BB%E6%B3%A8%E9%87%8A"><span class="toc-number">8.3.</span> <span class="toc-text">8.3  类注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E5%87%BD%E6%95%B0%E6%B3%A8%E9%87%8A"><span class="toc-number">8.4.</span> <span class="toc-text">8.4  函数注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E5%8F%98%E9%87%8F%E6%B3%A8%E9%87%8A"><span class="toc-number">8.5.</span> <span class="toc-text">8.5  变量注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-%E5%AE%9E%E7%8E%B0%E6%B3%A8%E9%87%8A"><span class="toc-number">8.6.</span> <span class="toc-text">8.6  实现注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-%E6%9E%9A%E4%B8%BE%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E6%B3%A8%E9%87%8A"><span class="toc-number">8.7.</span> <span class="toc-text">8.7  枚举和结构体注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-TODO%E6%B3%A8%E9%87%8A"><span class="toc-number">8.8.</span> <span class="toc-text">8.8   TODO注释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%A0%BC%E5%BC%8F"><span class="toc-number">9.</span> <span class="toc-text">9. 格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E8%A1%8C%E9%95%BF%E5%BA%A6"><span class="toc-number">9.1.</span> <span class="toc-text">9.1  行长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81"><span class="toc-number">9.2.</span> <span class="toc-text">9.2  文件编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E7%BC%A9%E8%BF%9B"><span class="toc-number">9.3.</span> <span class="toc-text">9.3  缩进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-%E5%A4%A7%E6%8B%AC%E5%8F%B7"><span class="toc-number">9.4.</span> <span class="toc-text">9.4  大括号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">9.5.</span> <span class="toc-text">9.5  函数调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89"><span class="toc-number">9.6.</span> <span class="toc-text">9.6  函数声明与定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-7-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">9.7.</span> <span class="toc-text">9.7  条件语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-8-%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">9.8.</span> <span class="toc-text">9.8  布尔表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-9-switch-case%E8%AF%AD%E5%8F%A5"><span class="toc-number">9.9.</span> <span class="toc-text">9.9  switch-case语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-10-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">9.10.</span> <span class="toc-text">9.10  指针和引用表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-11-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-number">9.11.</span> <span class="toc-text">9.11  预处理指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-12-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%80%BC%E5%88%97%E8%A1%A8"><span class="toc-number">9.12.</span> <span class="toc-text">9.12  构造函数初始值列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-13-%E7%B1%BB%E6%A0%BC%E5%BC%8F"><span class="toc-number">9.13.</span> <span class="toc-text">9.13  类格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%AE%8C%E7%BB%93%E6%92%92%E8%8A%B1"><span class="toc-number">10.</span> <span class="toc-text">10  完结撒花</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/21/CppRestSDK%E7%BC%96%E8%AF%91ASIO%E7%89%88%E6%9C%AC%E8%BF%87%E7%A8%8B/" title="CppRestSDK编译ASIO版本过程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/cpp_default_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CppRestSDK编译ASIO版本过程"/></a><div class="content"><a class="title" href="/2025/08/21/CppRestSDK%E7%BC%96%E8%AF%91ASIO%E7%89%88%E6%9C%AC%E8%BF%87%E7%A8%8B/" title="CppRestSDK编译ASIO版本过程">CppRestSDK编译ASIO版本过程</a><time datetime="2025-08-21T13:25:28.000Z" title="Created 2025-08-21 21:25:28">2025-08-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/17/%E4%BD%BF%E7%94%A8libheif%E5%BA%93%E8%AF%BB%E5%8F%96heic%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%A9%E7%95%A5%E5%9B%BE/" title="使用libheif库读取heic文件的缩略图"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/cpp_default_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用libheif库读取heic文件的缩略图"/></a><div class="content"><a class="title" href="/2025/03/17/%E4%BD%BF%E7%94%A8libheif%E5%BA%93%E8%AF%BB%E5%8F%96heic%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%A9%E7%95%A5%E5%9B%BE/" title="使用libheif库读取heic文件的缩略图">使用libheif库读取heic文件的缩略图</a><time datetime="2025-03-17T12:18:50.000Z" title="Created 2025-03-17 20:18:50">2025-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/22/Qt%E4%B8%AD%E5%90%84%E7%A7%8D%E5%9B%BE%E5%83%8F%E7%9A%84%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%BB%A5%E5%8F%8A%E4%B8%8Ecv-Mat%E5%9B%BE%E5%83%8F%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%BD%AC%E6%8D%A2/" title="Qt中各种图像的格式转换以及与cv::Mat图像格式之间的转换"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/cpp-memory-leaks/cpp-memory-leaks.github.io/refs/heads/master/img/qt_default_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Qt中各种图像的格式转换以及与cv::Mat图像格式之间的转换"/></a><div class="content"><a class="title" href="/2025/01/22/Qt%E4%B8%AD%E5%90%84%E7%A7%8D%E5%9B%BE%E5%83%8F%E7%9A%84%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%BB%A5%E5%8F%8A%E4%B8%8Ecv-Mat%E5%9B%BE%E5%83%8F%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%BD%AC%E6%8D%A2/" title="Qt中各种图像的格式转换以及与cv::Mat图像格式之间的转换">Qt中各种图像的格式转换以及与cv::Mat图像格式之间的转换</a><time datetime="2025-01-21T16:33:34.000Z" title="Created 2025-01-22 00:33:34">2025-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/25/Qt%E4%BD%BF%E7%94%A8libheif%E5%BA%93%E6%98%BE%E7%A4%BA%E8%8B%B9%E6%9E%9C%E7%9A%84heic%E5%9B%BE%E7%89%87/" title="Qt使用libheif库显示苹果的heic图片"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/cpp-memory-leaks/cpp-memory-leaks.github.io/refs/heads/master/img/qt_default_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Qt使用libheif库显示苹果的heic图片"/></a><div class="content"><a class="title" href="/2024/12/25/Qt%E4%BD%BF%E7%94%A8libheif%E5%BA%93%E6%98%BE%E7%A4%BA%E8%8B%B9%E6%9E%9C%E7%9A%84heic%E5%9B%BE%E7%89%87/" title="Qt使用libheif库显示苹果的heic图片">Qt使用libheif库显示苹果的heic图片</a><time datetime="2024-12-25T12:17:31.000Z" title="Created 2024-12-25 20:17:31">2024-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/25/QCheckBox%E7%9A%84%E4%B8%89%E6%80%81%E5%A4%8D%E9%80%89%E6%A1%86%E5%92%8C%E5%8F%8D%E9%80%89/" title="QCheckBox的三态复选框和反选"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/cpp-memory-leaks/cpp-memory-leaks.github.io/refs/heads/master/img/qt_default_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="QCheckBox的三态复选框和反选"/></a><div class="content"><a class="title" href="/2024/12/25/QCheckBox%E7%9A%84%E4%B8%89%E6%80%81%E5%A4%8D%E9%80%89%E6%A1%86%E5%92%8C%E5%8F%8D%E9%80%89/" title="QCheckBox的三态复选框和反选">QCheckBox的三态复选框和反选</a><time datetime="2024-12-25T11:10:56.000Z" title="Created 2024-12-25 19:10:56">2024-12-25</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="OQS" target="_blank">OQS</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = []
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/cpp-memory-leaks" title="博客">博客</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/" title="tag"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/" title="category"><div class="headline">Categories</div><div class="length-num">3</div></a></div><span class="sidebar-menu-item-title">Function</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="Display Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>Display Mode</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://cpp-memory-leaks.github.io" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/cpp-memory-leaks" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.cbd.int/@docsearch/css@3.5.2/dist/style.css"/><script src="https://cdn.cbd.int/@docsearch/js@3.5.2/dist/umd/index.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: '',
    apiKey: '',
    indexName: '',
    container: '#docsearch',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    anzhiyu.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 OQS 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>