<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>QT详解 | Stack Overflow</title><meta name="keywords" content="Qt"><meta name="author" content="OQS"><meta name="copyright" content="OQS"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="QT详解"><meta name="application-name" content="QT详解"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="QT详解"><meta property="og:url" content="https://cpp-memory-leaks.github.io/2024/09/13/QT%E8%AF%A6%E8%A7%A3/index.html"><meta property="og:site_name" content="Stack Overflow"><meta property="og:description" content="QT详解 Qt 可以做什么？  Qt 虽然经常被当做一个 GUI 库，用来开发图形界面应用程序，但这并不是 Qt 的全部；Qt 除了可以绘制漂亮的界面（包括控件、布局、交互），还包含很多其它功能，比如多线程、访问数据库、图像处理、音频视频处理、网络通信、文件操作等，这些 Qt 都已经内置了。"><meta property="og:locale" content="en"><meta property="og:image" content="https://raw.githubusercontent.com/cpp-memory-leaks/cpp-memory-leaks.github.io/refs/heads/master/img/qt_default_cover.png"><meta property="article:author" content="OQS"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://raw.githubusercontent.com/cpp-memory-leaks/cpp-memory-leaks.github.io/refs/heads/master/img/qt_default_cover.png"><meta name="description" content="QT详解 Qt 可以做什么？  Qt 虽然经常被当做一个 GUI 库，用来开发图形界面应用程序，但这并不是 Qt 的全部；Qt 除了可以绘制漂亮的界面（包括控件、布局、交互），还包含很多其它功能，比如多线程、访问数据库、图像处理、音频视频处理、网络通信、文件操作等，这些 Qt 都已经内置了。"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://cpp-memory-leaks.github.io/2024/09/13/QT%E8%AF%A6%E8%A7%A3/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":null},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"Author: OQS","link":"Link: ","source":"Source: Stack Overflow","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.","copySuccess":"Copy success, copy and reprint please mark the address of this article"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Stack Overflow',
  title: 'QT详解',
  postAI: '',
  pageFillDescription: 'QT详解, GNU 工具集 在 GNU 工具集里面开发时常见到的几个罗列如下（这些工具通常位于 Linux 或 Unix 系统里的 x2Fusrx2Fbinx2F 目录）：, MinGW, MSYS（Minimal SYStem）, CMake, Qt 工具集, Project, Makefile, Debug 和 Release, C++11 标准, Dynamic Link 和 Static Link, 动态链接库, 静态链接库, 库文件后缀, Explicit Linking 和 Implicit Linking, Qt Creator 的设置, 新建一个项目, 项目的文件组成和管理, 项目的编译、调试与运行, widget.h 文件, namespace 声明, Widget 类的定义, widget.cpp 文件, widget.ui 文件, ui_widget.h 文件, 实例程序功能, 界面组件布局, 界面组件的层次关系, 布局管理, 伙伴关系与 Tab 顺序, 项目功能实现, 字体样式设置, 字体颜色设置, 三个按钮的功能设计, 实例功能, 界面创建, QWDlgManual 类定义, 界面组件的创建与布局, 信号与槽的关联, Qt 的元对象系统, 属性系统, 属性定义, 属性的使用, 动态属性, 类的附加信息, 全局变量定义, 全局函数定义, 全局宏定义, 顺序容器类, QList, QLinkedList, QVector, QStack, QQueue, 关联容器类, QSet, QMap, QMultiMap, QHash, QMultiHash, Java 类型迭代器, 顺序容器类的迭代器的使用, 关联容器类的迭代器的使用, STL类型迭代器, 顺序容器类的迭代器的用法, 关联容器类的迭代器的用法详解可以做什么虽然经常被当做一个库用来开发图形界面应用程序但这并不是的全部除了可以绘制漂亮的界面包括控件布局交互还包含很多其它功能比如多线程访问数据库图像处理音频视频处理网络通信文件操作等这些都已经内置了总起来说主要用于桌面程序开发和嵌入式开发来开发桌面程序有以下优点简单易学封装的很好几行代码就可以开发出一个简单的客户端不需要了解资料丰富资料丰富能够成倍降低学习成本否则你只能去看源码关于的资料就很少漂亮的界面很容易做出漂亮的界面和炫酷的动画而比较麻烦独立安装程序最终会编译为本地代码不需要其他库的支撑而要安装虚拟机要安装跨平台如果你的程序需要运行在多个平台下同时又希望降低开发成本几乎是必备的学习的基础依旧是的主要编程语言也并没有忽略它添加了很多新的而且会持续更新引入只是提供的另外一种选择并不是让它成为唯一的选择是的基础无论如何都要掌握总的来说对于是不可或缺的而只是一个加分项认识一下用到的开发工具不是凭空产生的它是基于现有工具链打造而成的它所使用的编译器链接器调试器等都不是自己的官方只是开发了上层工具下面我们分几个部分讲解使用到的工具链工具集在工具集里面开发时常见到的几个罗列如下这些工具通常位于或系统里的目录工具说明语言编译器语言编译器链接器将目标文件和库文件链接起来创建可执行程序和动态链接库生成静态库可以编辑和管理静态链接库生成器可以根据文件自动编译链接生成可执行程序或库文件调试器用于调试可执行程序查看可执行文件依赖的共享库扩展名也叫动态链接库原本工具只在系统里才有随着系统的广泛使用为了在系统里可以使用工具诞生了项目利用就可以生成里面的程序和链接库需要注意的是与系统里工具集的有些区别里面工具带有扩展名系统里工具通常都是没有扩展名的里面的生成器文件名为系统里就叫在链接时是链接到库引用文件生成的可执行程序运行时依赖而系统里链接时和运行时都是使用另外里也没有工具因为不使用共享库文件如果要查看里可执行文件的依赖库需要使用微软自家的工具里面动态库扩展名为可以通过来生成用于创建和使用动态链接库需要的文件如和原本是用于生成位程序的随着位系统流行起来从分离出来了项目该项目同时支持生成位和位程序的版本库就是使用项目里面的工具集生成的另外提一下由于本身主要就是编译链接等工具和头文件库文件并不包含系统管理文件操作之类的环境这对希望用类命令的开发者来说还是不够用的所以官方又推出了相当于是一个部署在系统里面的小型系统环境移植了很多命令行工具和配置文件等等是对的扩展对于熟悉系统环境或者要尝试学习系统的人都是一种便利和的安装升级都是通过其官方的工具实现二者是统一下载安装管理的对于项目它对应的小型系统环境叫是的衍生版不仅支持位系统和位系统还有自己的独特的软件包管理工具它从系统里移植了软件管理工具所以装了之后可以直接通过来下载安装软件而且可以自动解决依赖关系方便系统升级等装了之后不需要自己去下载可以直接用命令安装编译链接工具和工具等项目主页含项目主页项目主页是一个开源的跨平台自动化构建工具可以跨平台地生成各式各样的或者文件支持利用各种编译工具生成可执行程序或链接库自己不编译程序它相当于用自己的构建脚本叫各种编译工具集去生成可执行程序或链接库一般用于编译程序的文件比较复杂自己去编写比较麻烦而利用就可以编写相对简单的由根据自动生成然后就可以用生成可执行程序或链接库本教程里面是使用官方的工具生成文件没有用这里之所以提是因为整个桌面环境的茫茫多程序都是用脚本构建的另外跨平台的程序库如等也都是用脚本构建的以后如果接触到这些东西是需要了解的项目主页项目主页工具集官方的开发环境安装包里有自己专门的开发工具之前用过命令是开发最核心的工具既可以生成项目文件也可以自动生成项目的文件这里将常用的开发工具列表如下工具说明核心的项目构建工具可以生成跨平台的项目文件并能依据不同操作系统和编译工具生成相应的用于构建可执行程序或链接库用户界面编译器使用语法格式的文件定义用户界面根据文件生成用于创建用户界面的代码头文件比如元对象编译器处理头文件的类定义里面的宏它会生成源代码文件比如其中包含相应类的元对象代码元对象代码主要用于实现信号槽机制运行时类型定义动态属性系统资源文件编译器负责在项目构建过程中编译资源文件将资源嵌入到最终的程序里集成开发环境包含项目生成管理代码编辑图形界面可视化编辑编译生成程序调试上下文帮助版本控制系统集成等众多功能还支持手机和嵌入式设备的程序生成部署助手帮助文档浏览查询工具库所有模块和开发工具的帮助文档示例代码等都可以检索到是开发必备神器也可用于自学设计师专门用于可视化编辑图形用户界面所见即所得生成文件用于项目语言家代码里用宏包裹的就是可翻译的字符串开发人员可用命令生成项目的待翻译字符串文件用翻译多国语言翻译完成后用命令生成文件然后就可用于多国语言界面显示在里是用进行程序的原型设计和测试用取代了旧的新的另外还支持中的新特性编程涉及的术语和名词用到的开发工具的初步使用本节我们来介绍一下使用编程过程中常用的术语和名字它们不一定专属于在其它的开发过程中也会使用到的中文翻译是项目或者工程这里的项目是指为实现某个相对独立功能的程序代码合集这些代码不单单是放在一块而是有相互之间的关联性并且有专门负责管理该项目的项目文件比如使用文件管理项目则使用作为项目文件集成开发环境通常都是依据项目文件管理和构建项目即生成脚本虽然可以直接调用编译器如编译程序但是如果项目里的代码文件变多了哪些代码文件更新了需要重新编译哪些代码没有改不需要重新编译等等靠程序员自己记忆去处理是比较麻烦的事还有哪些代码需要预处理或是链接哪些库文件这些都是繁杂的过程为了规范程序的编译生成过程产生了规范化的生成脚本就是生成器可以依据规范的自动生成目标程序或库文件简单的说就是定义好让程序员只需要去关注如何编写代码而生成程序过程中的脏活累活都交给程序现在通常都有工具自动生成如工具这样就大量减轻了程序员的负担和即调试即发行代码编写之后生成的目标程序或库文件通常不会绝对正确或多或少有些毛病因此需要进行纠错调试调试过程中需要源代码和二进制目标程序之间一一对应的关系这样才能定位到错误代码所以版本的程序是臃肿而不进行优化的与之相对的是发行版在纠正了发觉到的错误后需要发布程序用于实际用途实际应用时强调运行效率高减少冗余代码因此会对二进制程序进行大量优化提升性能这样发布的二进制目标程序就是版版本和版本使用的库文件不一样版本程序通常链接的也是版本的库文件比如库文件的简短名不含扩展名都是以结尾的库通常都比较大版本程序链接的通常就是版本的库文件版本库文件名字比版本库文件少一个字母如而且版本库一般都比版本小很多运行效率也高很多标准时代在变化标准也在前进正式公布标准有最新的标准是年月日公布的在公布之前该标准原名为这是一次较大的修订和扩充建议读者专门学一下从版本就开始用新特性了编译器里面开始支持的版本是这之后版本的编译器都在逐步完善对的支持现在新版本编译器对新标准的支持都比较全面了官方在编译库的时候都是开启特性的如果我们要在自己项目代码启用新标准需要在文件里面添加一行如果是版本则是添加编译器默认开启特性命令则需要自己添加选项上面就是为编译器命令添加选项和即动态链接即静态链接动态链接库目标程序通常都不是独立个体生成程序时都需要链接其他的库要用到其他库的代码对于多个程序同时运行而言内存中就可能有同一个库的多个副本占用了太多内存而干的活差不多为了优化内存运用效率引入了动态链接库或叫共享库使用动态链接库时内存中只需要一份该库文件其他程序要使用该库文件时只要链接过来就行了由于动态库文件外置链接到动态库的目标程序相对比较小因为剥离了大量库代码而只需要一些链接指针使用动态库也意味着程序需要链接到如或文件得提前装好动态库文件然后目标程序才能正常运行静态链接库静态库就是将链接库的代码和自己编写的代码都编译链接到一块链接到静态库的程序通常比较大但好处是运行时依赖的库文件很少因为目标程序自己内部集成了很多库代码库文件后缀系统里静态库扩展名一般是动态库扩展名一般是系统里编译器用的静态库扩展名一般是动态库扩展名一般是比较特殊是将工具集和链接库从系统移植到里有意思的情况就出现了使用的静态库扩展名为而其动态库扩展名则为仅在生成目标程序过程中使用则是在目标程序运行时使用和即显式链接即隐式链接这两种都是动态链接库的使用方式动态链接库通常都有其导出函数列表告知其他可执行程序可以使用它的哪些函数可执行程序使用这些导出函数有两种方式一是在运行时使用主动加载动态库的函数里比如用函数打开并加载动态库里一般用打开并加载动态库只有当程序代码执行到这些函数时其参数里的动态库才会被加载这就是显式链接显式链接方式是在运行时加载动态库其程序启动时并不检查这些动态库是否存在隐式链接是最为常见的所有的编译环境默认都是采用隐式链接的方式使用动态库隐式链接会在链接生成可执行程序时就确立依赖关系在该程序启动时操作系统自动会检查它依赖的动态库并一一加载到该程序的内存空间程序员就不需要操心什么时候加载动态库了比如编译环境链接时使用动态库对应的文件包含动态库的导出函数声明但没有实际功能代码在程序运行前系统会检查依赖的如果找不到某个动态库就会出现类似下图对话框是将动态库的导出函数声明放在了文件里程序运行依赖的动态库也是请注意链接器使用的文件分两类一种是完整的静态库体积比较大另一种是动态库的导出声明体积比较小链接器使用的文件也是类似的官方库都是按照动态库发布的静态库只有自己编译才会有的初步使用启动出现如图所示的主窗口图主窗口的界面很简洁上方是主菜单栏左侧是主工具栏窗口的中间部分是工作区根据设计内容不同工作区会显示不同的内容图是在左侧主工具栏单击欢迎按钮后显示实例的界面这时工作区的左侧有示例教程几个按钮单击后会在主工作区显示相应的内容单击按钮后工作区显示新建项目按钮和最近打开项目的列表单击示例按钮后工作区显示自带的大量实例选择某个实例就可以在中打开该项目源程序单击教程按钮后工作区显示各种视频教程查看视频教程需要联网并使用浏览器打开单击按钮工作区显示帮助主题内容主窗口左侧是主工具栏主工具栏提供了项目文件编辑窗体设计程序调试项目设置等各种功能按钮的设置对可以进行一些设置如刚安装好的界面语言可能是中文也可以选择将的界面语言设置为英文图的构建和运行设置页面单击菜单栏的菜单项会打开选项设置对话框如图所示对话框的左侧是可设置的内容分组单击后右侧出现具体的设置界面常用的设置包括以下几点环境设置在页面可以设置语言和主题本教程全部以中文界面的进行讲解所以语言选择为为了使界面抓图更清晰设置主题为更改语言和主题后需要重新启动才会生效文本编辑器设置在此界面可以设置文本编辑器的字体设置各种类型文字的字体颜色如关键字数字字符串注释等字体颜色也可以选择不同的配色主题编辑器缺省字体的大小为可以修改得大一些构建和运行设置图显示的是的设置界面它有以下几个页面构建套件页面显示可用的编译工具页面显示安装的版本编译器页面显示系统里可用的和编译器由于安装了和会自动检测出这些编译器页面显示自动检测到的调试器有调试器和的调试器编写第一个程序学习一种编程语言或编程环境通常会先编写一个程序我们也用编写一个程序以初步了解设计应用程序的基本过程对使用编写应用程序建立初步的了解新建一个项目单击的菜单项文件新建文件或项目出现如图所示的对话框在这个对话框里选择需要创建的项目或文件的模板图新建文件或项目对话框可以创建多种项目在最左侧的列表框中单击中间的列表框中列出了可以创建的应用程序的模板各类应用程序如下支持桌面平台的有图形用户界面界面的应用程序的设计完全基于语言采用提供的一套类库控制台应用程序无界面一般用于学习语言只需要简单的输入输出操作时可创建此类项目创建可部署的应用程序是支持的一套开发架构其界面设计采用语言程序架构采用语言利用可以设计非常炫的用户界面一般用于移动设备或嵌入式设备上无边框的应用程序的设计创建基于组件的可部署的应用程序组件只有及以后版本才有创建项目也是基于语言的界面设计支持画布在图显示的对话框中选择项目类型为后单击按钮出现如图所示的新建项目向导图新建项目向导第步项目名称和项目存储位置设置在图中选择一个目录如再设置项目名称为这样新建项目后会在目录下新建一个目录项目所有文件保存在目录下在图中设置好项目名称和保存路径后单击按钮出现如图所示的选择编译工具的界面图新建项目向导第步选择编译工具可以将这几个编译工具都选中在编译项目时再选择一个作为当前使用的编译工具这样可以编译生成不同版本的可执行程序图新建项目想到第步选择界面基类在图显示的界面中单击按钮出现如图所示的界面在此界面中选择需要创建界面的基类有种基类可以选择是主窗口类主窗口具有主菜单栏工具栏和状态栏类似于一般的应用程序的主窗口是所有具有可视界面类的基类选择创建的界面对各种界面组件都可以支持是对话框类可建立一个基于对话框的界面在此选择作为基类自动更改的各个文件名不用手动去修改勾选创建界面复选框这个选项如果勾选就会由创建用户界面文件否则需要自己编程手工创建界面初始学习为了了解的设计功能勾选此选项然后单击按钮出现一个页面总结了需要创建的文件和文件保存目录单击完成按钮就可以完成项目的创建项目的文件组成和管理完成了以上新建项目的步骤后在的左侧工具栏中单击编辑按钮可显示如图所示的窗口图项目管理与文件编辑界面窗口左侧有上下两个子窗口上方的目录树显示了项目内文件的组织结构显示当前项目为项目的名称构成目录树的一个根节点可以打开多个项目但是只有一个活动项目活动项目的项目名称节点用粗体字体表示在项目名称节点下面分组管理着项目内的各种源文件几个文件及分组分别为以下几项是项目管理文件包括一些对项目的设置项分组该节点下是项目内的所有头文件图中所示项目有一个头文件是主窗口类的头文件分组该节点下是项目内的所有源文件图中所示项目有两个源文件是主窗口类的实现文件与文件对应是主函数文件也是应用程序的入口分组该节点下是项目内的所有界面文件图中所示项目有一个界面文件是主窗口的界面文件界面文件是文本文件使用语言描述界面的组成左侧上下两个子窗口的显示内容可以通过其上方的一个下拉列表框进行选择可以选择的显示内容包括项目打开文档书签文件系统类视图大纲等在图中上方的子窗口显示了项目的文件目录树下方显示打开的文件列表可以在下方选择显示类视图这样下方则显示项目内所有的类的结构便于程序浏览和快速切换到需要的代码位置双击文件目录树中的文件出现如图所示的窗体设计界面图集成在中设计器这个界面实际上是中集成的窗口左侧是分组的组件面板中间是设计的窗体在组件面板的分组里将一个组件拖放到设计的窗体上面双击刚刚放置的组件可以编辑其文字内容将文字内容更改为还可以在窗口右下方的属性编辑器里编辑标签的属性点大小更改为勾选粗体项目的编译调试与运行单击主窗口左侧工具栏上的项目按钮出现如图所示的项目编译设置界面图项目编译器选择和设置界面界面左侧一栏的下面显示了本项目中可用的编译器工具要使用哪一个编译器用于项目编译单击其名称即可选择的编译器名称会用粗体字表示这里选择使用编译器每个编译器又有和两个设置界面在设置界面上有一个复选框如果勾选此项编译后将在项目的同级目录下建立一个编译后的文件目录目录名称包含编译器信息这种方式一般用于使用不同编译器创建不同版本的可执行文件如果不勾选此项编译后将在项目的目录下建立和子目录用于存放编译后的文件在设计完文件并设置好编译工具之后就可以对项目进行编译调试或运行主窗口左侧工具栏下方有个按钮其功能见表图标作用快捷键弹出菜单选择编译工具和编译模式如或模式直接运行程序如果修改后未编译会先进行编译即使在程序中设置了断点此方式运行的程序也无法调试项目需要以模式编译点此按钮开始调试运行可以在程序中设置断点若是以模式编译点此按钮也无法进行调试编译当前项目首先对项目进行编译没有错误后再运行程序程序运行的界面如图所示这就是一个标准的桌面应用程序我们采用可视化的方式设计了一个窗口并在上面显示了字符串图实例程序运行时界面在中也可以对程序设置断点进行调试但是必须以模式编译并以快捷键方式运行程序程序调试的方法与一般工具类似不再详述注意要在里调试编译的程序必须安装软件开发工具包项目管理文件及其作用详解在中新建一个项目在选择窗口基类的页面选择作为窗体基类并选中复选框创建后的项目文件目录树如图所示图项目文件的目录树这个项目包含以下一些文件项目管理文件存储项目设置的文件主程序入口文件实现函数的程序文件窗体界面文件一个格式存储的窗体上的元件及其布局的文件是所设计的窗体类的头文件是里定义类的实现文件中任何窗体或界面组件都是用类封装的一个类一般有一个头文件文件和一个源程序文件文件本节先来介绍一下项目管理文件文件后缀为的文件是项目的管理文件文件名就是项目的名称如本项目中的下面是文件的内容项目管理文件用于记录项目的一些设置以及项目包含文件的组织管理表示项目中加入模块是用于设计的类库模块如果创建的是控制台应用程序就不需要添加类库以模块的形式组织各种功能的类根据项目涉及的功能需求在项目中添加适当的类库模块支持例如如果项目中使用到了涉及数据库操作的类就需要用到模块在文件中需要增加如下一行中的第行是这是个条件执行语句表示当主版本大于时才加入模块表示生成的目标可执行文件的名称即编译后生成的可执行文件是表示项目使用的模板是是一般的应用程序后面的记录了项目中包含的源程序文件头文件和窗体文件文件的名称这些文件列表是自动添加到项目管理文件里面的用户不需要手动修改当添加一个文件到项目或从项目里删除一个文件时项目管理文件里的条目会自动修改项目界面文件及其作用超详细项目中后缀为的文件是可视化设计的窗体的定义文件如双击项目文件目录树中的文件会打开一个集成在中的对窗体进行可视化设计如图所示图集成在中的设计器本教程后面将称这个集成在中的为设计器以便与独立运行的区别开来图中的设计器有以下一些功能区域组件面板窗口左侧是界面设计组件面板分为多个组如等界面设计的常见组件都可以在组件面板里找到中间主要区域是待设计的窗体如果要将某个组件放置到窗体上时从组件面板上拖放一个组件到窗体上即可例如先放一个和一个到窗体上和编辑器与编辑器是位于待设计窗体下方的两个编辑器和编辑器用于可视化地进行信号与槽的关联编辑器用于可视化设计布局和界面设计工具栏窗口上方的一个工具栏工具栏上的按钮主要实现布局和界面设计对象浏览器窗口右上方是用树状视图显示窗体上各组件之间的布局包含关系视图有两列显示每个组件的对象名称和类名称属性编辑器窗口右下方是属性编辑器是界面设计时最常用到的编辑器属性编辑器显示某个选中的组件或窗体的各种属性及其取值可以在属性编辑器里修改这些属性的值图显示的是选中窗体上放置的标签组件后属性编辑器的内容最上方显示的文字表示这个组件是一个类的组件是图界面组件的属性编辑器属性编辑器的内容分为两列分别为属性的名称和属性的值属性又分为多个组实际上表示了类的继承关系如在图中可以看出的继承关系是表示组件的对象名称界面上的每个组件都需要一个唯一的对象名称以便被引用界面上的组件的命名应该遵循一定的法则具体使用什么样的命名法则根据个人习惯而定主要目的是便于区分和记忆也要便于与普通变量相区分设置其他属性的值只需在属性编辑器里操作即可如设置的属性为只需像图那样修改属性的值即可提示标准语言里并没有关键字是对标准的扩展使得在里就可以可视化设置类的数据在图显示的设计窗体上放置一个和一个组件它们的主要属性设置见表类名称属性设置备注设置标签显示文字和字体设置按钮的文字编辑完属性之后再为按钮增加一个功能就是单击此按钮时关闭窗口退出程序使用和编辑器完成这个功能如图所示图信号与槽编辑器中设计信号与槽的关联在信号与槽编辑器的工具栏上单击按钮在出现的条目中选择选择选择窗体选择这样设置表示当按钮被单击时就执行的函数实现关闭窗口的功能然后对项目进行编译和运行可以出现如图所示的窗口单击按钮可以关闭程序图具有按钮的程序标签的文字内容和字体被修改了窗口标题也显示为所设置的标题而我们并没有编写一行程序语句是怎么实现这些功能的呢为了搞清楚窗体类的定义以及界面功能的实现原理这里将项目进行编译编译后在项目目录下会自动生成一个文件这样对于一个窗体就有个文件了各文件的功能说明见表文件名功能定义窗体类的头文件定义了类类的功能实现源程序文件窗体界面文件由设计器自动生成存储了窗体上各个组件的属性设置和布局编译后根据窗体上的组件及其属性信号与槽的关联等自动生成的一个类的定义文件类的名称是下面分别分析各个文件的内容及其功能以及它们是如何联系在一起工作实现界面的创建与显示的文件文件是窗体类的头文件在创建项目时选择窗体基类是在中定义了一个继承自的类下面是文件的内容文件有几个重要的部分声明代码中有如下的一个声明这是声明了一个名称为的命名空间包含一个类但是这个类并不是本文件里定义的类而是文件里定义的类用于描述界面组件的这个声明相当于一个外部类型声明具体要看完文件内的解释之后才能搞明白类的定义文件的主体部分是一个继承于的类的定义也就是本实例的窗体类在类中使用了宏这是使用的信号与槽和机制的类都必须加入的一个宏信号与槽在后面详细介绍在部分定义了类的构造函数和析构函数在部分又定义了一个指针这个指针是用前面声明的里的类定义的所以指针是指向可视化设计的界面后面会看到要访问界面上的组件都需要通过这个指针文件文件是类的实现代码下面是文件的内容注意到在这个文件的包含文件部分自动加入了如下一行内容这个就是编译生成的与文件对应的类定义文件目前只有构造函数和析构函数其中构造函数头部是其意义是执行父类的构造函数创建一个类的对象这个就是的部分定义的指针变量构造函数里只有一行语句它是执行了类的函数这个函数实现窗口的生成与各种属性的设置信号与槽的关联后面会具体介绍析构函数只是简单地删除用创建的指针所以在文件里有一个名称为里面有一个类是用于描述可视化设计的窗体且与里定义的类同名在类里访问类的成员变量或函数需要通过类里的指针如同构造函数里执行函数那样文件是窗体界面定义文件是一个文件定义了窗口上的所有组件的属性设置布局及其信号与槽函数的关联等用设计器可视化设计的界面都由自动解析并以文件的形式保存下来在设计界面时只需在设计器里进行可视化设计即可而不用管文件是怎么生成的下面是文件的内容文件是在对文件编译后生成的一个文件会出现在编译后的目录下或与同目录与项目的编译设置有关文件并不会出现在的项目文件目录树里当然可以手工将添加到项目中方法是在项目文件目录树上右击项目名称节点在调出的快捷菜单中选择找到并添加文件即可注意是对文件编译后自动生成的又是通过设计器可视化设计生成的所以对手工进行修改没有什么意义所有涉及界面的修改都应该直接在设计器里进行所以也没有必要添加到项目里下面是文件的内容查看文件的内容发现它主要做了以下的一些工作定义了一个类用于封装可视化设计的界面自动生成了界面各个组件的类成员变量定义在部分为界面上每个组件定义了一个指针变量变量的名称就是设置的比如在窗体上放置了一个和一个并命名后自动生成的定义是定义了函数这个函数用于创建各个界面组件并设置其位置大小文字内容字体等属性设置信号与槽的关联函数体的第一部分是根据可视化设计的界面内容用代码创建界面上各组件并设置其属性接下来调用了函数用来设置界面各组件的文字内容属性如标签的文字按键的文字窗体的标题等将界面上的文字设置的内容独立出来作为一个函数在设计多语言界面时会用到这个函数函数的第三部分是设置信号与槽的关联本文件中有以下两行第行是调用函数将在设计器里设置的信号与槽的关联转换为语句这里是将按键的信号与窗体的槽函数关联起来就是在图中设置的信号与槽的关联的程序语句实现这样当单击按钮时就会执行的槽函数而槽函数的功能是关闭窗口第行是设置槽函数的关联方式用于将设计器自动生成的组件信号的槽函数与组件信号相关联所以在的构造函数里调用就实现了窗体上组件的创建属性设置信号与槽的关联定义并定义一个从继承的类提示文件里实现界面功能的类是再定义一个类从继承而来并定义在里这样与里的类同名但是用区分开来所以界面的类与文件里定义的类实际上是两个类但是的处理让用户感觉不到类的存在只需要知道在类里用指针可以访问可视化设计的界面组件就可以了项目中主函数及其作用是实现函数的文件下面是文件的内容定义并创建应用程序定义并创建窗口显示窗口应用程序运行函数是应用程序的入口它的主要功能是创建应用程序创建窗口显示窗口并运行应用程序开始应用程序的消息循环和事件处理是的标准应用程序类第行代码定义了一个类的实例就是应用程序对象然后定义了一个类的变量是本实例设计的窗口的类名定义此窗口后再用显示此窗口最后一行用启动应用程序的执行开始应用程序的消息循环和事件处理界面布局管理详解在上一节通过一个简单的应用程序分析了创建的应用程序中各个文件的作用剖析了可视化设计的文件是如何被转换为的类定义并自动创建界面的这些是使用可视化设计用户界面并使各个部分融合起来运行的基本原理本节再以一个稍微复杂的例子来讲解设计的常见功能包括界面设计时布局的管理以及程序里如何访问界面组件实例程序功能创建一个项目在创建窗体时选择基类生成的类命名为并选择生成窗体如此新建的项目有一个界面文件一个头文件和源程序文件此外还有项目文件和主程序文件界面文件设计时界面如图所示程序的主要功能是对中间一个文本框的文字字体样式和颜色进行设置图实例程序设计时界面在界面设计时对需要访问的组件修改其如各个按钮需要读取输入的编辑框需要显示结果的标签等以便在程序里区分对于不需要程序访问的组件则无需修改其如用于界面上组件分组的布局等让设计器自动命名即可对图中几个主要组件的命名属性设置见表对象名类名称属性设置备注用于显示文字内容可编辑设置字体为下划线设置字体为斜体设置字体为粗体字体颜色为黑色字体颜色为红色字体颜色为蓝色确定返回确定并关闭窗口取消返回取消并关闭窗口退出退出程序界面窗口的类名称是不要修改对于界面组件的属性设置需要注意以下几点是窗体上创建的组件的实例名称界面上的每个组件需要有一个唯一的程序里访问界面组件时都是通过其进行访问自动生成的槽函数名称里也有所以组件的需要在设计程序之前设置好设置好之后一般不要再改动若设计程序之后再改动涉及的代码需要相应的改动窗体的就是窗体的类名称在设计器里不要修改窗体的窗体的实例名称需要在使用窗体的代码里去定义界面组件布局的界面设计使用了布局功能所谓布局就是界面上组件的排列方式使用布局可以使组件有规则地分布并且随着窗体大小变化自动地调整大小和相对位置布局管理是设计的必备技巧下面逐步讲解如何实现图所示的界面设计界面组件的层次关系为了将界面上的各个组件的分布设计得更加美观经常使用一些容器类如等例如将个组件放置在一个组件里该组件就是这个的容器移动这个就会同时移动其中的个图界面组件的放置及层次关系图显示的是设计图界面的前期阶段在窗体上放置了个组件在里放置个组件在里放置个组件图右侧里显示了界面上各组件之间的层次关系布局管理为界面设计提供了丰富的布局管理功能在设计器中组件面板里有和两个组件面板在窗体上方的工具栏里有布局管理的按钮如图所示图用于布局可视化设计的组件面板和工具栏和两个组件面板里的布局组件的功能见表布局组件功能垂直方向布局组件自动在垂直方向上分布水平方向布局组件自动在水平方向上分布网格状布局网状布局大小改变时每个网格的大小都改变窗体布局与网格状布局类似但是只有最右侧的一列网格会改变大小一个用于水平分隔的空格一个用于垂直分隔的空格使用组件面板里的布局组件设计布局时先拖放一个布局组件到窗体上如在设计图中个按钮的布局时先放一个到窗体上布局组件会以红色边框显示再往布局组件里拖放个和个就可以得到图中个按钮的水平布局效果在设计窗体的上方有一个工具栏用于调整设计器进入不同的状态以及进行布局设计工具栏上各按钮的功能见表按钮及快捷键功能界面设计进入编辑状态就是正常的设计状态进入信号与槽的可视化设计状态进入伙伴关系编辑状态可以设置一个与一个组件成为伙伴关系进入顺序编辑状态顺序是在键盘上按键时输入焦点在界面各组件之间跳动的顺序将窗体上所选组件水平布局将窗体上所选组件垂直布局将窗体上所选组件用一个分割条进行水平分割布局将窗体上所选组件用一个分割条进行垂直分割布局将窗体上所选组件按窗体布局将窗体上所选组件网格布局解除窗体上所选组件的布局也就是打散现有的布局自动调整所选组件的大小使用工具栏上的布局控制按钮时只需在窗体上选中需要设计布局的组件然后点击某个布局按钮即可在窗体上选择组件时同时按住键可以实现组件多选选择某个容器类组件相当于选择了其内部的所有组件例如在图的界面中选中然后单击工具栏按钮就可以对内的个水平布局在图的界面上使里的个水平布局里的个水平布局下方个按钮水平布局在窗体上又放置了一个组件现在改变或按钮的水平布局的大小其内部组件都会自动改变大小但是当改变窗体大小时界面上的各组件却并不会自动改变大小随后还需为窗体指定一个总的布局选中窗体即不要选择任何组件单击工具栏上的按钮使个组件垂直分布这样布局后当窗体大小改变时各个组件都会自动改变大小在设计器里可视化设计布局时要善于利用水平和垂直空格组件善于设置组件的最大最小宽度和高度来实现某些需要的布局效果伙伴关系与顺序在设计工具栏上单击按钮可以进入伙伴关系编辑状态如设计一个窗体时进入伙伴编辑状态之后的界面如图所示图编辑伙伴关系伙伴关系是指界面上一个和一个组件相关联如图中的伙伴关系编辑状态单击一个按住鼠标左键然后拖向一个组件就建立了和组件之间的伙伴关系伙伴关系是为了在程序运行时在窗体上用快捷键快速将输入焦点切换到某个组件上例如在图的界面上设定姓名标签的属性为姓名其中符号用来指定快捷字符界面上并不显示这里指定快捷字母为那么程序运行时用户按下输入焦点就会快速切换到姓名关联的输入框内图顺序编辑状态在设计器工具栏上单击按钮进入顺序编辑状态如图所示顺序是指在程序运行时按下键盘上的键时输入焦点的移动顺序一个好的用户界面在按键时焦点应该以合理的顺序在界面上移动而不是随意地移动进入顺序编辑状态后在界面上会显示具有顺序组件的编号依次按希望的顺序单击组件就可以重排顺序了没有输入焦点的组件是没有顺序的如组件项目功能实现下面开始设计程序功能对于该程序希望它的功能如下单击个时根据其状态设置里的文字的字体样式个是互斥选择的单击某个时设置文字的颜色单击确定取消或退出按钮时关闭窗口退出程序字体样式设置窗体在设计模式下选中组件单击右键调出其快捷菜单在快捷菜单中单击菜单项中文状态为转到槽出现如图所示的对话框图的对话框该对话框列出了类的所有信号第一个是第二个是带一个布尔类型参数的信号会将组件当前的选择状态作为一个参数传递在响应代码里可以直接利用这个传递的参数而如果用信号则需要在代码里读取组件的选中状态为了简化代码选择信号选择然后单击按钮在的类定义中会在部分自动增加一个槽函数声明函数名是根据发射对象及其信号名称自动命名的同时在文件中自动添加了函数的框架在此函数中添加如下的代码实现文本框字体下划线的控制以同样的方法为和两个设计槽函数编译后运行发现已经实现了修改字体的下划线斜体粗体属性的功能说明信号与槽函数已经关联了但是查看的构造函数构造函数只有简单的一条语句这里没有发现用函数进行几个的信号与槽函数关联的操作这些功能是如何实现的呢查看编译生成的文件构造函数里调用的是在文件里实现的查看函数的内容也没有发现用函数进行几个的信号与槽关联的操作只是在里发现了如下的一条语句秘密就在于这条语句函数将搜索界面上的所有组件将信号与槽函数匹配的信号和槽关联起来它假设槽函数的名称是例如通过设计器的操作为自动生成的槽函数是它就正好是的信号的槽函数那么就会将此信号和槽函数关联起来如同执行了下面的这样一条语句这就是用设计器可视化设计某个组件的信号响应槽函数而不用手工去将其关联起来的原因都是在界面类的构造函数里调用自动完成了关联字体颜色设置设置字体的个是互斥性选择的即一次只有一个被选中虽然也可以采用可视化设计的方式设计其信号的槽函数但是这样就需要生成个槽函数这里可以简化设计即设计一个槽函数将个的信号关联到这一个槽函数为此在类的部分增加一个槽函数定义如下提示将鼠标光标移动到这个函数的函数名上面单击右键在弹出的快捷菜单中选择就可以在文件中自动为函数生成一个函数框架在文件中为编写实现代码如下由于这个槽函数是自定义的所以不会自动与的事件关联此时编译后运行程序不会实现改变字体颜色的功能需要在的构造函数中手工进行关联代码如下在构造函数中将个的信号与同一个槽函数相关联再编译后运行就可以更改文字的颜色了三个按钮的功能设计界面上还有确定取消退出个按钮这是在对话框中常见的按钮确定表示确认选择并关闭对话框取消表示取消选择并关闭对话框退出则直接关闭对话框是从继承而来的提供了等槽函数来表示这三种状态只需将按钮的信号与相应槽函数关联即可下面采用可视化的方式将按钮的信号与这些槽函数关联起来在设计器里单击上方工具栏里的按钮窗体进入信号与槽函数编辑状态如图所示图窗体进入编辑状态将鼠标移动到确定按钮上方再按下鼠标左键移动到窗体的空白区域释放左键这时出现如图所示的关联设置对话框图信号与槽关联编辑对话框在图中左侧的列表框里显示了的信号选择右边的列表框里显示了的槽函数选择单击按钮同样的方法可以将的信号与的槽函数关联将的信号与的槽函数关联注意在图的右侧列表框中没有槽函数需要勾选下方的才会出现函数设置完个按钮的信号与槽关联之后在窗体下方的和编辑器里也显示了这个关联实际上可以直接在和编辑器进行关联设置现在编译并运行程序单击这个按钮都会关闭程序那么这个按钮的信号与槽函数的关联是在哪里实现的呢答案在函数里在函数里自动增加了以下行代码这个实例程序的功能全部完成了采用设计器设计了窗体界面采用可视化和程序化的方式设计槽函数设计信号与槽函数之间的关联从以上的设计过程可以看到和设计器为设计应用程序提供了强大的可视化设计功能信号与槽机制详解信号与槽是编程的基础也是的一大创新因为有了信号与槽的编程机制在中处理界面各个组件的交互操作时变得更加直观和简单信号就是在特定情况下被发射的事件例如最常见的信号就是鼠标单击时发射的信号一个最常见的信号是选择的列表项变化时发射的信号程序设计的主要内容就是对界面上各组件的信号的响应只需要知道什么情况下发射哪些信号合理地去响应和处理这些信号就可以了槽就是对信号响应的函数槽就是一个函数与一般的函数是一样的可以定义在类的任何部分或可以具有任何参数也可以被直接调用槽函数与一般的函数不同的是槽函数可以与一个信号关联当信号被发射时关联的槽函数被自动执行信号与槽关联是用函数实现的其基本格式是是类的一个静态函数而是所有类的基类在实际调用时可以忽略前面的限定符所以可以直接写为其中是发射信号的对象的名称是信号名称信号可以看做是特殊的函数需要带括号有参数时还需要指明参数是接收信号的对象名称是槽函数的名称需要带括号有参数时还需要指明参数和是的宏用于指明信号和槽并将它们的参数转换为相应的字符串例如在前面章节中的项目的文件中在函数中有如下的语句其作用就是将按钮的信号与窗体的槽函数相关联这样当单击按钮就是界面上的按钮时就会执行的槽函数关于信号与槽的使用有以下一些规则需要注意一个信号可以连接多个槽例如这是当一个对象的数值发生变化时所在窗体有两个槽进行响应一个用于计算一个用于更新状态当一个信号与多个槽函数关联时槽函数按照建立连接时的顺序依次执行当信号和槽函数带有参数时在函数里要写明参数的类型但可以不写参数名称多个信号可以连接同一个槽例如在前面章节中的项目中让三个选择颜色的的信号关联到相同的一个自定义槽函数这样当任何一个被单击时都会执行函数一个信号可以连接另外一个信号例如这样当一个信号发射时也会发射另外一个信号实现某些特殊的功能严格的情况下信号与槽的参数个数和类型需要一致至少信号的参数不能少于槽的参数如果不匹配会出现编译错误或运行错误在使用信号与槽的类中必须在类的定义中加入宏当一个信号被发射时与其关联的槽函数通常被立即执行就像正常调用一个函数一样只有当信号关联的所有槽函数执行完毕后才会执行发射信号处后面的代码信号与槽机制是编程的基础使用信号与槽机制可以比较容易地将信号与响应代码关联起来纯代码设计实例分析的可视化设计是对用户而言的其实底层都是的代码实现只是巧妙地进行了处理让用户省去了很多繁琐的界面设计工作由于界面设计的底层其实都是由语言实现的底层实现的功能比可视化设计更加强大和灵活某些界面效果是可视化设计无法完成的或者某些人习惯了用纯代码的方式来设计界面就可以采用纯代码的方式设计界面如自带的实例基本都是用纯代码方式实现用户界面的所以本节介绍一个用纯代码方式设计的实例通过实例了解用纯代码设计的基本原理与前面的可视化设计相对应且称之为代码化设计实例功能首先建立一个项目在创建项目向导中选择基类时选择基类新类的名称命名为关键是取消创建窗体即不勾选创建界面复选框创建后的项目文件目录树下没有文件该项目通过代码创建一个对话框实现与类似的界面和功能本例完成后的运行效果如图所示其界面和功能与类似图实例运行效果界面创建类定义完成功能后的文件中类的完整定义如下创建与初始化初始化信号与槽的链接的信号的槽函数的信号的槽函数的信号的槽函数设置字体颜色在类的部分声明了界面上的各个组件的指针变量这些界面组件都需要在类的构造函数里创建并在窗体上布局在部分自定义了两个函数用来创建所有界面组件并完成布局和属性设置用来完成所有的信号与槽函数的关联在部分声明了个槽函数分别是个的响应槽函数以及个颜色设置的的共同响应槽函数注意与可视化设计得到的窗体类定义不同的类定义里没有指向界面的指针这几个槽函数的功能与例中的类似只是在访问界面组件时无需使用指针而是直接访问类里定义的界面组件的成员变量即可例如的代码界面的创建以及信号与槽函数的关联都在的构造函数里完成构造函数代码如下界面创建与布局信号与槽的关联构造函数调用创建界面组件并布局调用进行信号与槽函数的关联界面组件的创建与布局函数实现界面组件的创建与布局以及属性设置下面是的完整代码创建个并水平布局创建个并水平布局创建确定取消退出个并水平布局确定取消退出创建文本框并设置初始字体获取字体修改字体大小设置字体创建垂直布局并设置为主布局添加字体类型组添加字体颜色组添加添加按键组设置为窗体的主布局函数按照顺序完成了如下的功能创建个组件这个组件的指针已经定义为的私有变量然后创建一个水平布局将个添加到这个水平布局里创建个组件并创建一个水平布局将个添加到这个水平布局里创建个组件并创建一个水平布局将个添加到这个水平布局里并适当添加水平空格创建一个组件设置其文字内容并设置其字体创建一个垂直布局将前面创建的个水平布局和文本框依次添加到此布局里设置垂直布局为窗体的主布局如此创建组件并设置布局后运行可以得到如图所示的界面效果这里完全是采用代码来实现组件创建与布局的设置而这些功能在可视化设计中是由函数根据界面的可视化设计结果自动实现的采用代码设计实现时需要对组件的布局有个完整的规划不如可视化设计直观且编写代码工作量大信号与槽的关联在纯代码设计时信号与槽的关联也需要用代码来完成函数初始化所有的信号与槽的关联其完整代码如下三个颜色的信号与槽函数关联三个字体设置的的信号与相应的槽函数关联三个按钮的信号与窗体的槽函数关联设计完成后编译并运行程序可以得到如图所示的运行效果且功能与相同很显然采用纯代码方式实现界面是比较复杂的代码设计的工作量大而繁琐使用技巧在设计界面或编辑代码时有一些快捷键和使用技巧熟悉这些快捷键和使用技巧可以提高工作效率表是的一些快捷操作的总结功能快捷键解释在同名的头文件和源程序文件之间切换跟踪光标下的符号若是变量可跟踪到变量声明的地方若是函数体或函数声明可在两者之间切换在函数的声明函数原型和定义函数实现之间切换对光标处的符号更改名称这将替换到所有用到这个符号的地方为函数原型在文件里生成函数体为选择的文字自动进行缩进为选择的文字进行注释符号的切换即可以注释所选代码或取消注释为光标所在的符号显示帮助文件的内容文件全部保存调出查找替换对话框查找下一个编译当前项目开始调试调试状态下单步略过即执行当前行程序语句调试状态下跟踪进入即如果当前行里有函数就跟踪进入函数体设置或取消当前行的断点设置另外在使用时要善于使用自带的帮助文件对于一个编程语言或类库来说其自带的帮助文件是最全面最权威的资料当光标停留在一个类名或函数上时按可以调出其帮助文件的内容在主窗口左侧的主工具栏上有按钮单击可以打开的帮助文件系统如图所示也可以使用开始菜单程序组里的单独打开帮助系统图使用的帮助系统查看资料在帮助文件显示界面上左上方工具栏中有个下拉列表框可以选择和种模式模式下左边框里显示已存储的书签任何帮助页面下点击窗口上方工具栏上的可以添加书签模式下左边框里以目录树形式显示的所有模块如图所示可以分类浏览想看的内容模式下可以输入查找内容左边框里会列出与输入内容前匹配的帮助主题列表模式下可以输入关键字进行搜索在帮助系统里可以搜索查看每个类的详细资料如可以看到这个类的详细资料包括在这个类定义的公共类型属性公共函数信号公共槽等另外若要查看类的继承关系可以访问官网的页面元对象和属性系统详解是一个用标准编写的跨平台开发类库它对标准进行了扩展引入了元对象系统信号与槽属性等特性使应用程序的开发变得更高效本节将介绍的这些核心特点对于理解和编写高效的程序是大有帮助的的元对象系统的元对象系统提供了对象之间通信的信号与槽机制运行时类型信息和动态属性系统元对象系统由以下三个基础组成类是所有使用元对象系统的类的基类在一个类的部分声明宏使得类可以使用元对象的特性如动态属性信号与槽元对象编译器为每个的子类提供必要的代码来实现元对象系统的特性构建项目时工具读取源文件当它发现类的定义里有宏时它就会为这个类生成另外一个包含有元对象支持代码的源文件这个生成的源文件连同类的实现文件一起被编译和连接除了信号与槽机制外元对象还提供如下一些功能函数返回类关联的元对象元对象类包含了访问元对象的一些接口函数例如函数可在运行时返回类的名称字符串返回函数创建类的一个新的实例函数判断一个对象实例是否是名称为的类或的子类的实例例如是的子类返回返回返回不是的子类和函数可翻译字符串用于多语言界面设计后续章会专门介绍多语言界面设计和函数用于通过属性名称动态设置和获取属性值对于及其子类还可以使用函数进行动态投射例如假设是的子类并且在类定义中声明了宏创建实例使用下面的语句变量定义为指针但它实际指向类所以可以正确投射为即从到的投射是成功的因为实际是类是的子类也可以将其成功投射为即投射为是成功的因为并不区分内建的类型和用户自定义类型但是若要将投射为则是失败的即这样投射是失败的返回指针为因为不是的子类使用动态投射使得程序可以在运行时对不同的对象做不同的处理属性系统属性定义提供一个宏可以定义属性它也是基于元对象系统实现的的属性系统与编译器无关可以用任何标准的编译器编译定义了属性的程序在的子类中用宏定义属性其使用格式如下宏定义一个返回值类型为名称为的属性用关键字定义属性的读取写入函数还有其他的一些关键字定义属性的一些操作特性属性的类型可以是支持的任何类型也可以用户自定义类型宏定义属性的一些主要关键字的意义如下指定一个读取属性值的函数没有关键字时必须设置指定一个设定属性值的函数只读属性没有设置指定一个成员变量与属性关联成为可读可写的属性无需再设置和是可选的用于指定一个设置属性缺省值的函数是可选的用于设置一个信号当属性值变化时发射此信号表示属性是否在里可见缺省为表示属性值是一个常数对于一个对象实例指定的函数返回值是常数但是每个实例的返回值可以不一样具有关键字的属性不能有和关键字表示所定义的属性不能被子类重载类定义属性的一些例子如下属性的使用不管是否用和定义了接口函数只要知道属性名称就可以通过读取属性值并通过设置属性值例如动态属性函数可以在运行时为类定义一个新的属性称之为动态属性动态属性是针对类的实例定义的动态属性可以使用查询就如在类定义里用宏定义的属性一样例如在数据表编辑界面上一些字段是必填字段就可以在初始化界面时为这些字段的关联显示组件定义一个新的属性并设置值为如然后可以应用下面的样式定义将这种必填字段的背景颜色设置为亮绿色类的附加信息属性系统还有一个宏可以为类的元对象定义名称值信息如用宏定义附加类信息后可以通过元对象的一些函数获取类的附加信息如获取某个附加信息函数原型定义如下返回值是类型有和两个函数可获得类附加信息的名称和值全局变量函数和宏定义详解头文件包含了类库的一些全局定义包括基本数据类型函数和宏一般的类的头文件都会包含该文件所以不用显式包含这个头文件也可以使用其中的定义全局变量定义为了确保在各个平台上各数据类型都有统一确定的长度为各种常见数据类型定义了类型符号如就是的类型定义即中定义的数据类型见表数据类型等效定义字节数其中缺省是字节类型浮点数如果使用选项进行配置就是字节类型的浮点数是中新增的一个类用于表示位的浮点数要使用需要包含头文件全局函数定义头文件包含一些常用函数的定义这些函数多以模板类型作为参数返回相应的模板类型模板类型可以用任何其他类型替换若是以或类型数作为参数的一般有两个参数版本的同名函数如和表是中常用的全局函数定义列出了函数的输入和输出参数若存在和两种参数版本只列出类型参数的版本函数功能返回变量的绝对值返回限定在至范围之内的値若和近似相等返回如果参数约等于返回返回无穷大的数若是一个有限的数返回若是一个无限大的数返回若不是一个数返回返回和中较大的值返回和中较小的值将近似为最接近的整数将近似为最接近的整数标准中函数的线程安全型版本返回至之间的伪随机数标准中函数的线程安全型版本使用种子对伪随机数字序列初始化还有一些基础的数学运算函数在头文件中定义比如三角运算函数弧度与角度之间的转换函数等全局宏定义中文件中定义了很多宏以下一些是比较常用的这个宏展开为数值形式表示编译器版本例如编译器版本为则为这个宏常用于条件编译设置根据版本不同编译不同的代码段这个宏展开为版本号的一个整数表示例如这个宏展开为版本号的字符串如和表示系统内存中数据的字节序表示大端字节序表示小端字节序在需要判断系统字节序时会用到例如和在使用或设计共享库时用于导入或导出库的内容后续章节有其使用实例在类定义中用于重载一个虚函数例如在某个类中重载虚函数可以定义如下使用宏后如果重载的虚函数没有进行任何重载操作编译器将会报错这个宏将一个虚函数定义为最终级别不能再被重载或定义一个类不能再被继承示例如下这个宏用于在函数中定义不在函数体里使用的参数示例如下在这个函数里参数没有使用如果不用定义编译器会出现参数未使用的警告用于容器类的遍历例如用于构造一个无限循环例如在窗体显示信息如果编译器设置了则不作任何输出例如类似的宏还有等也是用于在窗体显示信息顺序容器类和关联容器类详解提供了多个基于模板的容器类这些容器类可以用于存储指定类型的数据项例如常用的字符串列表类就是从容器类继承的实现对字符串列表的添加存储删除等操作的容器类比标准模板库中的容器类更轻巧安全和易于使用这些容器类是隐式共享和可重入的而且它们进行了速度和存储优化因此可以减少可执行文件的大小此外它们还是线程安全的也就是说它们作为只读容器时可被多个线程访问容器类是基于模板的类如常用的容器类是一个具体的类型可以是等简单类型也可以是等类但不能是或任何其子类必须是一个可赋值的类型即必须提供一个缺省的构造函数一个可复制构造函数和一个赋值运算符例如用定义一个字符串列表的容器其定义方法是这样定义了一个容器类的变量它的数据项是所以可以用于处理字符串列表例如的容器类分为顺序容器和关联容器顺序容器类的顺序容器类有和是最常用的容器类虽然它是以数组列表的形式实现的但是在其前或后添加数据非常快以下标索引的方式对数据项进行访问用于添加插入替换移动删除数据项的函数有和等提供下标索引方式访问数据项如同数组一样也提供函数例如的函数在数据项为空时返回函数返回数据项的个数是中最常用的容器类很多函数的参数传递都是采用容器类例如的静态函数的函数原型是其返回数据就是类型的列表是链式列表数据项不是用连续的内存存储的它基于迭代器访问数据项并且插入和删除数据项的操作时间相同除了不提供基于下标索引的数据项访问外的其他接口函数与基本相同提供动态数组的功能以下标索引访问数据的函数接口与几乎完全相同的性能比更高因为的数据项是连续存储的是提供类似于堆栈的后入先出操作的容器类和是主要的接口函数例如程序会依次输出是提供类似于队列先入先出操作的容器类和是主要操作函数例如程序会依次输出关联容器类还提供关联容器类和和支持一个键关联多个值和类使用散列函数进行查找查找速度更快是基于散列表的集合模板类它存储数据的顺序是不定的查找值的速度非常快内部就是用实现的定义容器和输入数据的实例代码如下测试一个值是否包含于这个集合用函数示例如下提供一个字典关联数组一个键映射到一个值存储数据是按照键的顺序如果不在乎存储顺序使用会更快定义类型变量和赋值的示例代码如下也可以使用函数赋值或移除一个键值对示例如下要查找一个值使用运算符或函数示例如下如果在映射表中没有找到指定的键会返回一个缺省构造值例如如果值的类型是字符串会返回一个空的字符串在使用函数查找键值时还可以指定一个缺省的返回值示例如下这表示如果在里找到键就返回关联的值否则返回值为是的子类是用于处理多值映射的便利类多值映射就是一个键可以对应多个值正常情况下不允许多值映射除非使用添加键值对是的子类所以的大多数函数在都是可用的但是有几个特殊的等效于等效于使用示例如下不提供操作符使用函数访问最新插入的键的单个值如果要获取一个键对应的所有值使用函数返回值是类型是基于散列表来实现字典功能的模板类存储的键值对具有非常快的查找速度与的功能和用法相似区别在于以下几点比的查找速度快在上遍历时数据项是按照键排序的而的数据项是任意顺序的的键必须提供运算符的键必须提供运算符和一个名称为的全局散列函数是的子类是用于处理多值映射的便利类其用法与类似迭代器类型和类型详解迭代器为访问容器类里的数据项提供了统一的方法有两种迭代器类类型的迭代器和类型的迭代器两者比较类型的迭代器更易于使用且提供一些高级功能而类型的迭代器效率更高类型迭代器对于每个容器类有两个类型迭代器一个用于只读操作一个用于读写操作各个类型的容器类见表容器类只读迭代器读写迭代器和等关联容器类的迭代器用法相冋和等容器类的用法相同所以下面只以和为例介绍迭代器的用法顺序容器类的迭代器的使用类型迭代器的指针不是指向一个数据项而是在数据项之间迭代器指针位置示意图如图所示图类型迭代器位置示意图下面是遍历访问一个容器的所有数据项的典型代码容器对象作为参数传递给迭代器的构造函数用于对作只读遍历起始时刻迭代器指针在容器第一个数据项的前面图中数据项的前面调用判断在迭代器指针后面是否还有数据项如果有就调用跳过一个数据项并且函数返回跳过去的那个数据项也可以反向遍历示例代码如下用于移动指针和读取数据的函数见表函数名功能迭代器移动到列表的最前面第一个数据项之前迭代器移动到列表的最后面最后一个数据项之后如果迭代器不是位于列表最后位罝返回返回下一个数据项并且迭代器后移一个位置返回下一个数据项但是不移动迭代器位置如果迭代器不是位于列表的最前面返回返回前一个数据项并且迭代器前移一个位置返回前一个数椐项但是不移动迭代器指针是只读访问容器内数据项的迭代器若要在遍历过程中对容器的数据进行修改需要使用例如下面的示例代码为删除容器中数据为奇数的项函数移除函数刚刚跳过的一个数据项不会使迭代器失效函数可以修改刚刚跳过去的数据项的值关联容器类的迭代器的使用对于关联容器类使用和迭代器类它们具有表所示的所有函数主要是增加了和函数用于获取刚刚跳过的数据项的键和值例如下面的代码将删除键城市名称里以结尾的数据项如果是在多值容器里遍历可以用或查找下一个或上一个值如下面的代码将删除上一示例代码中里值为的所有数据项类型迭代器迭代器与和的原生算法兼容并且进行了速度优化具体类型见表容器类只读迭代器读写迭代器对于每一个容器类都有两个类型迭代器一个用于只读访问一个用于读写访问无需修改数据时一定使用只读迭代器因为它们速度更快注意在定义只读迭代器和读写迭代器时的区别它们使用了不同的关健字定义只读迭代器定义读写迭代器此外还可以使用和定义相应的反尚迭代器类型的迭代器是数组的指针所以运算符使迭代器指向下一个数据项运算符返回数据项内容与类型的迭代器不同迭代器直接指向数据项迭代器指向位置示意图如图所示图类型迭代器位置示意图函数使迭代器指向容器的第一个数据项函数使迭代器指向一个虚拟的表示结尾的数据项表示的数据项是无效的一般用作循环结束条件下面仍然以和为例说明迭代器的用法其他容器类迭代器的用法类似顺序容器类的迭代器的用法下面的示例代码将里的数据项逐项输出和是用于只读迭代器的表示起始和结束位置若使用反向读写迭代器并将上面示例代码中的数据项都改为小写代码如下关联容器类的迭代器的用法对于关联容器类和迭代器的操作符返回数据项的值如果想返回键使用函数对应的用函数返回一个项的值例如下面的代码将中所有项的键和值输出包含很多返回值为或的函数要遍历这些返回的容器必须先复制由于使用了隐式共享这样的复制并无多大开销例如下面的代码是正确的提示隐式共享是对象的管理方法一个对象被隐式共享只是传递该对象的一个指针给使用者而不实际复制对象数据只有在使用者修改数据时才实质复制共享对象给使用者如在上面的代码中返回的是一个表对象但是实际上代码并不将表示的列表内容完全复制给变量只是传递给它一个指针只有当发生数据修改时才会将共享对象的数据复制给这样避免了不必要的复制减少了资源占用而下面的代码是错误的对于类型的迭代器隐式共享还涉及另外一个问题即当有一个迭代器在操作一个容器变量时不要去复制这个容器变量关键字用法无师自通提供一个关键字实际是里定义的一个宏用于方便地访问容器里所有数据项关键字用于遍历容路中所有的项使用的句法是使用的代码比使用迭代器更简洁例如使用遍历一个的示例代码如下用于迭代的变量也可以在语句里定义语句也可以使用花括号可以使用退出迭代示例代码如下对于和会自动访问键值对里的值所以无需调用如果需要访问键则可以调用示例代码如下对于多值映射可以使用两重语句示例代码如下注意关徤字遍历一个容器变量是创建了容器的一个副本所以不能修改原来容器变量的数据项编写第一个程序编写第一个程序编写第一个程序编写第一个程序编写第一个程序',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-09-13 19:01:08',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Stack Overflow" type="application/atom+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://cpp-memory-leaks.github.io" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/cpp-memory-leaks" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Stack Overflow</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> Search</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="微信" src="/null"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="/null"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> Newest Comments</span></div><div class="aside-list"><span>loading...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>3</sup></a><a href="/tags/C-cpprestsdk-openssl-tls-https/" style="font-size: 1.05rem;">C++ cpprestsdk openssl tls https<sup>1</sup></a><a href="/tags/C-libheif/" style="font-size: 1.05rem;">C++ libheif<sup>1</sup></a><a href="/tags/Qt/" style="font-size: 1.05rem;">Qt<sup>6</sup></a><a href="/tags/Qt-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/" style="font-size: 1.05rem;">Qt 自定义控件<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/09/"><span class="card-archive-list-date">September 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">August 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">March 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">January 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">December 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">November 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">September 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">August 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/Qt/" itemprop="url">Qt</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Qt/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Qt</span></a></span></div></div><h1 class="post-title" itemprop="name headline">QT详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-09-13T10:08:29.000Z" title="Created 2024-09-13 18:08:29">2024-09-13</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-09-13T11:01:08.418Z" title="Updated 2025-09-13 19:01:08">2025-09-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为深圳"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>深圳</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://raw.githubusercontent.com/cpp-memory-leaks/cpp-memory-leaks.github.io/refs/heads/master/img/qt_default_cover.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://cpp-memory-leaks.github.io/2024/09/13/QT%E8%AF%A6%E8%A7%A3/"><header><a class="post-meta-categories" href="/categories/Qt/" itemprop="url">Qt</a><a href="/tags/Qt/" tabindex="-1" itemprop="url">Qt</a><h1 id="CrawlerTitle" itemprop="name headline">QT详解</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">OQS</span><time itemprop="dateCreated datePublished" datetime="2024-09-13T10:08:29.000Z" title="Created 2024-09-13 18:08:29">2024-09-13</time><time itemprop="dateCreated datePublished" datetime="2025-09-13T11:01:08.418Z" title="Updated 2025-09-13 19:01:08">2025-09-13</time></header><h1 id="QT详解"><a href="#QT详解" class="headerlink" title="QT详解"></a>QT详解</h1><ol>
<li><strong>Qt 可以做什么？</strong></li>
</ol>
<p>Qt 虽然经常被当做一个 GUI 库，用来开发图形界面应用程序，但这并不是 Qt 的全部；Qt 除了可以绘制漂亮的界面（包括控件、布局、交互），还包含很多其它功能，比如多线程、访问数据库、图像处理、音频视频处理、网络通信、文件操作等，这些 Qt 都已经内置了。       总起来说，Qt 主要用于桌面程序开发和嵌入式开发。</p>
<ol start="2">
<li><strong>Qt 来开发 Windows 桌面程序有以下优点：</strong></li>
</ol>
<ul>
<li><p>简单易学：Qt 封装的很好，几行代码就可以开发出一个简单的客户端，不需要了解 Windows API。</p>
</li>
<li><p>资料丰富：资料丰富能够成倍降低学习成本，否则你只能去看源码，关于 DirectUI、Htmlayout、aardio 的资料就很少。</p>
</li>
<li><p>漂亮的界面：Qt 很容易做出漂亮的界面和炫酷的动画，而 MFC、WTL、wxWidgets 比较麻烦。</p>
</li>
<li><p>独立安装：Qt 程序最终会编译为本地代码，不需要其他库的支撑，而 Java 要安装虚拟机，C# 要安装 .NET Framework。</p>
</li>
<li><p>跨平台：如果你的程序需要运行在多个平台下，同时又希望降低开发成本，Qt 几乎是必备的。</p>
</li>
</ul>
<ol start="3">
<li>学习QT的基础</li>
</ol>
<p>C++依旧是 Qt 的主要编程语言，Qt 5 也并没有忽略它，Qt 5 添加了很多新的 C++ API，而且会持续更新。引入 QML 只是 Qt 5 提供的另外一种选择，并不是让它成为唯一的选择。C++ 是 Qt 的基础，无论如何都要掌握总的来说，C++ 对于 Qt 是不可或缺的，而 QML 只是一个加分项。</p>
<ol start="4">
<li>认识一下Qt用到的开发工具</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/qt/">Qt</a>不是凭空产生的，它是基于现有工具链打造而成的，它所使用的编译器、链接器、调试器等都不是自己的，Qt 官方只是开发了上层工具。下面我们分几个部分讲解 Qt 使用到的工具链。</p>
<h2 id="GNU-工具集-在-GNU-工具集里面，开发时常见到的几个罗列如下（这些工具通常位于-Linux-或-Unix-系统里的-usr-bin-目录）："><a href="#GNU-工具集-在-GNU-工具集里面，开发时常见到的几个罗列如下（这些工具通常位于-Linux-或-Unix-系统里的-usr-bin-目录）：" class="headerlink" title="GNU 工具集 在 GNU 工具集里面，开发时常见到的几个罗列如下（这些工具通常位于 Linux 或 Unix 系统里的 &#x2F;usr&#x2F;bin&#x2F; 目录）："></a>GNU 工具集 在 GNU 工具集里面，开发时常见到的几个罗列如下（这些工具通常位于 Linux 或 Unix 系统里的 &#x2F;usr&#x2F;bin&#x2F; 目录）：</h2><table>
<thead>
<tr>
<th>工具</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>gcc</td>
<td>GNU C 语言编译器。</td>
</tr>
<tr>
<td>g++</td>
<td>GNU <a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a> 语言编译器。</td>
</tr>
<tr>
<td>ld</td>
<td>GNU 链接器，将目标文件和库文件链接起来，创建可执行程序和动态链接库。</td>
</tr>
<tr>
<td>ar</td>
<td>生成静态库 .a ，可以编辑和管理静态链接库。</td>
</tr>
<tr>
<td>make</td>
<td>生成器，可以根据 makefile 文件自动编译链接生成可执行程序或库文件。</td>
</tr>
<tr>
<td>gdb</td>
<td>调试器，用于调试可执行程序。</td>
</tr>
<tr>
<td>ldd</td>
<td>查看可执行文件依赖的共享库（扩展名 .so，也叫动态链接库）。</td>
</tr>
</tbody></table>
<h2 id="MinGW"><a href="#MinGW" class="headerlink" title="MinGW"></a>MinGW</h2><p>原本 GNU 工具只在 Linux&#x2F;Unix 系统里才有，随着 Windows 系统的广泛使用， 为了在 Windows 系统里可以使用 GNU 工具，诞生了 MinGW（Minimalist GNU for Windows） 项目，利用 MinGW 就可以生成 Windows 里面的 exe 程序和 dll 链接库。 需要注意的是，MinGW 与 Linux&#x2F;Unix 系统里 GNU 工具集的有些区别：</p>
<ul>
<li><p>MinGW 里面工具带有扩展名 .exe， Linux&#x2F;Unix 系统里工具通常都是没有扩展名的。</p>
</li>
<li><p>MinGW 里面的生成器文件名为 mingw32-make.exe，Linux&#x2F;Unix 系统里就叫 make。</p>
</li>
<li><p>MinGW 在链接时是链接到 *.a 库引用文件，生成的可执行程序运行时依赖 *.dll，而 Linux&#x2F;Unix 系统里链接时和运行时都是使用 *.so 。</p>
</li>
</ul>
<p>另外 MinGW 里也没有 ldd 工具，因为 Windows 不使用 .so 共享库文件。如果要查看 Windows 里可执行文件的依赖库，需要使用微软自家的 Dependency Walker 工具。Windows 里面动态库扩展名为 .dll，MinGW 可以通过 dlltool 来生成用于创建和使用动态链接库需要的文件，如 .def 和 .lib。 MinGW 原本是用于生成 32 位程序的，随着 64 位系统流行起来， 从 MinGW 分离出来了 MinGW-w64 项目，该项目同时支持生成 64 位和 32 位程序。Qt 的 MinGW 版本库就是使用 MinGW-w64 项目里面的工具集生成的。</p>
<h4 id="MSYS（Minimal-SYStem）"><a href="#MSYS（Minimal-SYStem）" class="headerlink" title="MSYS（Minimal SYStem）"></a>MSYS（Minimal SYStem）</h4><p>另外提一下，由于 MinGW 本身主要就是编译链接等工具和头文件、库文件，并不包含系统管理、文件操作之类的 Shell 环境， 这对希望用类 Unix 命令的开发者来说还是不够用的。 所以 MinGW 官方又推出了 MSYS（Minimal SYStem），相当于是一个部署在 Windows 系统里面的小型 Unix 系统环境， 移植了很多 Unix&#x2F;Linux 命令行工具和配置文件等等，是对 MinGW 的扩展。         MSYS 对于熟悉 Unix&#x2F;Linux 系统环境或者要尝试学习 Unix&#x2F;Linux 系统的人都是一种便利。MSYS 和 MinGW 的安装升级都是通过其官方的 mingw-get 工具实现，二者是统一下载安装管理的。         对于 MinGW-w64 项目，它对应的小型系统环境叫 MSYS2（Minimal SYStem 2），MSYS2 是 MSYS 的衍生版，不仅支持 64 位系统和 32 位系统，还有自己的独特的软件包管理工具，它从 Arch Linux 系统里移植了 pacman 软件管理工具，所以装了 MSYS2 之后，可以直接通过 pacman 来下载安装软件，而且可以自动解决依赖关系、方便系统升级等。装了 MSYS2 之后，不需要自己去下载 MinGW-w64，可以直接用 pacman 命令安装编译链接工具和 git 工具等。         MinGW 项目主页（含 MSYS）： <a target="_blank" rel="noopener" href="http://www.mingw.org/">http://www.mingw.org/</a></p>
<p>MinGW-w64 项目主页： <a target="_blank" rel="noopener" href="https://sourceforge.net/projects/mingw-w64/">https://sourceforge.net/projects/mingw-w64/</a></p>
<p>MSYS2 项目主页： <a target="_blank" rel="noopener" href="https://sourceforge.net/projects/msys2/">https://sourceforge.net/projects/msys2/</a></p>
<h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>CMake（Cross platform Make）是一个开源的跨平台自动化构建工具， 可以跨平台地生成各式各样的 makefile 或者 project 文件， 支持利用各种编译工具生成可执行程序或链接库。         CMake 自己不编译程序， 它相当于用自己的构建脚本 CMakeLists.txt，叫各种编译工具集去生成可执行程序或链接库。         一般用于编译程序的 makefile 文件比较复杂，自己去编写比较麻烦， 而利用 CMake ，就可以编写相对简单的 CMakeLists.txt ，由 CMake 根据 CMakeLists.txt 自动生成 makefile，然后就可以用 make 生成可执行程序或链接库。         本教程里面是使用 Qt 官方的 qmake 工具生成 makefile 文件，没有用 CMake。这里之所以提 CMake，是因为整个 KDE 桌面环境的茫茫多程序都是用 CMake 脚本构建的，另外跨平台的程序&#x2F;库如 Boost C++ Libraries、<a target="_blank" rel="noopener" href="http://c.biancheng.net/opencv/">OpenCV</a>、LLVM、Clang 等也都是用 CMake 脚本构建的。以后如果接触到这些东西，是需要了解 CMake 的。         CMake 项目主页：<a target="_blank" rel="noopener" href="https://cmake.org/">https://cmake.org/</a></p>
<p>KDE 项目主页：<a target="_blank" rel="noopener" href="https://www.kde.org/">https://www.kde.org/</a></p>
<h2 id="Qt-工具集"><a href="#Qt-工具集" class="headerlink" title="Qt 工具集"></a>Qt 工具集</h2><p>Qt 官方的开发环境安装包里有自己专门的开发工具，之前用过 qmake 命令。qmake 是 Qt 开发最核心的工具，既可以生成 Qt 项目文件 .pro ，也可以自动生成项目的 Makefile 文件。         这里将常用的 Qt 开发工具列表如下：</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>qmake</td>
<td>核心的项目构建工具，可以生成跨平台的 .pro 项目文件，并能依据不同操作系统和编译工具生成相应的 Makefile，用于构建可执行程序或链接库。</td>
</tr>
<tr>
<td>uic</td>
<td>User Interface Compiler，用户界面编译器，Qt 使用 XML 语法格式的 .ui 文件定义用户界面，uic 根据 .ui 文件生成用于创建用户界面的 C++ 代码头文件，比如 ui_*****.h 。</td>
</tr>
<tr>
<td>moc</td>
<td>Meta-Object Compiler，元对象编译器，moc 处理 C++ 头文件的类定义里面的 Q_OBJECT 宏，它会生成源代码文件，比如 moc_*****.cpp ，其中包含相应类的元对象代码，元对象代码主要用于实现 Qt 信号&#x2F;槽机制、运行时类型定义、动态属性系统。</td>
</tr>
<tr>
<td>rcc</td>
<td>Resource Compiler，资源文件编译器，负责在项目构建过程中编译 .qrc 资源文件，将资源嵌入到最终的 Qt 程序里。</td>
</tr>
<tr>
<td>qtcreator</td>
<td>集成开发环境，包含项目生成管理、代码编辑、图形界面可视化编辑、 编译生成、程序调试、上下文帮助、版本控制系统集成等众多功能， 还支持手机和嵌入式设备的程序生成部署。</td>
</tr>
<tr>
<td>assistant</td>
<td>Qt 助手，帮助文档浏览查询工具，Qt 库所有模块和开发工具的帮助文档、示例代码等都可以检索到，是 Qt 开发必备神器，也可用于自学 Qt。</td>
</tr>
<tr>
<td>designer</td>
<td>Qt 设计师，专门用于可视化编辑图形用户界面（所见即所得），生成 .ui 文件用于 Qt 项目。</td>
</tr>
<tr>
<td>linguist</td>
<td>Qt 语言家，代码里用 tr() 宏包裹的就是可翻译的字符串，开发人员可用 lupdate 命令生成项目的待翻译字符串文件 .ts，用 linguist 翻译多国语言 .ts ，翻译完成后用 lrelease 命令生成 .qm 文件，然后就可用于多国语言界面显示。</td>
</tr>
<tr>
<td>qmlscene</td>
<td>在 Qt 4.x 里是用 qmlviewer 进行 QML 程序的原型设计和测试，Qt 5 用 qmlscene 取代了旧的 qmlviewer。新的 qmlscene 另外还支持 Qt 5 中的新特性 scenegraph 。</td>
</tr>
</tbody></table>
<ol start="5">
<li>Qt编程涉及的术语和名词</li>
</ol>
<p>&lt; <a target="_blank" rel="noopener" href="http://c.biancheng.net/view/3868.html">Qt用到的开发工具</a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1804.html">Qt Creator的初步使用</a></p>
<p>本节我们来介绍一下使用 <a target="_blank" rel="noopener" href="http://c.biancheng.net/qt/">Qt</a>编程过程中常用的术语和名字，它们不一定专属于 Qt，在其它的 C&#x2F;<a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a>开发过程中也会使用到。</p>
<h2 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h2><p>Project 的中文翻译是“项目”或者“工程”，这里的项目是指为实现某个相对独立功能的程序代码合集，这些代码不单单是放在一块，而是有相互之间的关联性，并且有专门负责管理该项目的项目文件，比如：</p>
<ul>
<li><p>Qt 使用 .pro 文件管理项目；</p>
</li>
<li><p>VC++ 则使用 .vcproj 作为项目文件。</p>
</li>
</ul>
<p>集成开发环境通常都是依据项目文件（.pro&#x2F;.vcproj）管理和构建项目。</p>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>即生成脚本，虽然可以直接调用编译器如 g++ 编译程序，但是如果项目里的代码文件变多了，哪些代码文件更新了需要重新编译，哪些代码没有改不需要重新编译等等，靠程序员自己记忆去处理是比较麻烦的事，还有哪些代码需要预处理或是链接哪些库文件， 这些都是繁杂的过程。为了规范程序的编译生成过程，产生了规范化的生成脚本，就是 Makefile，生成器 make 可以依据规范的 Makefile 自动生成目标程序或库文件。 简单的说，就是定义好 Makefile ，让程序员只需要去关注如何编写代码，而生成程序过程中的脏活累活都交给 make 程序。 现在 Makefile 通常都有工具自动生成，如 qmake 工具， 这样就大量减轻了程序员的负担。</p>
<h2 id="Debug-和-Release"><a href="#Debug-和-Release" class="headerlink" title="Debug 和 Release"></a>Debug 和 Release</h2><p>Debug 即调试，Release 即发行。代码编写之后，生成的目标程序或库文件通常不会绝对正确，或多或少有些毛病（bug）， 因此需要进行纠错调试（Debug）。调试过程中需要源代码和二进制目标程序之间一一对应的关系， 这样才能定位到错误代码，所以 Debug 版本的程序是臃肿而不进行优化的。 与之相对的是 Release 发行版，在纠正了发觉到的错误后，需要发布程序用于实际用途，实际应用时强调运行效率高，减少冗余代码，因此会对二进制程序进行大量优化，提升性能。这样发布的二进制目标程序就是 Release 版。 Debug 版本和 Release 版本使用的库文件不一样：</p>
<ul>
<li><p>Debug 版本程序通常链接的也是 Debug 版本的库文件，比如 libQt5Guid.a&#x2F;Qt5Guid.dll，库文件的简短名（不含扩展名）都是以 d 结尾的，Debug 库通常都比较大 。</p>
</li>
<li><p>Release 版本程序链接的通常就是 Release 版本的库文件，Release 版本库文件名字比 Debug 版本库文件少一个字母 d ，如 libQt5Gui.a&#x2F;Qt5Gui.dll，而且 Release 版本库一般都比 Debug 版本小很多，运行效率也高很多。</p>
</li>
</ul>
<h2 id="C-11-标准"><a href="#C-11-标准" class="headerlink" title="C++11 标准"></a>C++11 标准</h2><p>时代在变化，C++ 标准也在前进。C++ 正式公布标准有 C++98、C++03、C++11。最新的 C++11 标准是2011年8月12日公布的，在公布之前该标准原名为 C++0x 。这是一次较大的修订和扩充，建议读者专门学一下。 Qt 从 4.8 版本就开始用 C++11 新特性了。编译器里面开始支持 C++11 的版本是 MSVC 2010、<a target="_blank" rel="noopener" href="http://c.biancheng.net/gcc/">GCC</a>4.5、Clang 3.1，这之后版本的编译器都在逐步完善对 C++11 的支持，现在新版本编译器对新标准的支持都比较全面了。 Qt 官方在编译 Qt5 库的时候都是开启 C++11 特性的，如果我们要在自己项目代码启用新标准，需要在 .pro 文件里面添加一行：</p>
<p>CONFIG +&#x3D; c++11</p>
<p>如果是 Qt4 版本则是添加：</p>
<p>gcc:CXXFLAGS +&#x3D; -std&#x3D;c++0x</p>
<p>MSVC 编译器默认开启 C++11 特性，GCC（g++命令）则需要自己添加选项 -std&#x3D;c++0x ，上面 CXXFLAGS 就是为 GCC 编译器（g++命令）添加 -std&#x3D;c++0x 选项。</p>
<h2 id="Dynamic-Link-和-Static-Link"><a href="#Dynamic-Link-和-Static-Link" class="headerlink" title="Dynamic Link 和 Static Link"></a>Dynamic Link 和 Static Link</h2><p>Dynamic Link 即动态链接，Static Link 即静态链接。</p>
<h4 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h4><p>目标程序通常都不是独立个体，生成程序时都需要链接其他的库，要用到其他库的代码。对于多个程序同时运行而言，内存中就可能有同一个库的多个副本，占用了太多内存而干的活差不多。 为了优化内存运用效率，引入了动态链接库（Dynamic Link Library），或叫共享库（Shared Object）。使用动态链接库时，内存中只需要一份该库文件，其他程序要使用该库文件时，只要链接过来就行了。由于动态库文件外置，链接到动态库的目标程序相对比较小，因为剥离了大量库代码，而只需要一些链接指针。 使用动态库，也意味着程序需要链接到如 *.dll 或 *.so 文件，得提前装好动态库文件，然后目标程序才能正常运行。</p>
<h4 id="静态链接库"><a href="#静态链接库" class="headerlink" title="静态链接库"></a>静态链接库</h4><p>静态库就是将链接库的代码和自己编写的代码都编译链接到一块，链接到静态库的程序通常比较大，但好处是运行时依赖的库文件很少，因为目标程序自己内部集成了很多库代码。</p>
<h4 id="库文件后缀"><a href="#库文件后缀" class="headerlink" title="库文件后缀"></a>库文件后缀</h4><p>Linux&#x2F;Unix 系统里静态库扩展名一般是 .a，动态库扩展名一般是 .so 。Windows 系统里 VC 编译器用的静态库扩展名一般是 .lib，动态库扩展名一般是 .dll 。 MinGW 比较特殊，是将 GNU 工具集和链接库从 Linux&#x2F;Unix 系统移植到 Windows 里， 有意思的情况就出现了，MinGW 使用的静态库扩展名为 .a ，而其动态库扩展名则为 .dll， .a 仅在生成目标程序过程中使用，.dll 则是在目标程序运行时使用。</p>
<h2 id="Explicit-Linking-和-Implicit-Linking"><a href="#Explicit-Linking-和-Implicit-Linking" class="headerlink" title="Explicit Linking 和 Implicit Linking"></a>Explicit Linking 和 Implicit Linking</h2><p>Explicit Linking 即显式链接，Implicit Linking 即隐式链接，这两种都是动态链接库的使用方式。 动态链接库通常都有其导出函数列表， 告知其他可执行程序可以使用它的哪些函数。可执行程序使用这些导出函数有两种方式：一是在运行时使用主动加载动态库的函数，Linux 里比如用 dlopen 函数打开并加载动态库，Windows 里一般用 LoadLibrary 打开并加载动态库，只有当程序代码执行到这些函数时，其参数里的动态库才会被加载，这就是显式链接。显式链接方式是在运行时加载动态库，其程序启动时并不检查这些动态库是否存在。 隐式链接是最为常见的，所有的编译环境默认都是采用隐式链接的方式使用动态库。隐式链接会在链接生成可执行程序时就确立依赖关系，在该程序启动时，操作系统自动会检查它依赖的动态库，并一一加载到该程序的内存空间，程序员就不需要操心什么时候加载动态库了。比如 VC 编译环境，链接时使用动态库对应的 .lib 文件（包含动态库的导出函数声明，但没有实际功能代码），在 .exe 程序运行前系统会检查依赖的 .dll，如果找不到某个动态库就会出现类似下图对话框：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/8106cd02-3b24-487b-9e1c-78c1c7a4bc65.gif" alt="image"></p>
<p>MinGW 是将动态库的导出函数声明放在了 .a 文件里，程序运行依赖的动态库也是 .dll 。 请注意，VC 链接器使用的 .lib 文件分两类，一种是完整的静态库，体积比较大，另一种是动态库的导出声明，体积比较小。MinGW 链接器使用的 .a 文件也是类似的，Qt 官方库都是按照动态库发布的，静态库只有自己编译才会有。</p>
<ol start="6">
<li>Qt Creator的初步使用</li>
</ol>
<p>启动 <a target="_blank" rel="noopener" href="http://c.biancheng.net/qt/">Qt</a>Creator，出现如图 1 所示的主窗口：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/4044f0d5-dff3-48ef-8c13-1e76e2570fb6.gif" alt="image">图 1 Qt Creator主窗口</p>
<p>Qt Creator 的界面很简洁。上方是主菜单栏，左侧是主工具栏，窗口的中间部分是工作区。根据设计内容不同，工作区会显示不同的内容。 图 1 是在左侧主工具栏单击“Welcome（欢迎）”按钮后显示实例的界面。这时工作区的左侧有 “Projects”、“Examples（示例）”、“Tutorials（教程）”、“Get Started Now”几个按钮，单击后会在主工作区显示相应的内容：</p>
<ul>
<li><p>单击“Projects”按钮后，工作区显示新建项目按钮和最近打开项目的列表。</p>
</li>
<li><p>单击“Examples（示例）”按钮后，工作区显示 Qt 自带的大量实例，选择某个实例就可以在 Qt Creator 中打开该项目源程序。</p>
</li>
<li><p>单击“Tutorials（教程）”按钮后，工作区显示各种视频教程，查看视频教程需要联网并使用浏览器打开。</p>
</li>
<li><p>单击“Get Started Now”按钮，工作区显示“Qt Creator Manual”帮助主题内容。</p>
</li>
</ul>
<p>主窗口左侧是主工具栏，主工具栏提供了项目文件编辑、窗体设计、程序调试、项目设置等各种功能按钮。</p>
<h2 id="Qt-Creator-的设置"><a href="#Qt-Creator-的设置" class="headerlink" title="Qt Creator 的设置"></a>Qt Creator 的设置</h2><p>对 Qt Creator 可以进行一些设置，如刚安装好的 Qt Creator 界面语言可能是中文，也可以选择将 Qt Creator 的界面语言设置为英文。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/284a1bf7-28ee-4c63-aba1-0e270dba4874.gif" alt="image">图 2 Options 的构建和运行设置页面</p>
<p>单击 Qt Creator 菜单栏的 Tools→Options 菜单项会打开选项设置对话框（如图 2 所示）。对话框的左侧是可设置的内容分组，单击后右侧出现具体的设置界面。常用的设置包括以下几点：</p>
<ol>
<li><p>Environment（环境） 设置：在 Interface 页面可以设置语言和主题，本教程全部以中文界面的 Qt Creator 进行讲解，所以语言选择为 Chinese（China）；为了使界面抓图更清晰，设置主题为 Flat Light。更改语言和主题后需要重新启动 Qt Creator 才会生效。</p>
</li>
<li><p>Text Editor（文本编辑器）设置：在此界面可以设置文本编辑器的字体，设置各种类型文字的字体颜色，如关键字、数字、字符串、注释等字体颜色，也可以选择不同的配色主题。编辑器缺省字体的大小为 9，可以修改得大一些。</p>
</li>
<li><p>Build &amp; Run（构建和运行）设置：图 2 显示的是 Build &amp; Run 的设置界面，它有以下几个页面。</p>
<ul>
<li><p>Kits（构建套件）页面显示 Qt Creator 可用的编译工具。</p>
</li>
<li><p>Qt Versions 页面显示安装的 Qt 版本。</p>
</li>
<li><p>Compliers（编译器）页面显示系统里可用的 C 和 <a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a>编译器，由于安装了 MinGW 和 Visual Studio 2015，Qt Creator 会自动检测出这些编译器。</p>
</li>
<li><p>Debuggers 页面显示 Qt Creator 自动检测到的调试器，有 GNU gdb for MinGW 调试器和 Windows 的 CDB 调试器。</p>
</li>
</ul>
</li>
<li><p>编写第一个Qt程序</p>
</li>
</ol>
<p>学习一种编程语言或编程环境，通常会先编写一个“Hello World”程序。我们也用 <a target="_blank" rel="noopener" href="http://c.biancheng.net/qt/">Qt</a>Creator 编写一个“Hello World”程序，以初步了解 Qt Creator 设计应用程序的基本过程，对使用 Qt Creator 编写 Qt <a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a>应用程序建立初步的了解。</p>
<h2 id="新建一个项目"><a href="#新建一个项目" class="headerlink" title="新建一个项目"></a>新建一个项目</h2><p>单击 Qt Creator 的菜单项文件-&gt;新建文件或项目，出现如图 1 所示的对话框。在这个对话框里选择需要创建的项目或文件的模板。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/66c676c4-5847-4ce1-9c35-2a8da18b96c4.gif" alt="image">图 1 新建文件或项目对话框</p>
<p>Qt Creator 可以创建多种项目，在最左侧的列表框中单击“Application”，中间的列表框中列出了可以创建的应用程序的模板，各类应用程序如下：</p>
<ul>
<li><p>Qt Widgets Application，支持桌面平台的有图形用户界面（Graphic User Interface，GUI） 界面的应用程序。GUI 的设计完全基于 C++ 语言，采用 Qt 提供的一套 C++ 类库。</p>
</li>
<li><p>Qt Console Application，控制台应用程序，无 GUI 界面，一般用于学习 C&#x2F;C++ 语言，只需要简单的输入输出操作时可创建此类项目。</p>
</li>
<li><p>Qt Quick Application，创建可部署的 Qt Quick 2 应用程序。Qt Quick 是 Qt 支持的一套 GUI 开发架构，其界面设计采用 QML 语言，程序架构采用 C++ 语言。利用 Qt Quick 可以设计非常炫的用户界面，一般用于移动设备或嵌入式设备上无边框的应用程序的设计。</p>
</li>
<li><p>Qt Quick Controls 2 Application，创建基于 Qt Quick Controls 2 组件的可部署的 Qt Quick 2 应用程序。Qt Quick Controls 2 组件只有 Qt 5.7 及以后版本才有。</p>
</li>
<li><p>Qt Canvas 3D Application，创建 Qt Canvas 3D QML 项目，也是基于 QML 语言的界面设计，支持 3D 画布。</p>
</li>
</ul>
<p>在图 1 显示的对话框中选择项目类型为 Qt Widgets Application 后，单击“Choose…”按钮，出现如图 2 所示的新建项目向导：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/6d9a532e-09ef-4461-ab16-fabd6c6a1b09.gif" alt="image">图 2 新建项目向导第 1 步：项目名称和项目存储位置设置</p>
<p>在图 2 中，选择一个目录，如“E:\QtDemo”，再设置项目名称为 Demo， 这样新建项目后，会在“E:\QtDemo”目录下新建一个目录，项目所有文件保 存在目录“E:\QtDemo\Demo\”下。 在图 2 中设置好项目名称和保存路径后，单击“Next”按钮，出现如图 3 所示的选择编译工具的界面：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/41fd2068-80ce-4596-b6d6-4e6077e48c83.gif" alt="image">图 3 新建项目向导第 2 步：选择编译工具</p>
<p>可以将这几个编译工具都选中，在编译项目时再选择一个作为当前使用的编译工具，这样可以编译生成不同版本的可执行程序。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/b33a5462-3fe8-40df-9876-a0bcc80625c6.gif" alt="image">图 4 新建项目想到第 3 步：选择界面基类</p>
<p>在图 3 显示的界面中单击“Next”按钮，出现如图 4 所示的界面。在此界面中选择需要创建界面的基类（base class）。有 3 种基类可以选择：</p>
<ol>
<li><p>QMainWindow 是主窗口类，主窗口具有主菜单栏、工具栏和状态栏，类似于一般的应用程序的主窗口；</p>
</li>
<li><p>QWidget 是所有具有可视界面类的基类，选择 QWidget 创建的界面对各种界面组件都可以 支持；</p>
</li>
<li><p>QDialog 是对话框类，可建立一个基于对话框的界面；</p>
</li>
</ol>
<p>在此选择 QMainWindow 作为基类，自动更改的各个文件名不用手动去修改。勾选“创建界面”复选框。这个选项如果勾选，就会由 Qt Creator 创建用户界面文件，否则，需要自己编程手工创建界面。初始学习，为了了解 Qt Creator 的设计功能，勾选此选项。 然后单击“Next”按钮，出现一个页面，总结了需要创建的文件和文件保存目录，单击“完成”按钮就可以完成项目的创建。</p>
<h2 id="项目的文件组成和管理"><a href="#项目的文件组成和管理" class="headerlink" title="项目的文件组成和管理"></a>项目的文件组成和管理</h2><p>完成了以上新建项目的步骤后，在 Qt Creator 的左侧工具栏中单击“编辑”按钮，可显示如图 5 所示的窗口。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/686eba8f-4737-4b95-b120-083eadce8bd6.gif" alt="image">图 5 项目管理与文件编辑界面</p>
<p>窗口左侧有上下两个子窗口，上方的目录树显示了项目内文件的组织结构，显示当 前项目为 Demo。项目的名称构成目录树的一个根节点，Qt Creator 可以打开多个项目，但是只有一个活动项目，活动项目的项目名称节点用粗体字体表示。 在项目名称节点下面，分组管理着项目内的各种源文件，几个文件及分组分别为以下几项：</p>
<ul>
<li><p>Demo.pro 是项目管理文件，包括一些对项目的设置项。</p>
</li>
<li><p>Headers 分组，该节点下是项目内的所有头文件（.h），图 5 中所示项目有一个头文件 mainwindow.h，是主窗口类的头文件。</p>
</li>
<li><p>Sources 分组：该节点下是项目内的所有 C++源文件（.cpp），图 5 中所示项目有两个 C++ 源文件，mainwindow.cpp 是主窗口类的实现文件，与 mainwindow.h 文件对应。main.cpp 是主函数文件，也是应用程序的入口。</p>
</li>
<li><p>Forms 分组：该节点下是项目内的所有界面文件（.ui）。图 5 中所示项目有一个界面文件mainwindow.ui，是主窗口的界面文件。界面文件是文本文件，使用 XML 语言描述界面的组成。</p>
</li>
</ul>
<p>左侧上下两个子窗口的显示内容可以通过其上方的一个下拉列表框进行选择，可以选择的显示内容包括项目、打开文档、书签、文件系统、类视图、大纲等。在图 5 中，上方的子窗口显示了项目的文件目录树，下方显示打开的文件列表。可以在下方选择显示类视图，这样下方则显示项目内所有的类的结构，便于程序浏览和快速切换到需要的代码位置。 双击文件目录树中的文件mainwindow.ui，出现如图 6 所示的窗体设计界面：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/18aa8643-fd4e-4934-82c9-b55f2f1ddbe1.gif" alt="image">图 6 集成在 Qt Creator 中UI设计器</p>
<p>这个界面实际上是 Qt Creator 中集成的 Qt Designer。窗口左侧是分组的组件面板，中间是设计的窗体。在组件面板的 Display Widgets 分组里，将一个Label组件拖放到设计的窗体上面。双击刚刚放置的 Label 组件，可以编辑其文字内容，将文字内容更改为“Hello, World!”。还可以在窗口右下方的属性编辑器里编辑标签的 Font 属性，Point Size（点大小）更改为 12，勾选粗体。</p>
<h2 id="项目的编译、调试与运行"><a href="#项目的编译、调试与运行" class="headerlink" title="项目的编译、调试与运行"></a>项目的编译、调试与运行</h2><p>单击主窗口左侧工具栏上的“项目”按钮，出现如图 7 所示的项目编译设置界面。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/bf563ae6-1b67-4927-abb9-f1d555278878.gif" alt="image">图 7 项目编译器选择和设置界面</p>
<p>界面左侧一栏的“Build &amp; Run”下面显示了本项目中可用的编译器工具，要使用哪一个编译器用于项目编译，单击其名称即可，选择的编译器名称会用粗体字表示。这里选择使用 MinGW 32bit 编译器。 每个编译器又有 Build 和 Run 两个设置界面。在 Build 设置界面上，有一个“Shadow build” 复选框。如果勾选此项，编译后将在项目的同级目录下建立一个编译后的文件目录，目录名称包含编译器信息，这种方式一般用于使用不同编译器创建不同版本的可执行文件。如果不勾选此项，编译后将在项目的目录下建立“Debug”和“Release”子目录用于存放编译后的文件。 在设计完 mainwindow.ui 文件，并设置好编译工具之后，就可以对项目进行编译、调试或运行。主窗口左侧工具栏下方有 4 个按钮，其功能见表 1。</p>
<table>
<thead>
<tr>
<th>图标</th>
<th>作用</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/33357e0a-b44f-4623-8db1-e2429c88067a.gif" alt="image"></td>
<td>弹出菜单选择编译工具和编译模式，如 Debug或 Release模式</td>
<td></td>
</tr>
<tr>
<td><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/488ad3ff-0509-489d-ba4c-02b2e0606f8f.gif" alt="image"></td>
<td>直接运行程序，如果修改后未编译，会先进行编译。即使在程序中设置了断点，此方式运行的程序也无法调试。</td>
<td>Ctrl+R</td>
</tr>
<tr>
<td><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/98f9ef25-2d18-4292-b376-624de70f404d.gif" alt="image"></td>
<td>项目需要以Debug模式编译，点此按钮开始调试运行，可以在程序中设置断点。若是以 Release模式编译，点此按钮也无法进行调试。</td>
<td>F5</td>
</tr>
<tr>
<td><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/fa4430d5-2d0f-48e9-885f-0fc39d65ecc9.gif" alt="image"></td>
<td>编译当前项目</td>
<td>Ctrl+B</td>
</tr>
</tbody></table>
<p>首先对项目进行编译，没有错误后，再运行程序。程序运行的界面如图 8 所示。这就是一个标准的桌面应用程序，我们采用可视化的方式设计了一个窗口，并在上面显示了字符串“Hello， World！”。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/27854f2a-ee7a-46e2-a980-d260a1415f59.gif" alt="image">图 8 实例程序 Demo 运行时界面</p>
<p>在 Qt Creator 中也可以对程序设置断点进行调试，但是必须以 Debug 模式编译，并以“Start Debugging”（快捷键 F5）方式运行程序。</p>
<p>程序调试的方法与一般 IDE 工具类似，不再详述。注意，要在 Qt Creator 里调试 MSVC2015 编译的程序，必须安装 Windows 软件开发工具包 SDK。       </p>
<ol start="8">
<li>Qt项目管理文件（.pro）及其作用详解</li>
</ol>
<p>在 <a target="_blank" rel="noopener" href="http://c.biancheng.net/qt/">Qt</a>Creator 中新建一个 Widget Application 项目 samp2_1，在选择窗口基类的页面选择 QWidget 作为窗体基类，并选中“Generate form”复选框。创建后的项目文件目录树如图 1 所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/5daeacb7-8528-4d7c-b081-fcdfa8fd6737.gif" alt="image"></p>
<p>图 1 项目文件的目录树</p>
<p>这个项目包含以下一些文件：</p>
<ul>
<li><p>项目管理文件 samp2_1.pro，存储项目设置的文件。</p>
</li>
<li><p>主程序入口文件 main.cpp，实现 main()函数的程序文件。</p>
</li>
<li><p>窗体界面文件 widget.ui，一个 XML 格式存储的窗体上的元件及 其布局的文件。</p>
</li>
<li><p>widget.h 是所设计的窗体类的头文件，widget.cpp 是 widget.h 里 定义类的实现文件。<a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a>中，任何窗体或界面组件都是用类封装的，一个类一般有一个头文件（.h 文件）和一个源程序文件（.cpp 文件）。</p>
</li>
</ul>
<p>本节先来介绍一下项目管理文件（.pro文件）。 后缀为“.pro”的文件是项目的管理文件，文件名就是项目的名称，如本项目中的 samp2_1.pro。 下面是 samp2_1.pro 文件的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QT       += core gui</span><br><span class="line">greaterThan(QT_MAJOR_VERSION, 4): QT += widgets</span><br><span class="line">TARGET = samp2_1</span><br><span class="line">TEMPLATE = app</span><br><span class="line">SOURCES += \</span><br><span class="line">        main.cpp \</span><br><span class="line">        widget.cpp</span><br><span class="line">HEADERS += \</span><br><span class="line">        widget.h</span><br><span class="line">FORMS += \</span><br><span class="line">        widget.ui</span><br></pre></td></tr></table></figure>

<p>项目管理文件用于记录项目的一些设置，以及项目包含文件的组织管理。 “Qt +&#x3D; core gui”表示项目中加入 core gui 模块。core gui 是 Qt 用于 GUI 设计的类库模块，如果创建的是控制台（Console）应用程序，就不需要添加 core gui。 Qt 类库以模块的形式组织各种功能的类，根据项目涉及的功能需求，在项目中添加适当的类库模块支持。例如，如果项目中使用到了涉及数据库操作的类就需要用到 sql 模块，在 pro 文件中需要增加如下一行：</p>
<p>Qt +&#x3D;sql</p>
<p>samp2_1.pro 中的第 2 行是：</p>
<p>greaterThan(Qt_MAJOR_VERSION, 4): Qt +&#x3D; widgets</p>
<p>这是个条件执行语句，表示当 Qt 主版本大于 4 时，才加入 widgets 模块。 “TARGET &#x3D; samp2_1”表示生成的目标可执行文件的名称，即编译后生成的可执行文件是 samp2_1.exe。 “TEMPLATE &#x3D; app”表示项目使用的模板是 app，是一般的应用程序。 后面的 SOURCES、HEADERS、FORMS 记录了项目中包含的源程序文件、头文件和窗体文件（.ui 文件）的名称。这些文件列表是 Qt Creator 自动添加到项目管理文件里面的，用户不需要手动修改。当添加一个文件到项目，或从项目里删除一个文件时，项目管理文件里的条目会自动修改。</p>
<ol start="9">
<li>Qt项目界面文件（.ui）及其作用（超详细）</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/qt/">Qt</a>项目中，后缀为“.ui”的文件是可视化设计的窗体的定义文件，如 widget.ui。双击项目文件目录树中的文件 widget.ui，会打开一个集成在 Qt Creator 中的 Qt Designer 对窗体进行可视化设计，如图 1 所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/48cf436f-7c10-45cb-acfb-b3c1f147aee2.gif" alt="image">图 1 集成在 Qt Creator中的 UI 设计器</p>
<p>本教程后面将称这个集成在 Qt Creator 中的 Qt Designer 为“UI 设计器”，以便与独立运行的 Qt Designer 区别开来。 图 1 中的 UI 设计器有以下一些功能区域：</p>
<ul>
<li><p>组件面板：窗口左侧是界面设计组件面板，分为多个组，如Layouts、Buttons、Display Widgets等，界面设计的常见组件都可以在组件面板里找到。</p>
</li>
<li><p>中间主要区域是待设计的窗体。如果要将某个组件放置到窗体上时，从组件面板上拖放一个组件到窗体上即可。例如，先放一个 Label 和一个 Push Button 到窗体上。</p>
</li>
<li><p>Signals 和 Slots 编辑器与 Action 编辑器是位于待设计窗体下方的两个编辑器。Signals 和Slots 编辑器用于可视化地进行信号与槽的关联，Action 编辑器用于可视化设计 Action。</p>
</li>
<li><p>布局和界面设计工具栏：窗口上方的一个工具栏，工具栏上的按钮主要实现布局和界面设计。</p>
</li>
<li><p>对象浏览器（Object Inspector）：窗口右上方是 Object Inspector，用树状视图显示窗体上各组件之间的布局包含关系，视图有两列，显示每个组件的对象名称（ObjectName）和类名称。</p>
</li>
<li><p>属性编辑器（Property Editor）：窗口右下方是属性编辑器，是界面设计时最常用到的编辑器。属性编辑器显示某个选中的组件或窗体的各种属性及其取值，可以在属性编辑器里修改这些属性的值。</p>
</li>
</ul>
<p>图 2 显示的是选中窗体上放置的标签组件后属性编辑器的内容。最上方显示的文字“LabDemo: QLabel”表示这个组件是一个 QLabel 类的组件，objectName 是LabDemo。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/7683c037-9ad3-4917-96d7-c1ee2e74001a.gif" alt="image">                                                                图 2 界面组件的属性编辑器</p>
<p>属性编辑器的内容分为两列，分别为属性的名称和属性的值。属性又分为多个组，实际上表示了类的继承关系，如在图 2 中，可以看出 QLabel 的继承关系是QObject→QWidget→QFrame→QLabel。 objectName 表示组件的对象名称，界面上的每个组件都需要一个唯一的对象名称，以便被引用。界面上的组件的命名应该遵循一定的法则，具体使用什么样的命名法则根据个人习惯而定，主要目的是便于区分和记忆，也要便于与普通变量相区分。 设置其他属性的值只需在属性编辑器里操作即可，如设置 LabDemo 的 text 属性为“Hello,World”，只需像图 2 那样修改 text 属性的值即可。</p>
<p>提示，标准 <a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a>语言里并没有 property 关键字，property 是 Qt 对标准 C++ 的扩展，使得在 Qt Designer 里就可以可视化设置类的数据。</p>
<p>在图 1 显示的设计窗体上，放置一个 Label 和一个 Push Button 组件，它们的主要属性设置见表 3。</p>
<table>
<thead>
<tr>
<th>ObjectName</th>
<th>类名称</th>
<th>属性设置</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>LabDemo</td>
<td>QLabel</td>
<td>Text&#x3D;”Hello, World” Font.PointSize&#x3D;20 Font.bold&#x3D;true</td>
<td>设置标签显示文字和字体</td>
</tr>
<tr>
<td>btnClose</td>
<td>QPushButton</td>
<td>Text&#x3D;”Close”</td>
<td>设置按钮的文字</td>
</tr>
</tbody></table>
<p>编辑完属性之后，再为 btnClose 按钮增加一个功能，就是单击此按钮时，关闭窗口，退出程序。使用 Signals 和 Slots 编辑器完成这个功能，如图 4 所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/fec3582a-cc3d-42a8-87c0-64d342bd36a7.gif" alt="image">                                        图 4 信号与槽编辑器中设计信号与槽的关联</p>
<p>在信号与槽编辑器的工具栏上单击“Add”按钮，在出现的条目中，Sender 选择 btnClose，Signal 选择 clicked()，Receiver 选择窗体 Widget，Slot 选择 close()。这样设置表示当按钮 btnClose 被单击时，就执行 Widget 的 close() 函数，实现关闭窗口的功能。 然后对项目进行编译和运行，可以出现如图 5 所示的窗口，单击“Close”按钮可以关闭程序。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/6b5f38b3-d520-4c5f-92b8-e5736ce549d9.gif" alt="image"></p>
<p>图 5 具有 Close 按钮的“Hello World”程序</p>
<p>标签的文字内容和字体被修改了，窗口标题也显示为所设置的标题，而我们并没有编写一行程序语句，Qt 是怎么实现这些功能的呢？ 为了搞清楚窗体类的定义，以及界面功能的实现原理，这里将项目进行编译。编译后在项目目录下会自动生成一个文件 ui_widget.h，这样对于一个窗体，就有 4 个文件了，各文件的功能说明见表 6。</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>widget.h</td>
<td>定义窗体类的头文件，定义了类Widget</td>
</tr>
<tr>
<td>widget.cpp</td>
<td>Widget 类的功能实现源程序文件</td>
</tr>
<tr>
<td>widget.ui</td>
<td>窗体界面文件，由UI设计器自动生成，存储了窗体上各个组件的属性设置和布局</td>
</tr>
<tr>
<td>ui_widget.h</td>
<td>编译后，根据窗体上的组件及其属性、信号与槽的关联等自动生成的一个类的定义文件，类的名称是Ui_Widget</td>
</tr>
</tbody></table>
<p>下面分别分析各个文件的内容及其功能，以及它们是如何联系在一起工作，实现界面的创建与显示的。</p>
<h2 id="widget-h-文件"><a href="#widget-h-文件" class="headerlink" title="widget.h 文件"></a>widget.h 文件</h2><p>widget.h 文件是窗体类的头文件。在创建项目时，选择窗体基类是 QWidget，在 widget.h 中定义了一个继承自 QWidget 的类 Widget。 下面是 widget.h 文件的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#ifndef WIDGET_H</span><br><span class="line">#define WIDGET_H</span><br><span class="line"></span><br><span class="line">#include &lt;QWidget&gt;</span><br><span class="line"></span><br><span class="line">namespace Ui &#123;</span><br><span class="line">class Widget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Widget : public QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit Widget(QWidget *parent = 0);</span><br><span class="line">    ~Widget();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // WIDGET_H</span><br></pre></td></tr></table></figure>

<p>widget.h 文件有几个重要的部分。</p>
<h4 id="namespace-声明"><a href="#namespace-声明" class="headerlink" title="namespace 声明"></a>namespace 声明</h4><p>代码中有如下的一个 namespace 声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">namespace Ui &#123;</span><br><span class="line">class Widget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是声明了一个名称为 Ui 的命名空间（namespace），包含一个类 Widget。但是这个类 Widget 并不是本文件里定义的类 Widget，而是 ui_widget.h 文件里定义的类，用于描述界面组件的。这个声明相当于一个外部类型声明（具体要看完 ui_widget.h 文件内的解释之后才能搞明白）。</p>
<h4 id="Widget-类的定义"><a href="#Widget-类的定义" class="headerlink" title="Widget 类的定义"></a>Widget 类的定义</h4><p>widget.h 文件的主体部分是一个继承于 QWidget 的类 Widget 的定义，也就是本实例的窗体类。 在 Widget 类中使用了宏 Q_OBJECT，这是使用 Qt 的信号与槽（signal 和 slot）机制的类都必须加入的一个宏（信号与槽在后面详细介绍）。 在 public 部分定义了 Widget 类的构造函数和析构函数。 在 private 部分又定义了一个指针。</p>
<p>Ui::Widget *ui;</p>
<p>这个指针是用前面声明的 namespace Ui 里的 Widget 类定义的，所以指针 ui 是指向可视化设计的界面，后面会看到要访问界面上的组件，都需要通过这个指针 ui。</p>
<h2 id="widget-cpp-文件"><a href="#widget-cpp-文件" class="headerlink" title="widget.cpp 文件"></a>widget.cpp 文件</h2><p>widget.cpp 文件是类 Widget 的实现代码，下面是 widget.cpp 文件的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;widget.h&quot;</span><br><span class="line">#include &quot;ui_widget.h&quot;</span><br><span class="line"></span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(new Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~Widget()</span><br><span class="line">&#123;</span><br><span class="line">    delete ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到，在这个文件的包含文件部分自动加入了如下一行内容：</p>
<p>#include “ui_widget.h”</p>
<p>这个就是 Qt 编译生成的与 UI 文件 widget.ui 对应的类定义文件。 目前只有构造函数和析构函数。其中构造函数头部是：</p>
<p>Widget::Widget(QWidget *parent) : QWidget(parent), ui(new Ui::Widget)</p>
<p>其意义是：执行父类 QWidget 的构造函数，创建一个 Ui::Widget 类的对象 ui。这个 ui 就是 Widget 的 private 部分定义的指针变量 ui。 构造函数里只有一行语句：</p>
<p>ui-&gt;setupUi(this)</p>
<p>它是执行了 Ui::Widget 类的 setupUi() 函数，这个函数实现窗口的生成与各种属性的设置、信号与槽的关联（后面会具体介绍）。 析构函数只是简单地删除用 new 创建的指针 ui。 所以，在 ui_widget.h 文件里有一个 namespace 名称为 Ui，里面有一个类 Widget 是用于描述可视化设计的窗体，且与 widget.h 里定义的类同名。在 Widget 类里访问 Ui::Widget 类的成员变量或函数需要通过 Widget 类里的 ui 指针，如同构造函数里执行 ui-&gt;setupUi( this) 函数那样。</p>
<h2 id="widget-ui-文件"><a href="#widget-ui-文件" class="headerlink" title="widget.ui 文件"></a>widget.ui 文件</h2><p>widget.ui 是窗体界面定义文件，是一个 XML 文件，定义了窗口上的所有组件的属性设置、布局，及其信号与槽函数的关联等。用UI设计器可视化设计的界面都由 Qt 自动解析，并以 XML 文件的形式保存下来。在设计界面时，只需在 UI 设计器里进行可视化设计即可，而不用管 widget.ui 文件是怎么生成的。 下面是 widget.ui 文件的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;ui version=&quot;4.0&quot;&gt;</span><br><span class="line">&lt;class&gt;Widget&lt;/class&gt;</span><br><span class="line">&lt;widget class=&quot;QWidget&quot; name=&quot;Widget&quot;&gt;</span><br><span class="line">  &lt;property name=&quot;geometry&quot;&gt;</span><br><span class="line">   &lt;rect&gt;</span><br><span class="line">    &lt;x&gt;0&lt;/x&gt;</span><br><span class="line">    &lt;y&gt;0&lt;/y&gt;</span><br><span class="line">    &lt;width&gt;336&lt;/width&gt;</span><br><span class="line">    &lt;height&gt;216&lt;/height&gt;</span><br><span class="line">   &lt;/rect&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property name=&quot;windowTitle&quot;&gt;</span><br><span class="line">   &lt;string&gt;My First Demo&lt;/string&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;widget class=&quot;QLabel&quot; name=&quot;Lablabel&quot;&gt;</span><br><span class="line">   &lt;property name=&quot;geometry&quot;&gt;</span><br><span class="line">    &lt;rect&gt;</span><br><span class="line">     &lt;x&gt;100&lt;/x&gt;</span><br><span class="line">     &lt;y&gt;70&lt;/y&gt;</span><br><span class="line">     &lt;width&gt;141&lt;/width&gt;</span><br><span class="line">     &lt;height&gt;61&lt;/height&gt;</span><br><span class="line">    &lt;/rect&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">   &lt;property name=&quot;font&quot;&gt;</span><br><span class="line">    &lt;font&gt;</span><br><span class="line">     &lt;pointsize&gt;12&lt;/pointsize&gt;</span><br><span class="line">     &lt;weight&gt;75&lt;/weight&gt;</span><br><span class="line">     &lt;bold&gt;true&lt;/bold&gt;</span><br><span class="line">    &lt;/font&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">   &lt;property name=&quot;text&quot;&gt;</span><br><span class="line">    &lt;string&gt;Hello，World&lt;/string&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">  &lt;/widget&gt;</span><br><span class="line">  &lt;widget class=&quot;QPushButton&quot; name=&quot;btnClose&quot;&gt;</span><br><span class="line">   &lt;property name=&quot;geometry&quot;&gt;</span><br><span class="line">    &lt;rect&gt;</span><br><span class="line">     &lt;x&gt;210&lt;/x&gt;</span><br><span class="line">     &lt;y&gt;150&lt;/y&gt;</span><br><span class="line">     &lt;width&gt;75&lt;/width&gt;</span><br><span class="line">     &lt;height&gt;23&lt;/height&gt;</span><br><span class="line">    &lt;/rect&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">   &lt;property name=&quot;text&quot;&gt;</span><br><span class="line">    &lt;string&gt;Close&lt;/string&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">  &lt;/widget&gt;</span><br><span class="line">&lt;/widget&gt;</span><br><span class="line">&lt;layoutdefault spacing=&quot;6&quot; margin=&quot;11&quot;/&gt;</span><br><span class="line">&lt;resources/&gt;</span><br><span class="line">&lt;connections&gt;</span><br><span class="line">  &lt;connection&gt;</span><br><span class="line">   &lt;sender&gt;btnClose&lt;/sender&gt;</span><br><span class="line">   &lt;signal&gt;clicked()&lt;/signal&gt;</span><br><span class="line">   &lt;receiver&gt;Widget&lt;/receiver&gt;</span><br><span class="line">   &lt;slot&gt;close()&lt;/slot&gt;</span><br><span class="line">   &lt;hints&gt;</span><br><span class="line">    &lt;hint type=&quot;sourcelabel&quot;&gt;</span><br><span class="line">     &lt;x&gt;247&lt;/x&gt;</span><br><span class="line">     &lt;y&gt;161&lt;/y&gt;</span><br><span class="line">    &lt;/hint&gt;</span><br><span class="line">    &lt;hint type=&quot;destinationlabel&quot;&gt;</span><br><span class="line">     &lt;x&gt;167&lt;/x&gt;</span><br><span class="line">     &lt;y&gt;107&lt;/y&gt;</span><br><span class="line">    &lt;/hint&gt;</span><br><span class="line">   &lt;/hints&gt;</span><br><span class="line">  &lt;/connection&gt;</span><br><span class="line">&lt;/connections&gt;</span><br><span class="line">&lt;/ui&gt;</span><br></pre></td></tr></table></figure>

<h2 id="ui-widget-h-文件"><a href="#ui-widget-h-文件" class="headerlink" title="ui_widget.h 文件"></a>ui_widget.h 文件</h2><p>ui_widget.h 是在对 widget.ui 文件编译后生成的一个文件，ui_widget.h 会出现在编译后的目录下，或与 widget.ui 同目录（与项目的 shadow build 编译设置有关）。 文件 ui_widget.h 并不会出现在 Qt Creator 的项目文件目录树里，当然，可以手工将 ui_widget.h 添加到项目中。方法是在项目文件目录树上，右击项目名称节点，在调出的快捷菜单中选择“Add Existing Files…”，找到并添加 ui_widget.h 文件即可。 注意，ui_widget.h 是对 widget.ui 文件编译后自动生成的，widget.ui 又是通过 UI 设计器可视化设计生成的。所以，对 ui_widget.h 手工进行修改没有什么意义，所有涉及界面的修改都应该直接在UI 设计器里进行。所以，ui_widget.h 也没有必要添加到项目里。 下面是 ui_widget.h 文件的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/********************************************************************************** Form generated from reading UI file &#x27;widget.ui&#x27;**** Created by: Qt User Interface Compiler version 5.9.1**** WARNING! All changes made in this file will be lost when recompiling UI file!********************************************************************************/#ifndef UI_WIDGET_H#define UI_WIDGET_H#include &lt;QtCore/QVariant&gt;#include &lt;QtWidgets/QAction&gt;#include &lt;QtWidgets/QApplication&gt;#include &lt;QtWidgets/QButtonGroup&gt;#include &lt;QtWidgets/QHeaderView&gt;#include &lt;QtWidgets/QLabel&gt;#include &lt;QtWidgets/QPushButton&gt;#include &lt;QtWidgets/QWidget&gt;QT_BEGIN_NAMESPACEclass Ui_Widget&#123;public:    QLabel *label;    QPushButton *btnClose;    void setupUi(QWidget *Widget)    &#123;        if (Widget-&gt;objectName().isEmpty())            Widget-&gt;setObjectName(QStringLiteral(&quot;Widget&quot;));        Widget-&gt;resize(336, 216);        label = new QLabel(Widget);        label-&gt;setObjectName(QStringLiteral(&quot;label&quot;));        label-&gt;setGeometry(QRect(100, 70, 141, 61));        QFont font;        font.setPointSize(12);        font.setBold(true);        font.setWeight(75);        label-&gt;setFont(font);        btnClose = new QPushButton(Widget);        btnClose-&gt;setObjectName(QStringLiteral(&quot;btnClose&quot;));        btnClose-&gt;setGeometry(QRect(210, 150, 75, 23));        retranslateUi(Widget);        QObject::connect(btnClose, SIGNAL(clicked()), Widget, SLOT(close()));        QMetaObject::connectSlotsByName(Widget);    &#125; // setupUi    void retranslateUi(QWidget *Widget)    &#123;        Widget-&gt;setWindowTitle(QApplication::translate(&quot;Widget&quot;, &quot;My First Demo&quot;, Q_NULLPTR));        label-&gt;setText(QApplication::translate(&quot;Widget&quot;, &quot;Hello\357\274\214World&quot;, Q_NULLPTR));        btnClose-&gt;setText(QApplication::translate(&quot;Widget&quot;, &quot;Close&quot;, Q_NULLPTR));    &#125; // retranslateUi&#125;;namespace Ui &#123;    class Widget: public Ui_Widget &#123;&#125;;&#125; // namespace UiQT_END_NAMESPACE#endif // UI_WIDGET_H</span><br></pre></td></tr></table></figure>

<p>查看 ui_widget.h 文件的内容，发现它主要做了以下的一些工作：</p>
<ol>
<li><p>定义了一个类 Ui_Widget，用于封装可视化设计的界面。</p>
</li>
<li><p>自动生成了界面各个组件的类成员变量定义。在 public 部分为界面上每个组件定义了一个指针变量，变量的名称就是设置的 objectName。比如，在窗体上放置了一个 QLabel 和一个 QPushButton 并命名后，自动生成的定义是：</p>
</li>
</ol>
<p>QLabel *LabDemo; QPushButton *btnClose;</p>
<ol start="3">
<li>定义了 setupUi() 函数，这个函数用于创建各个界面组件，并设置其位置、大小、文字内容、字体等属性，设置信号与槽的关联。setupUi() 函数体的第一部分是根据可视化设计的界面内容，用 C++ 代码创建界面上各组件，并设置其属性。 接下来，setupUi() 调用了函数 retranslateUi(Widget)，用来设置界面各组件的文字内容属性，如标签的文字、按键的文字、窗体的标题等。将界面上的文字设置的内容独立出来作为一个函数 retranslateUi()，在设计多语言界面时会用到这个函数。 setupUi() 函数的第三部分是设置信号与槽的关联，本文件中有以下两行：</li>
</ol>
<p>QObject::connect(btnClose, SIGNAL(clicked()), Widget, SLOT(close())); QMetaObject::connectSlotsByName(Widget);</p>
<p>第1 行是调用 connect() 函数，将在 UI 设计器里设置的信号与槽的关联转换为语句。这里是将 btnClose 按键的 clicked() 信号与窗体 Widget 的 close() 槽函数关联起来，就是在图 4 中设置的信号与槽的关联的程序语句实现。这样，当单击 btnClose 按钮时，就会执行 Widget 的 close() 槽函数，而 close() 槽函数的功能是关闭窗口。 第 2 行是设置槽函数的关联方式，用于将 UI 设计器自动生成的组件信号的槽函数与组件信号相关联。 所以，在Widget 的构造函数里调用 ui-&gt;setupUI(this)，就实现了窗体上组件的创建、属性设置、信号与槽的关联。</p>
<ol start="4">
<li>定义 namespace Ui，并定义一个从Ui_Widget 继承的类Widget。</li>
</ol>
<p>namespace Ui {    class Widget: public Ui_Widget {}; }</p>
<p>提示：ui_widget.h 文件里实现界面功能的类是 Ui_Widget。再定义一个类 Widget 从 Ui_Widget 继承而来，并定义在 namespace Ui 里，这样 Ui:: Widget 与 widget.h 里的类 Widget 同名，但是用 namespace 区分开来。所以，界面的 Ui:: Widget 类与文件 widget.h 里定义的 Widget 类实际上是两个类，但是 Qt 的处理让用户感觉不到 Ui:: Widget 类的存在，只需要知道在 Widget 类里用 ui 指针可以访问可视化设计的界面组件就可以了。</p>
<ol start="10">
<li>Qt项目中main主函数及其作用</li>
</ol>
<p>main.cpp 是实现 main() 函数的文件，下面是 main.cpp 文件的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;widget.h&quot;</span><br><span class="line">#include &lt;QApplication&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    QApplication a(argc, argv); //定义并创建应用程序   </span><br><span class="line">	  Widget w; //定义并创建窗口  </span><br><span class="line"> 	  w.show(); //显示窗口   </span><br><span class="line">	  return a.exec(); //应用程序运行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main() 函数是应用程序的入口。它的主要功能是创建应用程序，创建窗口，显示窗口，并运行应用程序，开始应用程序的消息循环和事件处理。     QApplication 是 <a target="_blank" rel="noopener" href="http://c.biancheng.net/qt/">Qt</a>的标准应用程序类，第 1 行代码定义了一个 QApplication 类的实例 a，就是应用程序对象。     然后定义了一个 Widget 类的变量 w，Widget 是本实例设计的窗口的类名，定义此窗口后再用 w.show() 显示此窗口。     最后一行用 a.exec() 启动应用程序的执行，开始应用程序的消息循环和事件处理。</p>
<ol start="11">
<li>Qt界面布局管理详解</li>
</ol>
<p>在上一节，通过一个简单的应用程序，分析了 <a target="_blank" rel="noopener" href="http://c.biancheng.net/qt/">Qt</a>创建的 GUI 应用程序中各个文件的作用，剖析了可视化设计的UI文件是如何被转换为 <a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a>的类定义，并自动创建界面的。这些是使用 Qt Creator 可视化设计用户界面，并使各个部分融合起来运行的基本原理。         本节再以一个稍微复杂的例子来讲解设计 GUI 的常见功能，包括界面设计时布局的管理，以及程序里如何访问界面组件。</p>
<h2 id="实例程序功能"><a href="#实例程序功能" class="headerlink" title="实例程序功能"></a>实例程序功能</h2><p>创建一个 Widget Application 项目 samp2_2，在创建窗体时选择基类 QDialog，生成的类命名为 QWDialog，并选择生成窗体。         如此新建的项目 samp2_2 有一个界面文件 qwdialog.ui，一个头文件 qwdialog.h 和源程序文件 qwdialog.cpp。此外，还有项目文件 samp2_2.pro 和主程序文件 main.cpp。         qwdialog.ui 界面文件设计时界面如图 1 所示。程序的主要功能是对中间一个文本框的文字字体样式和颜色进行设置。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/d15367cc-9b42-4778-99a7-2bf38a1b2257.gif" alt="image">                                                                图 1 实例程序 samp2_2 设计时界面</p>
<p>在界面设计时，对需要访问的组件修改其 objectName，如各个按钮、需要读取输入的编辑框、需要显示结果的标签等，以便在程序里区分。对于不需要程序访问的组件则无需修改其 objectName，如用于界面上组件分组的 GroupBox、Frame、布局等，让 UI 设计器自动命名即可。 对图 1 中几个主要组件的命名、属性设置见表 2。</p>
<table>
<thead>
<tr>
<th>对象名</th>
<th>类名称</th>
<th>属性设置</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>txtEdit</td>
<td>QPlainTextEdit</td>
<td>Text&#x3D;”Hello, World It is my demo. “ Font.PointSize&#x3D;20</td>
<td>用于显示文字内容，可编辑</td>
</tr>
<tr>
<td>chkBoxUnder</td>
<td>QCheckBox</td>
<td>Text&#x3D;”Underline”</td>
<td>设置字体为下划线</td>
</tr>
<tr>
<td>chkBoxItalic</td>
<td>QCheckBox</td>
<td>Text&#x3D;”Italic”</td>
<td>设置字体为斜体</td>
</tr>
<tr>
<td>chkBoxBold</td>
<td>QCheckBox</td>
<td>Text&#x3D;”Bold”</td>
<td>设置字体为粗体</td>
</tr>
<tr>
<td>rBtnBlack</td>
<td>QRadioButton</td>
<td>Text&#x3D;”Black”</td>
<td>字体颜色为黑色</td>
</tr>
<tr>
<td>rBtnRed</td>
<td>QRadioButton</td>
<td>Text&#x3D;”Red”</td>
<td>字体颜色为红色</td>
</tr>
<tr>
<td>rBtnBlue</td>
<td>QRadioButton</td>
<td>Text&#x3D;”Blue”</td>
<td>字体颜色为蓝色</td>
</tr>
<tr>
<td>btnOK</td>
<td>QPushButton</td>
<td>Text&#x3D;”确定”</td>
<td>返回确定，并关闭窗口</td>
</tr>
<tr>
<td>btnCancel</td>
<td>QPushButton</td>
<td>Text&#x3D;”取消”</td>
<td>返回取消，并关闭窗口</td>
</tr>
<tr>
<td>btnClose</td>
<td>QPushButton</td>
<td>Text&#x3D;”退出”</td>
<td>退出程序</td>
</tr>
<tr>
<td>QWDialog</td>
<td>QWDialog</td>
<td>windowTitle&#x3D;”Dialog by Designer”</td>
<td>界面窗口的类名称是QWDialog，objectName 不要修改</td>
</tr>
</tbody></table>
<p>对于界面组件的属性设置，需要注意以下几点。</p>
<ol>
<li><p>objectName 是窗体上创建的组件的实例名称，界面上的每个组件需要有一个唯一的 objectName，程序里访问界面组件时都是通过其 objectName 进行访问，自动生成的槽函数名称里也有 objectName。所以，组件的 objectName 需要在设计程序之前设置好，设置好之后一般不要再改动。若设计程序之后再改动 objectName，涉及的代码需要相应的改动。</p>
</li>
<li><p>窗体的 objectName 就是窗体的类名称，在 UI 设计器里不要修改窗体的 objectName，窗体的实例名称需要在使用窗体的代码里去定义。</p>
</li>
</ol>
<h2 id="界面组件布局"><a href="#界面组件布局" class="headerlink" title="界面组件布局"></a>界面组件布局</h2><p>Qt 的界面设计使用了布局（Layout）功能。所谓布局，就是界面上组件的排列方式，使用布局可以使组件有规则地分布，并且随着窗体大小变化自动地调整大小和相对位置。布局管理是 GUI 设计的必备技巧，下面逐步讲解如何实现图 1 所示的界面设计。</p>
<h4 id="界面组件的层次关系"><a href="#界面组件的层次关系" class="headerlink" title="界面组件的层次关系"></a>界面组件的层次关系</h4><p>为了将界面上的各个组件的分布设计得更加美观，经常使用一些容器类，如 QgoupBox、QtabWidget、QFrame 等。         例如，将 3 个 CheckBox 组件放置在一个 GroupBox 组件里，该 GroupBox 组件就是这 3 个 CheckBox 的容器，移动这个 GroupBox 就会同时移动其中的 3 个 CheckBox。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/f8010e30-aa1e-4516-8996-bfa9e058a992.gif" alt="image">                                                    图 3 界面组件的放置及层次关系</p>
<p>图 3 显示的是设计图 1 界面的前期阶段。在窗体上放置了 2 个 GroupBox 组件，在 groupBox1 里放置 3 个 CheckBox 组件，在 groupBox2 里放置 3 个 RadioButton 组件。图 3 右侧 Object Inspector 里显示了界面上各组件之间的层次关系。</p>
<h4 id="布局管理"><a href="#布局管理" class="headerlink" title="布局管理"></a>布局管理</h4><p>Qt 为界面设计提供了丰富的布局管理功能，在 UI 设计器中，组件面板里有 Layouts 和 Spacers 两个组件面板，在窗体上方的工具栏里有布局管理的按钮（如图 4 所示）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/be3253ea-59d1-437e-a7f5-0fc5c11ef85c.gif" alt="image">图 4 用于布局可视化设计的组件面板和工具栏</p>
<p>Layouts 和 Spacers 两个组件面板里的布局组件的功能见表 5：</p>
<table>
<thead>
<tr>
<th>布局组件</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Vertical Layout</td>
<td>垂直方向布局，组件自动在垂直方向上分布</td>
</tr>
<tr>
<td>Horizontal Layout</td>
<td>水平方向布局，组件自动在水平方向上分布</td>
</tr>
<tr>
<td>Grid Layout</td>
<td>网格状布局，网状布局大小改变时，每个网格的大小都改变</td>
</tr>
<tr>
<td>Form Layout</td>
<td>窗体布局，与网格状布局类似，但是只有最右侧的一列网格会改变大小</td>
</tr>
<tr>
<td>Horizontal Spacer</td>
<td>一个用于水平分隔的空格</td>
</tr>
<tr>
<td>Vertical Spacer</td>
<td>一个用于垂直分隔的空格</td>
</tr>
</tbody></table>
<p>使用组件面板里的布局组件设计布局时，先拖放一个布局组件到窗体上，如在设计图 4 中 3 个按钮的布局时，先放一个 Horizontal Layout 到窗体上，布局组件会以红色边框显示。再往布局组件里拖放 3 个 Push Button 和 2 个 Horizontal Spacer，就可以得到图 1 中 3 个按钮的水平布局效果。 在设计窗体的上方有一个工具栏，用于调整设计器进入不同的状态，以及进行布局设计，工具栏上各按钮的功能见表 6。</p>
<table>
<thead>
<tr>
<th>按钮及快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Edit Widget (F3)</td>
<td>界面设计进入编辑状态，就是正常的设计状态</td>
</tr>
<tr>
<td>Edit Signals&#x2F;Slots(F4)</td>
<td>进入信号与槽的可视化设计状态</td>
</tr>
<tr>
<td>Edit Buddies</td>
<td>进入伙伴关系编辑状态，可以设置一个Label 与一个组件成为伙伴关系</td>
</tr>
<tr>
<td>Edit Tab Order</td>
<td>进入Tab 顺序编辑状态，Tab 顺序是在键盘上按Tab 键时，输入焦点在界面各组件之间跳动的顺序</td>
</tr>
<tr>
<td>Lay Out Horizontally (Ctrl+H)</td>
<td>将窗体上所选组件水平布局</td>
</tr>
<tr>
<td>Lay Out Vertically (Ctrl+L)</td>
<td>将窗体上所选组件垂直布局</td>
</tr>
<tr>
<td>Lay Out Horizontally in Splitter</td>
<td>将窗体上所选组件用一个分割条进行水平分割布局</td>
</tr>
<tr>
<td>Lay Out Vertically in Splitter</td>
<td>将窗体上所选组件用一个分割条进行垂直分割布局</td>
</tr>
<tr>
<td>Lay Out in a Form Layout</td>
<td>将窗体上所选组件按窗体布局</td>
</tr>
<tr>
<td>Lay Out in a Grid</td>
<td>将窗体上所选组件网格布局</td>
</tr>
<tr>
<td>Break Layout</td>
<td>解除窗体上所选组件的布局，也就是打散现有的布局</td>
</tr>
<tr>
<td>Adjust Size(Ctrl+J)</td>
<td>自动调整所选组件的大小</td>
</tr>
</tbody></table>
<p>使用工具栏上的布局控制按钮时，只需在窗体上选中需要设计布局的组件，然后点击某个布局按钮即可。在窗体上选择组件时同时按住 Ctrl 键，可以实现组件多选，选择某个容器类组件，相当于选择了其内部的所有组件。         例如，在图 3 的界面中，选中 groupBox1，然后单击“Lay Out Horizontally”工具栏按钮，就可以对 groupBox1 内的 3 个 CheckBox 水平布局。 在图 4 的界面上，使 groupBox1 里的 3 个 CheckBox 水平布局，groupBox2 里的 3 个 RadioButton 水平布局，下方 3个按钮水平布局。在窗体上又放置了一个 PlainTextEdit 组件。现在，改变 groupBox1、groupBox2 或按钮的水平布局的大小，其内部组件都会自动改变大小。但是当改变窗体大小时，界面上的各组件却并不会自动改变大小。         随后还需为窗体指定一个总的布局。选中窗体（即不要选择任何组件），单击工具栏上的“Lay Out Vertically”按钮，使 4 个组件垂直分布。这样布局后，当窗体大小改变时，各个组件都会自动改变大小。 在 UI 设计器里可视化设计布局时，要善于利用水平和垂直空格组件，善于设置组件的最大、最小宽度和高度来实现某些需要的布局效果。</p>
<h4 id="伙伴关系与-Tab-顺序"><a href="#伙伴关系与-Tab-顺序" class="headerlink" title="伙伴关系与 Tab 顺序"></a>伙伴关系与 Tab 顺序</h4><p>在 UI 设计工具栏上单击“Edit Buddies”按钮可以进入伙伴关系编辑状态，如设计一个窗体时，进入伙伴编辑状态之后的界面如图 7 所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/93c4efe7-dfc7-4d6b-baae-ee964dc11e8e.gif" alt="image">图 7 编辑伙伴关系</p>
<p>伙伴关系（Buddy）是指界面上一个 Label 和一个组件相关联，如图 7 中的伙伴关系编辑状态，单击一个 Label，按住鼠标左键，然后拖向一个组件，就建立了 Label 和组件之间的伙伴关系。 伙伴关系是为了在程序运行时，在窗体上用快捷键快速将输入焦点切换到某个组件上。例如，在图 7 的界面上，设定“姓名”标签的 Text 属性为“姓名(&amp;N)”，其中符号“&amp;”用来指定快捷字符，界面上并不显示“&amp;”，这里指定快捷字母为 N。那么程序运行时，用户按下 Alt+N，输入焦点就会快速切换到“姓名”关联的输入框内。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/f05e917d-6c0d-491f-9d27-e4bbdbbba357.gif" alt="image">                                                                                    图 8 Tab 顺序编辑状态</p>
<p>在 UI 设计器工具栏上单击“Edit Tab Order”按钮进入Tab 顺序编辑状态（如图 8 所示）。Tab 顺序是指在程序运行时，按下键盘上的 Tab 键时输入焦点的移动顺序。一个好的用户界面，在按 Tab 键时，焦点应该以合理的顺序在界面上移动，而不是随意地移动。     进入 Tab 顺序编辑状态后，在界面上会显示具有 Tab 顺序组件的编号，依次按希望的顺序单击组件，就可以重排 Tab 顺序了。没有输入焦点的组件是没有 Tab 顺序的，如 Label 组件。</p>
<h2 id="项目功能实现"><a href="#项目功能实现" class="headerlink" title="项目功能实现"></a>项目功能实现</h2><p>下面开始设计程序功能。对于该程序，希望它的功能如下：</p>
<ol>
<li><p>单击 UnderLine、Italic、Bold 3 个 CheckBox 时，根据其状态，设置 PlainTextEdit 里的文字的字体样式；</p>
</li>
<li><p>Black、Red、Blue 3 个 RadioButton 是互斥选择的，单击某个 RadioButton 时，设置文字的颜色；</p>
</li>
<li><p>单击“确定”“取消”或“退出”按钮时，关闭窗口，退出程序。</p>
</li>
</ol>
<h4 id="字体样式设置"><a href="#字体样式设置" class="headerlink" title="字体样式设置"></a>字体样式设置</h4><p>窗体在<a target="_blank" rel="noopener" href="http://c.biancheng.net/design_pattern/">设计模式</a>下，选中 chkBoxUnder 组件，单击右键调出其快捷菜单。在快捷菜单中单击菜单项“Go to slot…”（中文状态为“转到槽”），出现如图 9 所示的对话框。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/0642f283-94f5-4dec-afff-438d7ba3d43a.gif" alt="image"></p>
<p>图 9 QcheckBox的Go to slot对话框</p>
<p>该对话框列出了 QCheckBox 类的所有信号，第一个是 clicked()，第二个是带一个布尔类型参数的 clicked(bool)。 信号 clicked(bool) 会将 CheckBox 组件当前的选择状态作为一个参数传递，在响应代码里可以直接利用这个传递的参数。而如果用信号 clicked()，则需要在代码里读取 CheckBox 组件的选中状态。为了简化代码，选择 clicked(bool) 信号。 选择 clicked(bool)，然后单击“OK”按钮，在 QWDialog 的类定义中，会在 private slots 部分自动增加一个槽函数声明，函数名是根据发射对象及其信号名称自动命名的。</p>
<p>void on_chkBoxUnder_clicked(bool checked);</p>
<p>同时，在 qwdialog.cpp 文件中自动添加了函数 on_chkBoxUnder_clicked(bool) 的框架，在此函数中添加如下的代码，实现文本框字体下划线的控制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void QWDialog::on_chkBoxUnder_clicked(bool checked)</span><br><span class="line">&#123;</span><br><span class="line">    QFont font=ui-&gt;txtEdit-&gt;font();</span><br><span class="line">    font.setUnderline(checked);</span><br><span class="line">    ui-&gt;txtEdit-&gt;setFont(font);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以同样的方法为 Italic 和 Bold 两个 CheckBox设计槽函数，编译后运行，发现已经实现了修改字体的下划线、斜体、粗体属性的功能，说明信号与槽函数已经关联了。 但是，查看 QWDialog 的构造函数，构造函数只有简单的一条语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QWDialog::QWDialog(QWidget *parent) : QDialog(parent), ui(new Ui::QWDialog)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里没有发现用 connect() 函数进行几个 CheckBox 的信号与槽函数关联的操作。这些功能是如何实现的呢？ 查看编译生成的 ui_qwdialog.h 文件。构造函数里调用的 setupUi() 是在 ui_qwdialog.h 文件里实现的。查看 setupUi() 函数的内容，也没有发现用 connect() 函数进行几个 CheckBox 的信号与槽关联的操作，只是在 setupUI()里发现了如下的一条语句：</p>
<p>QMetaObject::connectSlotsByName(QWDialog);</p>
<p>秘密就在于这条语句。connectSlotsByName(QWDialog) 函数将搜索 QWDialog 界面上的所有组件，将信号与槽函数匹配的信号和槽关联起来，它假设槽函数的名称是：</p>
<p>void on_<object name>_<signal name>(<signal parameters>);</p>
<p>例如，通过 UI 设计器的操作，为 chkBoxUnder 自动生成的槽函数是：</p>
<p>void on_chkBoxUnder_clicked(bool checked);</p>
<p>它就正好是 chkBoxUnder 的信号 clicked(bool) 的槽函数。那么，connectSlotsByName() 就会将此信号和槽函数关联起来，如同执行了下面的这样一条语句：</p>
<p>connect(chkBoxUnder, SIGNAL(clicked (bool)), this, SLOT (on_chkBoxUnder_clicked (bool));</p>
<p>这就是用 UI 设计器可视化设计某个组件的信号响应槽函数，而不用手工去将其关联起来的原因，都是在界面类的构造函数里调用 setupUi() 自动完成了关联。</p>
<h4 id="字体颜色设置"><a href="#字体颜色设置" class="headerlink" title="字体颜色设置"></a>字体颜色设置</h4><p>设置字体的 3 个 RadioButton 是互斥性选择的，即一次只有一个 RadioButton 被选中，虽然也可以采用可视化设计的方式设计其 clicked() 信号的槽函数，但是这样就需要生成 3 个槽函数。这里可以简化设计，即设计一个槽函数，将 3 个 RadioButton 的 clicked() 信号关联到这一个槽函数。 为此，在 QWDialog 类的 private slots 部分增加一个槽函数定义如下：</p>
<p>void setTextFontColor();</p>
<p>提示 将鼠标光标移动到这个函数的函数名上面，单击右键，在弹出的快捷菜单中选择“Refactor”→“Add Definition in qwdialog.cpp”，就可以在 qwdialog.cpp 文件中自动为函数 setTextFontColor() 生成一个函数框架。 在 qwdialog.cpp 文件中，为 setTextFontColor() 编写实现代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void QWDialog::setTextFontColor()</span><br><span class="line">&#123;</span><br><span class="line">    QPalette plet=ui-&gt;txtEdit-&gt;palette();</span><br><span class="line">    if (ui-&gt;rBtnBlue-&gt;isChecked())</span><br><span class="line">        plet.setColor(QPalette::Text,Qt::blue);</span><br><span class="line">    else if (ui-&gt;rBtnRed-&gt;isChecked())</span><br><span class="line">       plet.setColor(QPalette::Text,Qt::red);</span><br><span class="line">    else if (ui-&gt;rBtnBlack-&gt;isChecked())</span><br><span class="line">        plet.setColor(QPalette::Text,Qt::black);</span><br><span class="line">    else</span><br><span class="line">       plet.setColor(QPalette::Text,Qt::black);</span><br><span class="line">    ui-&gt;txtEdit-&gt;setPalette(plet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于这个槽函数是自定义的，所以不会自动与 RadioButton 的 clicked() 事件关联，此时编译后运行程序不会实现改变字体颜色的功能。需要在 QWDialog 的构造函数中手工进行关联，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QWDialog::QWDialog(QWidget *parent) : QDialog(parent), ui(new Ui::QWDialog)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(this);</span><br><span class="line">    connect(ui-&gt;rBtnBlue,SIGNAL(clicked()),this,SLOT(setTextFontColor()));</span><br><span class="line">    connect(ui-&gt;rBtnRed,SIGNAL(clicked()),this,SLOT(setTextFontColor()));</span><br><span class="line">    connect(ui-&gt;rBtnBlack,SIGNAL(clicked()),this,SLOT(setTextFontColor()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在构造函数中将 3 个 RadioButton 的 clicked() 信号与同一个槽函数 setTextFontColor() 相关联。再编译后运行，就可以更改文字的颜色了。</p>
<h4 id="三个按钮的功能设计"><a href="#三个按钮的功能设计" class="headerlink" title="三个按钮的功能设计"></a>三个按钮的功能设计</h4><p>界面上还有“确定”“取消”“退出”3 个按钮，这是在对话框中常见的按钮。“确定”表示确认选择并关闭对话框，“取消”表示取消选择并关闭对话框，“退出”则直接关闭对话框。 QWDialog 是从 QDialog 继承而来的，QDialog 提供了 accept()、reject()、close() 等槽函数来表示这三种状态，只需将按钮的 clicked() 信号与相应槽函数关联即可。 下面采用可视化的方式，将按钮的 clicked() 信号与这些槽函数关联起来。在 UI 设计器里，单击上方工具栏里的“Edit Signals&#x2F;Slots”按钮，窗体进入信号与槽函数编辑状态，如图 10 所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/97585e5f-2e3e-4248-bbdd-bac482f506d9.gif" alt="image">图 10 窗体进入Signals&#x2F;Slot编辑状态</p>
<p>将鼠标移动到“确定”按钮上方，再按下鼠标左键，移动到窗体的空白区域释放左键，这时出现如图 11 所示的关联设置对话框。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/fca6cab8-18c5-428c-9f5a-278f2c89bd9c.gif" alt="image">图 11 信号与槽关联编辑对话框</p>
<p>在图 11 中，左侧的列表框里显示了 btnOK 的信号，选择 clicked()，右边的列表框里显示了 QWDialog 的槽函数，选择 accept()，单击“OK”按钮。 同样的方法可以将 btnCancel 的 clicked() 信号与 QWDialog 的 reject() 槽函数关联，将 btnClose 的 clicked() 信号与 QWDialog 的 close() 槽函数关联。</p>
<p>注意，在图 11 的右侧列表框中没有 close() 槽函数，需要勾选下方的“Show signals and slots inherited from QWidget”才会出现 close() 函数。</p>
<p>设置完 3 个按钮的信号与槽关联之后，在窗体下方的 Signals 和 Slots 编辑器里也显示了这 3 个关联。实际上，可以直接在 Signals 和 Slots 编辑器进行关联设置。现在编译并运行程序，单击这 3 个按钮都会关闭程序。 那么，这 3 个按钮的信号与槽函数的关联是在哪里实现的呢？答案在 setupUi() 函数里，在 setupUi() 函数里自动增加了以下 3 行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QObject::connect(btnOK, SIGNAL(clicked()), QWDialog, SLOT(accept()));</span><br><span class="line">QObject::connect(btnCancel, SIGNAL(clicked()), QWDialog, SLOT(reject()));</span><br><span class="line">QObject::connect(btnClose, SIGNAL(clicked()), QWDialog, SLOT(close()));</span><br></pre></td></tr></table></figure>

<p>这个实例程序的功能全部完成了。采用 UI 设计器设计了窗体界面，采用可视化和程序化的方式设计槽函数，设计信号与槽函数之间的关联。 从以上的设计过程可以看到，Qt Creator 和 UI 设计器为设计应用程序提供了强大的可视化设计功能。</p>
<ol start="12">
<li>Qt信号与槽机制详解</li>
</ol>
<p>信号与槽（Signal &amp; Slot）是 <a target="_blank" rel="noopener" href="http://c.biancheng.net/qt/">Qt</a>编程的基础，也是 Qt 的一大创新。因为有了信号与槽的编程机制，在 Qt 中处理界面各个组件的交互操作时变得更加直观和简单。信号（Signal）就是在特定情况下被发射的事件，例如PushButton 最常见的信号就是鼠标单击时发射的 clicked() 信号，一个 ComboBox 最常见的信号是选择的列表项变化时发射的 CurrentIndexChanged() 信号。 GUI 程序设计的主要内容就是对界面上各组件的信号的响应，只需要知道什么情况下发射哪些信号，合理地去响应和处理这些信号就可以了。槽（Slot）就是对信号响应的函数。槽就是一个函数，与一般的<a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a>函数是一样的，可以定义在类的任何部分（public、private 或 protected），可以具有任何参数，也可以被直接调用。槽函数与一般的函数不同的是：槽函数可以与一个信号关联，当信号被发射时，关联的槽函数被自动执行。 信号与槽关联是用 QObject::connect() 函数实现的，其基本格式是：</p>
<p>QObject::connect(sender, SIGNAL(signal()), receiver, SLOT(slot()));</p>
<p>connect() 是 QObject 类的一个静态函数，而 QObject 是所有 Qt 类的基类，在实际调用时可以忽略前面的限定符，所以可以直接写为：</p>
<p>connect(sender, SIGNAL(signal()), receiver, SLOT(slot()));</p>
<p>其中，sender 是发射信号的对象的名称，signal() 是信号名称。信号可以看做是特殊的函数，需要带括号，有参数时还需要指明参数。receiver 是接收信号的对象名称，slot() 是槽函数的名称，需要带括号，有参数时还需要指明参数。 SIGNAL 和 SLOT 是 Qt 的宏，用于指明信号和槽，并将它们的参数转换为相应的字符串。例如，在 samp2_1（前面章节中的项目）的 ui_widget.h 文件中，在 setupUi() 函数中有如下的语句：</p>
<p>QObject::connect(btnClose, SIGNAL(clicked()), Widget, SLOT(close()));</p>
<p>其作用就是将 btnClose 按钮的 clicked() 信号与窗体（Widget）的槽函数 close() 相关联，这样，当单击 btnClose 按钮（就是界面上的“Close”按钮）时，就会执行 Widget 的 close() 槽函数。 关于信号与槽的使用，有以下一些规则需要注意：</p>
<ul>
<li>一个信号可以连接多个槽，例如：</li>
</ul>
<p>connect(spinNum, SIGNAL(valueChanged(int)), this, SLOT(addFun(int)); connect(spinNum, SIGNAL(valueChanged(int)), this, SLOT(updateStatus(int));</p>
<p>这是当一个对象 spinNum 的数值发生变化时，所在窗体有两个槽进行响应，一个 addFun()用于计算，一个 updateStatus() 用于更新状态。 当一个信号与多个槽函数关联时，槽函数按照建立连接时的顺序依次执行。 当信号和槽函数带有参数时，在 connect()函数里，要写明参数的类型，但可以不写参数名称。</p>
<ul>
<li>多个信号可以连接同一个槽，例如在 samp2_2（前面章节中的项目）中，让三个选择颜色的 RadioButton的clicked() 信号关联到相同的一个自定义槽函数 setTextFontColor()。</li>
</ul>
<p>connect(ui-&gt;rBtnBlue,SIGNAL(clicked()),this,SLOT(setTextFontColor())); connect(ui-&gt;rBtnRed,SIGNAL(clicked()),this,SLOT(setTextFontColor())); connect(ui-&gt;rBtnBlack,SIGNAL(clicked()),this,SLOT(setTextFontColor()));</p>
<p>这样，当任何一个 RadioButton 被单击时，都会执行 setTextFontColor() 函数。</p>
<ul>
<li>一个信号可以连接另外一个信号，例如：</li>
</ul>
<p>connect(spinNum, SIGNAL(valueChanged(int)), this, SIGNAL (refreshInfo(int));</p>
<p>这样，当一个信号发射时，也会发射另外一个信号，实现某些特殊的功能。</p>
<ul>
<li><p>严格的情况下，信号与槽的参数个数和类型需要一致，至少信号的参数不能少于槽的参数。如果不匹配，会出现编译错误或运行错误。</p>
</li>
<li><p>在使用信号与槽的类中，必须在类的定义中加入宏 Q_OBJECT。</p>
</li>
<li><p>当一个信号被发射时，与其关联的槽函数通常被立即执行，就像正常调用一个函数一样。只有当信号关联的所有槽函数执行完毕后，才会执行发射信号处后面的代码。</p>
</li>
</ul>
<p>信号与槽机制是 Qt GUI 编程的基础，使用信号与槽机制可以比较容易地将信号与响应代码关联起来。</p>
<ol start="13">
<li>Qt纯代码设计UI实例分析</li>
</ol>
<p>UI 的可视化设计是对用户而言的，其实底层都是 <a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a>的代码实现，只是 <a target="_blank" rel="noopener" href="http://c.biancheng.net/qt/">Qt</a>巧妙地进行了处理，让用户省去了很多繁琐的界面设计工作。 由于界面设计的底层其实都是由 C++ 语言实现的，底层实现的功能比可视化设计更加强大和灵活。某些界面效果是可视化设计无法完成的，或者某些人习惯了用纯代码的方式来设计界面，就可以采用纯代码的方式设计界面，如 Qt 自带的实例基本都是用纯代码方式实现用户界面的。 所以，本节介绍一个用纯代码方式设计 UI 的实例，通过实例了解用纯代码设计 UI 的基本原理。与前面的可视化 UI 设计相对应，且称之为代码化 UI 设计。</p>
<h2 id="实例功能"><a href="#实例功能" class="headerlink" title="实例功能"></a>实例功能</h2><p>首先建立一个 Widget Appliation 项目 samp2_3，在创建项目向导中选择基类时，选择基类 QDialog，新类的名称命名为 QWDlgManual，关键是取消创建窗体，即不勾选“Generate form”（创建界面）复选框。创建后的项目文件目录树下没有 qwdlgmanual.ui 文件。 该项目通过代码创建一个对话框，实现与 samp2_2 类似的界面和功能。本例完成后的运行效果如图 1 所示，其界面和功能与 samp2_2 类似。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/b8c40f64-6dee-4624-9069-e2a1ce396575.gif" alt="image"></p>
<p>图 1 实例 samp2_3 运行效果</p>
<h2 id="界面创建"><a href="#界面创建" class="headerlink" title="界面创建"></a>界面创建</h2><h4 id="QWDlgManual-类定义"><a href="#QWDlgManual-类定义" class="headerlink" title="QWDlgManual 类定义"></a>QWDlgManual 类定义</h4><p>完成功能后的 qwdlgmanual.h 文件中 QWDlgManual 类的完整定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QDialog&gt;</span><br><span class="line">#include &lt;QCheckBox&gt;</span><br><span class="line">#include &lt;QRadioButton&gt;</span><br><span class="line">#include &lt;QPlainTextEdit&gt;</span><br><span class="line">#include &lt;QPushButton&gt;</span><br><span class="line">class QWDlgManual : public QDialog&#123; </span><br><span class="line">   Q_OBJEC</span><br><span class="line">Tprivate: </span><br><span class="line">   QCheckBox   *chkBoxUnder;  </span><br><span class="line">  QCheckBox   *chkBoxItalic;  </span><br><span class="line">  QCheckBox   *chkBoxBold;  </span><br><span class="line">  QRadioButton    *rBtnBlack; </span><br><span class="line">   QRadioButton    *rBtnRed;  </span><br><span class="line">  QRadioButton    *rBtnBlue;  </span><br><span class="line">  QPlainTextEdit  *txtEdit;   </span><br><span class="line"> QPushButton     *btnOK;   </span><br><span class="line"> QPushButton     *btnCancel;   </span><br><span class="line"> QPushButton     *btnClose;   </span><br><span class="line"> void    iniUI();//UI 创建与初始化 </span><br><span class="line">   void    iniSignalSlots();//初始化信号与槽的链接</span><br><span class="line">private slots:    void on_chkBoxUnder(bool checked);</span><br><span class="line"> //Underline 的clicked(bool)信号的槽函数    </span><br><span class="line">void on_chkBoxItalic(bool checked);//Italic 的clicked(bool)信号的槽函数    void on_chkBoxBold(bool checked); //Bold 的clicked(bool)信号的槽函数    void setTextFontColor(); //设置字体颜色public:    QWDlgManual(QWidget *parent = 0);    ~QWDlgManual();&#125;;</span><br></pre></td></tr></table></figure>

<p>在 QWDlgManual 类的 private 部分，声明了界面上的各个组件的指针变量，这些界面组件都需要在 QWDlgManual 类的构造函数里创建并在窗体上布局。 在 private 部分自定义了两个函数，iniUI() 用来创建所有界面组件，并完成布局和属性设置，iniSignalSlots() 用来完成所有的信号与槽函数的关联。 在 private slots 部分声明了 4 个槽函数，分别是 3 个 CheckBox 的响应槽函数，以及 3 个颜色设置的 RadioButton 的共同响应槽函数。</p>
<p>注意：与可视化设计得到的窗体类定义不同，QWDlgManual 的类定义里没有指向界面的指针 ui。</p>
<p>这几个槽函数的功能与例 samp2_2 中的类似，只是在访问界面组件时，无需使用 ui 指针，而是直接访问 QWDlgManual 类里定义的界面组件的成员变量即可，例如 on_chkBoxUnder() 的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void QWDlgManual::on_chkBoxUnder(bool checked)&#123;    QFont font=txtEdit-&gt;font();    font.setUnderline(checked);    txtEdit-&gt;setFont(font);&#125;</span><br></pre></td></tr></table></figure>

<p>界面的创建，以及信号与槽函数的关联都在 QWDlgManual 的构造函数里完成，构造函数代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QWDlgManual::QWDlgManual(QWidget *parent) : QDialog(parent)&#123;    iniUI(); //界面创建与布局    iniSignalSlots(); //信号与槽的关联    setWindowTitle(&quot;Form created mannually&quot;);&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数调用 iniUI() 创建界面组件并布局，调用 iniSignalSlots() 进行信号与槽函数的关联。</p>
<h4 id="界面组件的创建与布局"><a href="#界面组件的创建与布局" class="headerlink" title="界面组件的创建与布局"></a>界面组件的创建与布局</h4><p>iniUI() 函数实现界面组件的创建与布局，以及属性设置。下面是 iniUI() 的完整代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void QWDlgManual::iniUI()&#123;    //创建 Underline, Italic, Bold 3 个CheckBox，并水平布局    chkBoxUnder=new QCheckBox(tr(&quot;Underline&quot;));    chkBoxItalic=new QCheckBox(tr(&quot;Italic&quot;));    chkBoxBold=new QCheckBox(tr(&quot;Bold&quot;));    QHBoxLayout *HLay1=new QHBoxLayout;    HLay1-&gt;addWidget(chkBoxUnder);    HLay1-&gt;addWidget(chkBoxItalic);    HLay1-&gt;addWidget(chkBoxBold);    //创建 Black, Red, Blue 3 个RadioButton，并水平布局    rBtnBlack=new QRadioButton(tr(&quot;Black&quot;));    rBtnBlack-&gt;setChecked(true);    rBtnRed=new QRadioButton(tr(&quot;Red&quot;));    rBtnBlue=new QRadioButton(tr(&quot;Blue&quot;));    QHBoxLayout *HLay2=new QHBoxLayout;    HLay2-&gt;addWidget(rBtnBlack);    HLay2-&gt;addWidget(rBtnRed);    HLay2-&gt;addWidget(rBtnBlue);    //创建确定, 取消, 退出3 个 PushButton, 并水平布局    btnOK=new QPushButton(tr(&quot;确定&quot;));    btnCancel=new QPushButton(tr(&quot;取消&quot;));    btnClose=new QPushButton(tr(&quot;退出&quot;));    QHBoxLayout *HLay3=new QHBoxLayout;    HLay3-&gt;addStretch();    HLay3-&gt;addWidget(btnOK);    HLay3-&gt;addWidget(btnCancel);    HLay3-&gt;addStretch();    HLay3-&gt;addWidget(btnClose);    //创建文本框,并设置初始字体    txtEdit=new QPlainTextEdit;    txtEdit-&gt;setPlainText(&quot;Hello world\n\nIt is my demo&quot;);    QFont font=txtEdit-&gt;font(); //获取字体    font.setPointSize(20);//修改字体大小    txtEdit-&gt;setFont(font);//设置字体    //创建垂直布局，并设置为主布局    QVBoxLayout *VLay=new QVBoxLayout;    VLay-&gt;addLayout(HLay1); //添加字体类型组    VLay-&gt;addLayout(HLay2);//添加字体颜色组    VLay-&gt;addWidget(txtEdit);//添加PlainTextEdit    VLay-&gt;addLayout(HLay3);//添加按键组    setLayout(VLay); //设置为窗体的主布局&#125;</span><br></pre></td></tr></table></figure>

<p>iniUI() 函数按照顺序完成了如下的功能：</p>
<ul>
<li><p>创建 3 个 QCheckBox 组件，这 3 个组件的指针已经定义为 QWDlgManual 的私有变量，然后创建一个水平布局 HLay1，将 3 个 CheckBox 添加到这个水平布局里。</p>
</li>
<li><p>创建 3 个 QRadioButton 组件，并创建一个水平布局 HLay2，将 3 个 RadioButton 添加到这个水平布局里。</p>
</li>
<li><p>创建 3 个 QPushButton 组件，并创建一个水平布局 HLay3，将 3 个 PushButton 添加到这个水平布局里，并适当添加水平空格。</p>
</li>
<li><p>创建一个 QPlainTextEdit 组件，设置其文字内容，并设置其字体。</p>
</li>
<li><p>创建一个垂直布局 VLay，将前面创建的 3 个水平布局和文本框依次添加到此布局里。</p>
</li>
<li><p>设置垂直布局为窗体的主布局。</p>
</li>
</ul>
<p>如此创建组件并设置布局后，运行可以得到如图 1 所示的界面效果。这里完全是采用代码来实现组件创建与布局的设置，而这些功能在可视化设计中是由 setupUi() 函数根据界面的可视化设计结果自动实现的。 采用代码设计实现 UI 时，需要对组件的布局有个完整的规划，不如可视化设计直观，且编写代码工作量大。</p>
<h2 id="信号与槽的关联"><a href="#信号与槽的关联" class="headerlink" title="信号与槽的关联"></a>信号与槽的关联</h2><p>在纯代码设计 UI 时，信号与槽的关联也需要用代码来完成。函数 iniSignalSlots() 初始化所有的信号与槽的关联，其完整代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void QWDlgManual::iniSignalSlots()&#123;    //三个颜色 QRadioButton 的clicked()信号与setTextFontColor()槽函数关联    connect(rBtnBlue,SIGNAL(clicked()),this,SLOT(setTextFontColor()));    connect(rBtnRed,SIGNAL(clicked()),this,SLOT(setTextFontColor()));    connect(rBtnBlack,SIGNAL(clicked()),this,SLOT(setTextFontColor()));    //三个字体设置的 QCheckBox 的clicked(bool)信号与相应的槽函数关联    connect(chkBoxUnder,SIGNAL(clicked(bool)),    this,SLOT(on_chkBoxUnder(bool)));    connect(chkBoxItalic,SIGNAL(clicked(bool)),    this,SLOT(on_chkBoxItalic(bool)));    connect(chkBoxBold,SIGNAL(clicked(bool)),    this,SLOT(on_chkBoxBold(bool)));    //三个按钮的信号与窗体的槽函数关联    connect(btnOK,SIGNAL(clicked()),this,SLOT(accept()));    connect(btnCancel,SIGNAL(clicked()),this,SLOT(reject()));    connect(btnClose,SIGNAL(clicked()),this,SLOT(close()));&#125;</span><br></pre></td></tr></table></figure>

<p>设计完成后，编译并运行程序，可以得到如图 1 所示的运行效果，且功能与 samp2_2 相同。很显然，采用纯代码方式实现 UI 界面是比较复杂的，代码设计的工作量大而繁琐。</p>
<ol start="14">
<li>Qt Creator使用技巧</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/qt/">Qt</a>Creator 在设计界面或编辑代码时，有一些快捷键和使用技巧，熟悉这些快捷键和使用技巧，可以提高工作效率。表 1 是 Qt Creator 的一些快捷操作的总结。</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Switch Header&#x2F;Source</td>
<td>F4</td>
<td>在同名的头文件和源程序文件之间切换</td>
</tr>
<tr>
<td>Follow Symbol Under Cursor</td>
<td>F2</td>
<td>跟踪光标下的符号，若是变量，可跟踪到变量声明的地方；若是函数体或函数声明，可在两者之间切换</td>
</tr>
<tr>
<td>Switch Between Function Declaration and Definition</td>
<td>Shift+F2</td>
<td>在函数的声明（函数原型）和定义（函数实现）之间切换</td>
</tr>
<tr>
<td>Refactor\Rename Symbol Under Cursor</td>
<td>Ctrl+Shift+R</td>
<td>对光标处的符号更改名称，这将替换到所有用到这个符号的地方</td>
</tr>
<tr>
<td>Refactor\Add Definition in .cpp</td>
<td></td>
<td>为函数原型在 cpp 文件里生成函数体</td>
</tr>
<tr>
<td>Auto-indent Selection</td>
<td>Ctrl+I</td>
<td>为选择的文字自动进行缩进</td>
</tr>
<tr>
<td>Toggle Comment Selection</td>
<td>Ctrl+&#x2F;</td>
<td>为选择的文字进行注释符号的切换，即可以注释所选代码，或取消注释</td>
</tr>
<tr>
<td>Context Help</td>
<td>F1</td>
<td>为光标所在的符号显示帮助文件的内容</td>
</tr>
<tr>
<td>Save All</td>
<td>Ctrl+Shift+S</td>
<td>文件全部保存</td>
</tr>
<tr>
<td>Find&#x2F;Replace</td>
<td>Ctrl+F</td>
<td>调出查找&#x2F;替换对话框</td>
</tr>
<tr>
<td>Find Next</td>
<td>F3</td>
<td>查找下一个</td>
</tr>
<tr>
<td>Build</td>
<td>Ctrl+B</td>
<td>编译当前项目</td>
</tr>
<tr>
<td>Start Debugging</td>
<td>F5</td>
<td>开始调试</td>
</tr>
<tr>
<td>Step Over</td>
<td>F10</td>
<td>调试状态下单步略过，即执行当前行程序语句</td>
</tr>
<tr>
<td>Step Into</td>
<td>F11</td>
<td>调试状态下跟踪进入，即如果当前行里有函数，就跟踪进入函数体</td>
</tr>
<tr>
<td>Toggle Breakpoint</td>
<td>F9</td>
<td>设置或取消当前行的断点设置</td>
</tr>
</tbody></table>
<p>另外，在使用 Qt 时，要善于使用 Qt 自带的帮助文件，对于一个编程语言或类库来说，其自带的帮助文件是最全面最权威的资料。当光标停留在一个类名或函数上时，按 F1 可以调出其帮助文件的内容。 在 Qt Creator 主窗口左侧的主工具栏上有“Help”按钮，单击可以打开 Qt 的帮助文件系统（如图 2 所示），也可以使用“开始”菜单 Qt 程序组里的 Assistant 单独打开帮助系统。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/94e13ac6-45f2-432e-a3c8-2a47ecf1d89d.gif" alt="image">图 2 使用 Qt 的帮助系统查看资料</p>
<p>在帮助文件显示界面上，左上方工具栏中有个下拉列表框，可以选择 Bookmarks、Contents、Index 和 Search 4 种模式：</p>
<ol>
<li><p>Bookmarks 模式下，左边框里显示已存储的 Bookmarks（书签），任何帮助页面下，点击窗口上方工具栏上的“Add Bookmark”可以添加书签。</p>
</li>
<li><p>Contents 模式下，左边框里以目录树形式显示 Qt 的所有模块（如图 1 所示），可以分类浏览想看的内容。</p>
</li>
<li><p>Index 模式下，可以输入查找内容，左边框里会列出与输入内容前匹配的帮助主题列表。</p>
</li>
<li><p>Search 模式下，可以输入关键字进行搜索。</p>
</li>
</ol>
<p>在 Qt 帮助系统里可以搜索查看每个类的详细资料，如 QTextEdit，可以看到这个类的详细资料，包括在这个类定义的公共类型、属性、公共函数、信号、公共槽等。 另外，若要查看类的继承关系，可以访问 Qt 官网的“Inheritance Hierarchy”页面。</p>
<ol start="15">
<li>Qt元对象和属性系统详解</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/qt/">Qt</a>是一个用标准 <a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a>编写的跨平台开发类库，它对标准 C++ 进行了扩展，引入了元对象系统、信号与槽、属性等特性，使应用程序的开发变得更高效。 本节将介绍 Qt 的这些核心特点，对于理解和编写高效的 Qt C++ 程序是大有帮助的。</p>
<h2 id="Qt-的元对象系统"><a href="#Qt-的元对象系统" class="headerlink" title="Qt 的元对象系统"></a>Qt 的元对象系统</h2><p>Qt 的元对象系统（Meta-Object System）提供了对象之间通信的信号与槽机制、运行时类型信息和动态属性系统。 元对象系统由以下三个基础组成：</p>
<ol>
<li><p>QObject 类是所有使用元对象系统的类的基类。</p>
</li>
<li><p>在一个类的 private 部分声明 Q_OBJECT宏，使得类可以使用元对象的特性，如动态属性、信号与槽。</p>
</li>
<li><p>MOC（元对象编译器）为每个 QObject 的子类提供必要的代码来实现元对象系统的特性。</p>
</li>
</ol>
<p>构建项目时，MOC 工具读取 C++ 源文件，当它发现类的定义里有 Q_OBJECT 宏时，它就会为这个类生成另外一个包含有元对象支持代码的 C++ 源文件，这个生成的源文件连同类的实现文件一起被编译和连接。 除了信号与槽机制外，元对象还提供如下一些功能：</p>
<ul>
<li>QObject::metaObject() 函数返回类关联的元对象，元对象类 QMetaObject 包含了访问元对象的一些接口函数，例如 QMetaObject::className() 函数可在运行时返回类的名称字符串。</li>
</ul>
<p>QObject *obj &#x3D; new QPushButton; obj-&gt;metaObject()-&gt;className (); &#x2F;&#x2F;返回”QPushButton”</p>
<ul>
<li><p>QMetaObject::newInstance() 函数创建类的一个新的实例。</p>
</li>
<li><p>QObject::inherits(const char *className) 函数判断一个对象实例是否是名称为 className 的类或 QObject 的子类的实例。例如：</p>
</li>
</ul>
<p>QTimer *timer &#x3D; new QTimer; &#x2F;&#x2F; QTimer 是 QObject 的子类 timer-&gt;inherits (“QTimer”); &#x2F;&#x2F; 返回 true timer-&gt;inherits (“QObject”);  &#x2F;&#x2F; 返回 true timer-&gt;inherits (“QAbstractButton”);&#x2F;&#x2F;返回 false,不是 QAbstractButton 的子类</p>
<ul>
<li><p>QObject::tr() 和 QObject::trUtf8() 函数可翻译字符串，用于多语言界面设计，后续章会专门介绍多语言界面设计。</p>
</li>
<li><p>QObject::setProperty() 和 QObject::property() 函数用于通过属性名称动态设置和获取属性值。</p>
</li>
</ul>
<p>对于 QObject 及其子类，还可以使用 qobject_cast() 函数进行动态投射（dynamic cast）。例如，假设 QMyWidget 是 QWidget 的子类并且在类定义中声明了 Q_OBJECT 宏。创建实例使用下面的语句：</p>
<p>QObject *obj &#x3D; new QMyWidget;</p>
<p>变量 obj 定义为 QObject 指针，但它实际指向 QMyWidget 类，所以可以正确投射为 QWidget，即：</p>
<p>QWidget *widget &#x3D; qobject_cast&lt;QWidget *&gt;(obj);</p>
<p>从 QObject 到 QWidget 的投射是成功的，因为 obj 实际是 QMyWidget 类，是 QWidget 的子类。也可以将其成功投射为 QMyWidget，即：</p>
<p>QMyWidget *myWidget &#x3D; qobject_cast&lt;QMyWidget *&gt;(obj);</p>
<p>投射为 QMyWidget 是成功的，因为 qobject_cast() 并不区分 Qt 内建的类型和用户自定义类型。但是，若要将 obj 投射为 QLabel 则是失败的，即：</p>
<p>QLabel * label - qobject_cast&lt;QLabel *&gt;(obj);</p>
<p>这样投射是失败的，返回指针 label 为 NULL，因为 QMyWidget 不是 QLabel 的子类。 使用动态投射，使得程序可以在运行时对不同的对象做不同的处理。</p>
<h2 id="属性系统"><a href="#属性系统" class="headerlink" title="属性系统"></a>属性系统</h2><h4 id="属性定义"><a href="#属性定义" class="headerlink" title="属性定义"></a>属性定义</h4><p>Qt 提供一个 Q_PROPERTY() 宏可以定义属性，它也是基于元对象系统实现的。Qt 的属性系统与 C++ 编译器无关，可以用任何标准的 C++ 编译器编译定义了属性的 Qt C++ 程序。 在 QObject 的子类中，用宏 Q_PROPERTY() 定义属性，其使用格式如下：</p>
<p>Q_PROPERTY(type name (READ getFunction [WRITE setFunction] | MEMBER meznberName [(READ getFunction | WRITE setFunction)])    [RESET resetFunction]    [NOTIFY notifySignal]    [REVISION int]    [DESIGNABLE bool]    [SCRIPTABLE bool]    [STORED bool]    [USER bool]    [CONSTANT]    [FINAL])</p>
<p>Q_PROPERTY 宏定义一个返回值类型为 type，名称为 name 的属性，用 READ、WRITE 关键字定义属性的读取、写入函数，还有其他的一些关键字定义属性的一些操作特性。属性的类型可以是 QVariant 支持的任何类型，也可以用户自定义类型。 Q_PROPERTY 宏定义属性的一些主要关键字的意义如下：</p>
<ul>
<li><p>READ 指定一个读取属性值的函数，没有 MEMBER 关键字时必须设置 READ。</p>
</li>
<li><p>WRITE 指定一个设定属性值的函数，只读属性没有 WRITE 设置。</p>
</li>
<li><p>MEMBER 指定一个成员变量与属性关联，成为可读可写的属性，无需再设置 READ 和 WRITE。</p>
</li>
<li><p>RESET 是可选的，用于指定一个设置属性缺省值的函数。</p>
</li>
<li><p>NOTIFY 是可选的，用于设置一个信号，当属性值变化时发射此信号。</p>
</li>
<li><p>DESIGNABLE 表示属性是否在 Qt Designer 里可见，缺省为 true。</p>
</li>
<li><p>CONSTANT 表示属性值是一个常数，对于一个对象实例，READ 指定的函数返回值是常数，但是每个实例的返回值可以不一样。具有 CONSTANT 关键字的属性不能有 WRITE 和 NOTIFY 关键字。</p>
</li>
<li><p>FINAL 表示所定义的属性不能被子类重载。</p>
</li>
</ul>
<p>QWidget 类定义属性的一些例子如下：</p>
<p>Q_PROPERTY(bool focus READ hasFocus) Q_PROPERTY(bool enabled READ isEnabled WRITE setEnabled) Q_PROPERTY(QCursor cursor READ cursor WRITE setCursor RESET unsetCursor)</p>
<h4 id="属性的使用"><a href="#属性的使用" class="headerlink" title="属性的使用"></a>属性的使用</h4><p>不管是否用 READ 和 WRITE 定义了接口函数，只要知道属性名称，就可以通过 QObject::property() 读取属性值，并通过 QObject::setProperty() 设置属性值。例如：</p>
<p>QPushButton *button &#x3D; new QPushButton; QObject *object &#x3D; button； object-&gt;setProperty(“flat”, true); bool isFlat&#x3D; object-&gt;property (“flat”);</p>
<h4 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h4><p>QObject::setProperty() 函数可以在运行时为类定义一个新的属性，称之为动态属性。动态属性是针对类的实例定义的。 动态属性可以使用 QObject::property() 查询，就如在类定义里用 Q_PROPERTY 宏定义的属性一样。 例如，在数据表编辑界面上，一些字段是必填字段，就可以在初始化界面时为这些字段的关联显示组件定义一个新的 required 属性，并设置值为“true”，如：</p>
<p>editName-&gt;setProperty(“required”, “true”); comboSex-&gt;setProperty(“required”, “true”); checkAgree-&gt;setProperty(“required”, “true”);</p>
<p>然后，可以应用下面的样式定义将这种必填字段的背景颜色设置为亮绿色。</p>
<p>*[required&#x3D;”true”]{background-color:lime}</p>
<h4 id="类的附加信息"><a href="#类的附加信息" class="headerlink" title="类的附加信息"></a>类的附加信息</h4><p>属性系统还有一个宏 Q_CLASSINFO()，可以为类的元对象定义“名称——值”信息，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class QMyClass:public QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    Q_CLASSINFO(&quot;author&quot;, &quot;Wang&quot;)</span><br><span class="line">    Q_CLASSINFO (&quot;company&quot;, &quot;UPC&quot;)</span><br><span class="line">    Q_CLASSINFO(&quot;version &quot;, &quot;3.0.1&quot;)</span><br><span class="line">  public:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用 Q_CLASSINFO() 宏定义附加类信息后，可以通过元对象的一些函数获取类的附加信息，如 classlnfo(int) 获取某个附加信息，函数原型定义如下：</p>
<p>QMetaClassInfo QMetaObject::classInfo(int index) const</p>
<p>返回值是 QMetaClassInfo 类型，有 name() 和 value() 两个函数，可获得类附加信息的名称和值。</p>
<ol start="16">
<li>Qt全局变量、函数和宏定义详解</li>
</ol>
<p>&lt;<a target="_blank" rel="noopener" href="http://c.biancheng.net/qt/">Qt</a>Global&gt; 头文件包含了 Qt 类库的一些全局定义，包括基本数据类型、函数和宏，一般的 Qt 类的头文件都会包含该文件，所以不用显式包含这个头文件也可以使用其中的定义。</p>
<h2 id="全局变量定义"><a href="#全局变量定义" class="headerlink" title="全局变量定义"></a>全局变量定义</h2><p>为了确保在各个平台上各数据类型都有统一确定的长度，Qt 为各种常见数据类型定义了类型符号，如 qint8 就是 signed char 的类型定义，即：</p>
<p>typedef signed char qint8;</p>
<p><QtGlobal>中定义的数据类型见表 1。</p>
<table>
<thead>
<tr>
<th>Qt 数据类型</th>
<th>等效定义</th>
<th>字节数</th>
</tr>
</thead>
<tbody><tr>
<td>qint8</td>
<td>signed char</td>
<td>1</td>
</tr>
<tr>
<td>qint16</td>
<td>signed short</td>
<td>2</td>
</tr>
<tr>
<td>qint32</td>
<td>signed int</td>
<td>4</td>
</tr>
<tr>
<td>qint64</td>
<td>long long int</td>
<td>8</td>
</tr>
<tr>
<td>qlonglong</td>
<td>long long int</td>
<td>8</td>
</tr>
<tr>
<td>quint8</td>
<td>unsigned char</td>
<td>1</td>
</tr>
<tr>
<td>quint16</td>
<td>unsigned short</td>
<td>2</td>
</tr>
<tr>
<td>quint32</td>
<td>unsigned int</td>
<td>4</td>
</tr>
<tr>
<td>quint64</td>
<td>unsigned long long int</td>
<td>8</td>
</tr>
<tr>
<td>qulonglong</td>
<td>unsigned long long int</td>
<td>8</td>
</tr>
<tr>
<td>uchar</td>
<td>unsigned char</td>
<td>1</td>
</tr>
<tr>
<td>ushort</td>
<td>unsigned short</td>
<td>2</td>
</tr>
<tr>
<td>uint</td>
<td>unsigned int</td>
<td>4</td>
</tr>
<tr>
<td>ulong</td>
<td>unsigned long</td>
<td>8</td>
</tr>
<tr>
<td>qreal</td>
<td>double</td>
<td>8</td>
</tr>
<tr>
<td>qfloat16</td>
<td></td>
<td>2</td>
</tr>
</tbody></table>
<p>其中 qreal 缺省是 8 字节 double 类型浮点数，如果 Qt 使用 -qreal float 选项进行配置，就是 4 字节 float 类型的浮点数。 qfloat16 是 Qt 5.9.0 中新增的一个类，用于表示 16 位的浮点数，要使用 qfloat16，需要包含头文件 <QFloat16>。</p>
<h2 id="全局函数定义"><a href="#全局函数定义" class="headerlink" title="全局函数定义"></a>全局函数定义</h2><p><QtGlobal> 头文件包含一些常用函数的定义，这些函数多以模板类型作为参数，返回相应的模板类型，模板类型可以用任何其他类型替换。若是以 double 或 float 类型数作为参数的，一般有两个参数版本的同名函数，如qFuzzyIsNull(double d) 和 qFuzzyIsNull(float f)。 表 2 是 <QtGlobal> 中常用的全局函数定义，列出了函数的输入和输出参数（若存在 double 和 float 两种参数版本，只列出 double 类型参数的版本）。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>T qAbs(const T &amp;value)</td>
<td>返回变量 value 的绝对值</td>
</tr>
<tr>
<td>const T &amp;qBound(const T &amp;min, const T&amp;value, const T &amp;max)</td>
<td>返回 value 限定在 min 至 max 范围之内的値</td>
</tr>
<tr>
<td>bool qFuzzyComparc(doublc p1, double p2)</td>
<td>若 p1 和 p2 近似相等，返回 true</td>
</tr>
<tr>
<td>bool qFuzzyIsNulI(double d)</td>
<td>如果参数 d 约等于 0，返回 true</td>
</tr>
<tr>
<td>double qInf(()</td>
<td>返回无穷大的数</td>
</tr>
<tr>
<td>bool qIsFinite(double d)</td>
<td>若 d 是一个有限的数，返回 true</td>
</tr>
<tr>
<td>bool qIsInf(double d)</td>
<td>若 d 是一个无限大的数，返回 true</td>
</tr>
<tr>
<td>bool qIsNaN(double d)</td>
<td>若 d 不是一个数，返回 true</td>
</tr>
<tr>
<td>constT&amp;qMax(const T&amp;value1, const T&amp;value2)</td>
<td>返回 value1 和 value2 中较大的值</td>
</tr>
<tr>
<td>const T &amp;qMin(const T&amp;value1, const T&amp;value2)</td>
<td>返回 value1 和 value2 中较小的值</td>
</tr>
<tr>
<td>qint64 qRound64(double value)</td>
<td>将 value 近似为最接近的 qint64 整数</td>
</tr>
<tr>
<td>int qRound(double value)</td>
<td>将 value 近似为最接近的 int 整数</td>
</tr>
<tr>
<td>int qrand()</td>
<td>标准 <a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a> 中 rand() 函数的线程安全型版本，返回 0 至 RAND_MAX 之间的伪随机数</td>
</tr>
<tr>
<td>void qsrand(uint seed)</td>
<td>标准 C++ 中 srand() 函数的线程安全型版本，使用种子 seed 对伪随机数字序列初始化</td>
</tr>
</tbody></table>
<p>还有一些基础的数学运算函数在 <QtMath> 头文件中定义，比如三角运算函数、弧度与角度之间的转换函数等。</p>
<h2 id="全局宏定义"><a href="#全局宏定义" class="headerlink" title="全局宏定义"></a>全局宏定义</h2><p><QtGlobal>中文件中定义了很多宏，以下一些是比较常用的：</p>
<ul>
<li><p>QT_VERSION：这个宏展开为数值形式 0xMMNNPP (MM &#x3D; major, NN &#x3D; minor, PP &#x3D; patch) 表示 Qt 编译器版本，例如 Qt 编译器版本为 Qt 5.9.1，则 QT_VERSION 为 0x050901。这个宏常用于条件编译设置，根据 Qt 版本不同，编译不同的代码段。</p>
</li>
<li><p>QT_VERSION_CHECK：这个宏展开为 Qt 版本号的一个整数表示，例如：</p>
</li>
<li><p>QT_VERSION_STR：这个宏展开为 Qt 版本号的字符串，如“5.9.0”。</p>
</li>
<li><p>Q_BYTE_ORDER、Q_BIG_ENDIAN 和 Q_LITTLE_ENDIAN：Q_BYTE_ORDER 表示系统内存中数据的字节序，Q_BIG_ENDIAN 表示大端字节序，Q_LITTLE_ ENDIAN 表示小端字节序。在需要判断系统字节序时会用到，例如：</p>
</li>
<li><p>Q_DECL_IMPORT 和 Q_DECL_EXPORT：在使用或设计共享库时，用于导入或导出库的内容，后续章节有其使用实例。</p>
</li>
<li><p>Q_DECL_OVERRIDE：在类定义中，用于重载一个虚函数，例如在某个类中重载虚函数 paintEvem()，可以定义如下：</p>
</li>
</ul>
<p>void paintEvent(QPaintEvent*) Q_DECL_OVERRIDE;</p>
<p>使用 Q_DECL_OVERRIDE 宏后，如果重载的虚函数没有进行任何重载操作，编译器将会报错。</p>
<ul>
<li><p>Q_DECL_FINAL：这个宏将一个虚函数定义为最终级别，不能再被重载，或定义一个类不能再被继承，示例如下：</p>
</li>
<li><p>Q_UNUSED(name)：这个宏用于在函数中定义不在函数体里使用的参数，示例如下： 在这个函数里，id 参数没有使用。如果不用 QJJNUSED(id) 定义，编译器会出现参数未使用的警告。</p>
</li>
<li><p>foreach(variable, container)：foreach 用于容器类的遍历，例如：</p>
</li>
<li><p>forever：forever用于构造一个无限循环，例如：</p>
</li>
<li><p>qDebug(const char * message,…）：在debugger窗体显示信息，如果编译器设置了 Qt_NO_DEBUG_OUTPUT，则不作任何输出，例如：</p>
</li>
</ul>
<p>qDebug(“Items in list: %d”, myList.size());</p>
<p>类似的宏还有 qWarning、qCritical、qFatal、qInfo 等，也是用于在 debugger 窗体显示信息。</p>
<ol start="17">
<li>Qt顺序容器类和关联容器类详解</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/qt/">Qt</a>提供了多个基于模板的容器类，这些容器类可以用于存储指定类型的数据项，例如常用的字符串列表类 QStringList 就是从容器类 QLiSt<QString> 继承的，实现对字符串列表的添加、存储、删除等操作。 Qt 的容器类比标准模板库（<a target="_blank" rel="noopener" href="http://c.biancheng.net/stl/">STL</a>）中的容器类更轻巧、安全和易于使用。这些容器类是隐式共享和可重入的，而且它们进行了速度和存储优化，因此可以减少可执行文件的大小。此外，它们还是线程安全的，也就是说它们作为只读容器时可被多个线程访问。 容器类是基于模板的类，如常用的容器类 QList<T>，T 是一个具体的类型，可以是 int、float 等简单类型，也可以是 Qstring、QDate 等类，但不能是 QObject 或任何其子类。T 必须是一个可赋值的类型，即T必须提供一个缺省的构造函数，一个可复制构造函数和一个赋值运算符。 例如用 QList<T> 定义一个字符串列表的容器，其定义方法是：</p>
<p>QList<QString> aList;</p>
<p>这样定义了一个 QList 容器类的变量 aList，它的数据项是 QString，所以 aList 可以用于处理字符串列表，例如：</p>
<p>aList.append(“Monday”); aList.append(“Tuesday”); aList.append(“Wednesday”); QString str&#x3D;aList[0];</p>
<p>Qt 的容器类分为顺序容器和关联容器。</p>
<h2 id="顺序容器类"><a href="#顺序容器类" class="headerlink" title="顺序容器类"></a>顺序容器类</h2><p>Qt 的顺序容器类有 QList、QLinkedList、QVector、QStack 和 QQueue。</p>
<h4 id="QList"><a href="#QList" class="headerlink" title="QList"></a>QList</h4><p>QList 是最常用的容器类，虽然它是以数组列表的形式实现的，但是在其前或后添加数据非常快，QList 以下标索引的方式对数据项进行访问。 QList 用于添加、插入、替换、移动、删除数据项的函数有：insert()、replace()、removeAt()、move()、swap()、append()、prepend()、removeFirst() 和 removeLast() 等。 QList 提供下标索引方式访问数据项，如同数组一样，也提供 at() 函数，例如：</p>
<p>QList<QString> list; list &lt;&lt; “one” &lt;&lt; “two” &lt;&lt; “three”; QString str1&#x3D;list[1]; &#x2F;&#x2F;str1&#x3D;&#x3D;”two” QString str0&#x3D;list.at(0); &#x2F;&#x2F;str0&#x3D;&#x3D;”one”</p>
<p>QList 的 isEmpty() 函数在数据项为空时返回 true，size() 函数返回数据项的个数。 QList 是 Qt 中最常用的容器类，很多函数的参数传递都是采用 QList 容器类，例如 QAudioDeviceInfo 的静态函数 availableDevices() 的函数原型是：</p>
<p>QList<QAudioDeviceInfo> QAudioDeviceInfo::availableDevices(QAudio::Mode mode)</p>
<p>其返回数据就是 QAudioDeviceInfo 类型的 QList 列表。</p>
<h4 id="QLinkedList"><a href="#QLinkedList" class="headerlink" title="QLinkedList"></a>QLinkedList</h4><p>QLinkedList<T> 是链式列表，数据项不是用连续的内存存储的，它基于迭代器访问数据项，并且插入和删除数据项的操作时间相同。 除了不提供基于下标索引的数据项访问外，QLinkedList 的其他接口函数与 QList 基本相同。</p>
<h4 id="QVector"><a href="#QVector" class="headerlink" title="QVector"></a>QVector</h4><p>QVector<T> 提供动态数组的功能，以下标索引访问数据。 QVector 的函数接口与 QList 几乎完全相同，QVector<T> 的性能比 QList<T> 更高，因为 QVector<P> 的数据项是连续存储的。</p>
<h4 id="QStack"><a href="#QStack" class="headerlink" title="QStack"></a>QStack</h4><p>QStack<T> 是提供类似于堆栈的后入先出（LIFO）操作的容器类，push() 和 pop() 是主要的接口函数。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QStack&lt;int&gt; stack;stack.push(10);stack.push(20);stack.push(30);while (!stack.isEmpty())    cout &lt;&lt; stack.pop() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>程序会依次输出 30, 20, 10。</p>
<h4 id="QQueue"><a href="#QQueue" class="headerlink" title="QQueue"></a>QQueue</h4><p>QQueue<T> 是提供类似于队列先入先出（FIFO）操作的容器类。enqueue() 和 dequeue() 是主要操作函数。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QQueue&lt;int&gt; queue;queue.enqueue (10);queue.enqueue(20);queue.enqueue (30);while (!queue.isEmpty())    cout &lt;&lt; queue.dequeue() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>程序会依次输出 10, 20，30。</p>
<h2 id="关联容器类"><a href="#关联容器类" class="headerlink" title="关联容器类"></a>关联容器类</h2><p>Qt 还提供关联容器类 QMap、QMultiMap、QHash、QMultiHash 和 QSet。 QMultiMap 和 QMultiHash 支持一个键关联多个值，QHash 和 QMultiHash 类使用散列函数进行查找，查找速度更快。</p>
<h4 id="QSet"><a href="#QSet" class="headerlink" title="QSet"></a>QSet</h4><p>QSet 是基于散列表的集合模板类，它存储数据的顺序是不定的，查找值的速度非常快。 QSet<T> 内部就是用 QHash 实现的。 定义 QSet<T> 容器和输入数据的实例代码如下：</p>
<p>QSet<QString> set; set &lt;&lt; “dog” &lt;&lt; “cat” &lt;&lt; “tiger”;</p>
<p>测试一个值是否包含于这个集合，用 contains() 函数，示例如下：</p>
<p>if (!set.contains(“cat”))    …    </p>
<h4 id="QMap"><a href="#QMap" class="headerlink" title="QMap"></a>QMap</h4><p>QMap&lt;Key, T&gt; 提供一个字典（关联数组)，一个键映射到一个值。QMap 存储数据是按照键的顺序，如果不在乎存储顺序，使用 QHash 会更快。 定义 QMap&lt;QString，int&gt; 类型变量和赋值的示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;QString, int&gt; map;map[&quot;one&quot;] = 1;map[&quot;two&quot;] = 2;map[&quot;three &quot;] = 3;</span><br></pre></td></tr></table></figure>

<p>也可以使用 insert() 函数赋值，或 remove() 移除一个键值对，示例如下：</p>
<p>map.insert(“four”, 4); map.remove(“two”);</p>
<p>要查找一个值，使用运算符“[]”或 value() 函数，示例如下：</p>
<p>int num1 &#x3D; map[“one”]; int num2 &#x3D; map.value(“two”);</p>
<p>如果在映射表中没有找到指定的键，会返回一个缺省构造值，例如，如果值的类型是字符串，会返回一个空的字符串。 在使用 value() 函数查找键值时，还可以指定一个缺省的返回值，示例如下：</p>
<p>timeout &#x3D; map.value(“TIMEOUT”,30);</p>
<p>这表示如果在 map 里找到键“TIMEOUT”，就返回关联的值，否则返回值为 30。</p>
<h4 id="QMultiMap"><a href="#QMultiMap" class="headerlink" title="QMultiMap"></a>QMultiMap</h4><p>QMultiMap 是 QMap 的子类，是用于处理多值映射的便利类。 多值映射就是一个键可以对应多个值。QMap 正常情况下不允许多值映射，除非使用 QMap::insertMulti() 添加键值对。 QMultiMap 是 QMap 的子类，所以 QMap 的大多数函数在 QMultiMap 都是可用的，但是有几个特殊的，QMultiMap::insert() 等效于 QMap::insertMulti() , QMultiMap::replace() 等效于 QMap::insert()。 QMultiMap 使用示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMultiMap&lt;QString, int&gt; map1, map2, map3;map1.insert(&quot;plenty&quot;, 100);mapl.insert(&quot;plenty&quot;, 2000); // map1.size() == 2map2.insert(&quot;plenty&quot;, 5000); // map2.size() == 1map3 = map1 + map2; // map3.size() == 3</span><br></pre></td></tr></table></figure>

<p>QMultiMap 不提供“[]”操作符，使用 value() 函数访问最新插入的键的单个值。如果要获取一个键对应的所有值，使用 values() 函数，返回值是 QList<T> 类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;int&gt; values = map.values(&quot;plenty&quot;);</span><br><span class="line">for (int i = 0; i &lt; values.size(); ++i)</span><br><span class="line">    cout &lt;&lt; values.at(i) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h4 id="QHash"><a href="#QHash" class="headerlink" title="QHash"></a>QHash</h4><p>QHash 是基于散列表来实现字典功能的模板类，QHash&lt;Key，T&gt; 存储的键值对具有非常快的查找速度。 QHash 与 QMap 的功能和用法相似，区别在于以下几点：</p>
<ol>
<li><p>QHash 比 QMap 的查找速度快；</p>
</li>
<li><p>在 QMap 上遍历时，数据项是按照键排序的，而 QHash 的数据项是任意顺序的；</p>
</li>
<li><p>QMap 的键必须提供“&lt;”运算符，QHash 的键必须提供“&#x3D;&#x3D;”运算符和一个名称为 qHash() 的全局散列函数。</p>
</li>
</ol>
<h4 id="QMultiHash"><a href="#QMultiHash" class="headerlink" title="QMultiHash"></a>QMultiHash</h4><p>QMultiHash 是 QHash 的子类，是用于处理多值映射的便利类，其用法与 QMultiMap 类似。</p>
<ol start="18">
<li>Qt迭代器（Java类型和STL类型）详解</li>
</ol>
<p>迭代器为访问容器类里的数据项提供了统一的方法，<a target="_blank" rel="noopener" href="http://c.biancheng.net/qt/">Qt</a>有两种迭代器类：<a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a>类型的迭代器和 <a target="_blank" rel="noopener" href="http://c.biancheng.net/stl/">STL</a>类型的迭代器。 两者比较，Java 类型的迭代器更易于使用，且提供一些高级功能，而 STL 类型的迭代器效率更高。</p>
<h2 id="Java-类型迭代器"><a href="#Java-类型迭代器" class="headerlink" title="Java 类型迭代器"></a>Java 类型迭代器</h2><p>对于每个容器类，有两个 Java 类型迭代器：一个用于只读操作，一个用于读写操作，各个Java 类型的容器类见表 1。</p>
<table>
<thead>
<tr>
<th>容器类</th>
<th>只读迭代器</th>
<th>读写迭代器</th>
</tr>
</thead>
<tbody><tr>
<td>QList<T>, QQueue<T></td>
<td>QListItcrator<T></td>
<td>QMutableListItcrator<T></td>
</tr>
<tr>
<td>QLinkedList<T></td>
<td>QLinkedListIterator<T></td>
<td>QMutableLinkedListIterator<T></td>
</tr>
<tr>
<td>QVector<T>, QStack<T></td>
<td>QVectorllcrator<T></td>
<td>QMutableVectorIterator<T></td>
</tr>
<tr>
<td>QSet<T></td>
<td>QSetItcrator<T></td>
<td>QMutableSetItcrator<T></td>
</tr>
<tr>
<td>QMap&lt;Key, T&gt;, QMultiMap&lt;Key, T&gt;</td>
<td>QMapIterator&lt;Key, T&gt;</td>
<td>QMutableMapIterator&lt;Key, T&gt;</td>
</tr>
<tr>
<td>QHash&lt;Key, T&gt;, QMultiHash&lt;Key, T&gt;</td>
<td>QHashIterator&lt;Key, T&gt;</td>
<td>QMutablcHashlterator&lt;Key, T&gt;</td>
</tr>
</tbody></table>
<p>QMap 和 QHash 等关联容器类的迭代器用法相冋，QList 和 QLinkedList、QSet 等容器类的用法相同，所以下面只以 QMap 和 QList 为例介绍迭代器的用法。</p>
<h4 id="顺序容器类的迭代器的使用"><a href="#顺序容器类的迭代器的使用" class="headerlink" title="顺序容器类的迭代器的使用"></a>顺序容器类的迭代器的使用</h4><p>Java 类型迭代器的指针不是指向一个数据项，而是在数据项之间，迭代器指针位置示意图如图 2 所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/398b8619-7ab1-4399-bfb3-a5180e8e3b12.gif" alt="image">图 2 Java类型迭代器位置示意图</p>
<p>下面是遍历访问一个 QList<QString> 容器的所有数据项的典型代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; list;list &lt;&lt; &quot;A&quot; &lt;&lt; &quot;B&quot; &lt;&lt; &quot;C&quot; &lt;&lt; &quot;D&quot;;QListIterator&lt;QString&gt; i (list);while (i.hasNext())    qDebug () &lt;&lt; i.next ();</span><br></pre></td></tr></table></figure>

<p>QList<QString> 容器对象 list 作为参数传递给 QListIterator<QString> 迭代器 i 的构造函数，i 用于对 list 作只读遍历。起始时刻，迭代器指针在容器第一个数据项的前面（图 2 中数据项“A” 的前面)，调用 hasNext() 判断在迭代器指针后面是否还有数据项，如果有，就调用 next() 跳过一个数据项，并且 next() 函数返回跳过去的那个数据项。 也可以反向遍历，示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QListIterator&lt;QString&gt; i (list);i.toBack();while (i.hasPrevious())    qDebug() &lt;&lt; i.previous();</span><br></pre></td></tr></table></figure>

<p>QListItemtor 用于移动指针和读取数据的函数见表 3。</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>void toFront()</td>
<td>迭代器移动到列表的最前面（第一个数据项之前)</td>
</tr>
<tr>
<td>void toBack()</td>
<td>迭代器移动到列表的最后面（最后一个数据项之后）</td>
</tr>
<tr>
<td>bool hasNext()</td>
<td>如果迭代器不是位于列表最后位罝，返回true</td>
</tr>
<tr>
<td>const T&amp; next()</td>
<td>返回下一个数据项，并且迭代器后移一个位置</td>
</tr>
<tr>
<td>const T&amp; peekNext()</td>
<td>返回下一个数据项，但是不移动迭代器位置</td>
</tr>
<tr>
<td>bool hasPrevious()</td>
<td>如果迭代器不是位于列表的最前面，返回true</td>
</tr>
<tr>
<td>const T&amp; previous()</td>
<td>返回前一个数据项，并且迭代器前移一个位置</td>
</tr>
<tr>
<td>const T&amp; peekPrevious()</td>
<td>返回前一个数椐项，但是不移动迭代器指针</td>
</tr>
</tbody></table>
<p>QListIterator 是只读访问容器内数据项的迭代器，若要在遍历过程中对容器的数据进行修改， 需要使用 QMutableListlterator。例如下面的示例代码为删除容器中数据为奇数的项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;int&gt; list;list &lt;&lt;1&lt;&lt;2&lt;&lt;3&lt;&lt;4&lt;&lt;5;QMutableListIterator&lt;int&gt; i (list);while (i.hasNext()) &#123;    if (i.next() % 2 != 0)        i.remove();&#125;</span><br></pre></td></tr></table></figure>

<p>remove() 函数移除 next() 函数刚刚跳过的一个数据项，不会使迭代器失效。setValue() 函数可以修改刚刚跳过去的数据项的值。</p>
<h4 id="关联容器类的迭代器的使用"><a href="#关联容器类的迭代器的使用" class="headerlink" title="关联容器类的迭代器的使用"></a>关联容器类的迭代器的使用</h4><p>对于关联容器类 QMap<Key T>，使用 QMapIterator 和 QMutableMapIterator 迭代器类，它们具有表 3 所示的所有函数，主要是增加了 key() 和 value() 函数用于获取刚刚跳过的数据项的键和值。 例如，下面的代码将删除键（城市名称）里以“City”结尾的数据项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;QString, QString&gt; map;map.insert(&quot;Paris&quot;, &quot;France&quot;);map.insert(&quot;New York&quot;, &quot;USA&quot;);map.insert(&quot;Mexico City&quot;, &quot;USA&quot;);map.insert(&quot;Moscow&quot;, &quot;Russia&quot;);...QMutableMapIterator&lt;QString, QString&gt; i(map);while (i.hasNext ()) &#123;    if (i.next().key().endsWith(&quot;City&quot;))        i.remove();&#125;</span><br></pre></td></tr></table></figure>

<p>如果是在多值容器里遍历，可以用 findNext() 或 findPrevious() 查找下一个或上一个值，如下面的代码将删除上一示例代码中 map 里值为“USA”的所有数据项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMutableMapIterator&lt;QString, QString&gt; i(map);、while (i.findNext(&quot;USA&quot;))    i.remove();</span><br></pre></td></tr></table></figure>

<h2 id="STL类型迭代器"><a href="#STL类型迭代器" class="headerlink" title="STL类型迭代器"></a>STL类型迭代器</h2><p>STL 迭代器与 Qt 和 STL 的原生算法兼容，并且进行了速度优化。具体类型见表 4。</p>
<table>
<thead>
<tr>
<th>容器类</th>
<th>只读迭代器</th>
<th>读写迭代器</th>
</tr>
</thead>
<tbody><tr>
<td>QList<T>, QQueue<T></td>
<td>QList<T>::const iterator</td>
<td>QList<T>::iterator</td>
</tr>
<tr>
<td>QLinkedList<T></td>
<td>Q1. i nked List&lt;1&gt;: :const_iterator</td>
<td>QLinkedList<T>::iterator</td>
</tr>
<tr>
<td>QVector<T>, QStack<T></td>
<td>QVector<T>::const_ilerator</td>
<td>QVector<T>::iterator</td>
</tr>
<tr>
<td>QSet<T></td>
<td>QSet<T>::const_iterator</td>
<td>QSet<T>::iterator</td>
</tr>
<tr>
<td>QMap&lt;Key, P&gt; QMultiMap&lt;Kcy, T&gt;</td>
<td>QMap&lt;Key, T&gt;::const_iterator</td>
<td>QMap&lt;Key, T&gt;:: iterator</td>
</tr>
<tr>
<td>QHash&lt;Key, T&gt; QMultiHash&lt;Key, T&gt;</td>
<td>QHash&lt;Key, T&gt;: :const_iterator</td>
<td>QHash&lt;Key, T&gt;::iterator</td>
</tr>
</tbody></table>
<p>对于每一个容器类，都有两个 STL 类型迭代器：一个用于只读访问，一个用于读写访问。无需修改数据时一定使用只读迭代器，因为它们速度更快。 注意，在定义只读迭代器和读写迭代器时的区别，它们使用了不同的关健字，const_iterator 定义只读迭代器，iterator 定义读写迭代器。此外，还可以使用 const_reverse_iterator 和 reverse_iterator 定义相应的反尚迭代器。 STL 类型的迭代器是数组的指针，所以“++”运算符使迭代器指向下一个数据项，运算符返回数据项内容。与 Java 类型的迭代器不同，STL 迭代器直接指向数据项，STL 迭代器指向位置示意图如图 5 所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/collab/32M9qPzB3v9pl015/c486641f-de42-4a34-8a8f-93c7d19b75b3.gif" alt="image">图 5 STL类型迭代器位置示意图</p>
<p>begin() 函数使迭代器指向容器的第一个数据项，end() 函数使迭代器指向一个虚拟的表示结尾的数据项，end() 表示的数据项是无效的，一般用作循环结束条件。 下面仍然以 QList 和 QMap 为例说明 STL 迭代器的用法，其他容器类迭代器的用法类似。</p>
<h4 id="顺序容器类的迭代器的用法"><a href="#顺序容器类的迭代器的用法" class="headerlink" title="顺序容器类的迭代器的用法"></a>顺序容器类的迭代器的用法</h4><p>下面的示例代码将 QList<QString> list 里的数据项逐项输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; list;list &lt;&lt; &quot;A&quot; &lt;&lt; &quot;B&quot; &lt;&lt; &quot;C&quot; &lt;&lt; &quot;D&quot;;QList&lt;QString&gt;::const_iterator i;for (i = list.constBegin(); i != list.constEnd(); ++i)    qDebug() &lt;&lt; *i;</span><br></pre></td></tr></table></figure>

<p>constBegin() 和 constEnd() 是用于只读迭代器的，表示起始和结束位置。 若使用反向读写迭代器，并将上面示例代码中 list 的数据项都改为小写，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt;::reverse_iterator i;for (i = list.rbegin(); i != list.rend(); ++i)    *i = i-&gt;toLower();&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关联容器类的迭代器的用法"><a href="#关联容器类的迭代器的用法" class="headerlink" title="关联容器类的迭代器的用法"></a>关联容器类的迭代器的用法</h4><p>对于关联容器类 QMap 和 QHash，迭代器的操作符返回数据项的值。如果想返回键，使用 key() 函数。对应的，用 value() 函数返回一个项的值。 例如，下面的代码将 QMap&lt;int，int&gt; map 中所有项的键和值输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;int, int&gt; map;...QMap&lt;int, int&gt;::const_iterator i;for (i = map.constBegin(); i != map.constEnd(); ++i)    qDebug () &lt;&lt; i.key () &lt;&lt; &#x27;:&#x27; &lt;&lt; i.value ();</span><br></pre></td></tr></table></figure>

<p>Qt API 包含很多返回值为 QList 或 QStringList 的函数，要遍历这些返回的容器，必须先复制。由于 Qt 使用了隐式共享，这样的复制并无多大开销。 例如，下面的代码是正确的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const QList&lt;int&gt; sizes = splitter-&gt;sizes();QList&lt;int&gt;::const_iterator i;for (i = sizes.begin (); i != sizes.end(); ++i)    ...</span><br></pre></td></tr></table></figure>

<p>提示：隐式共享是对象的管理方法。一个对象被隐式共享，只是传递该对象的一个指针给使用者，而不实际复制对象数据，只有在使用者修改数据时，才实质复制共享对象给使用者。如在上面的代码中，splitter-&gt;sizes() 返回的是一个 QList<int>M 表对象 sizes，但是实际上代码并不将 splitter-&gt;sizes() 表示的列表内容完全复制给变量 sizes，只是传递给它一个指针，只有当 sizes 发生数据修改时，才会将共享对象的数据复制给 sizes，这样避免了不必要的复制，减少了资源占用。</p>
<p>而下面的代码是错误的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;int&gt;::const_iterator i;for (i = splitter-&gt;sizes().begin(); i != splitter-&gt;sizes().end(); ++i)</span><br></pre></td></tr></table></figure>

<p>对于 STL 类型的迭代器，隐式共享还涉及另外一个问题，即当有一个迭代器在操作一个容器变量时，不要去复制这个容器变量。</p>
<ol start="19">
<li>Qt foreach关键字用法（无师自通）</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/qt/">Qt</a>提供一个关键字 foreach (实际是 <QtGlobal> 里定义的一个宏）用于方便地访问容器里所有数据项。 foreach 关键字用于遍历容路中所有的项，使用 foreach 的句法是：</p>
<p>foreach (variable, container)</p>
<p>使用 foreach 的代码比使用迭代器更简洁。例如，使用 foreach 遍历一个 QLinkedList<QString> 的示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QLinkedList&lt;QString&gt; list;...QString str;foreach (str, list)    qDebug() &lt;&lt; str;</span><br></pre></td></tr></table></figure>

<p>用于迭代的变量也可以在 foreach 语句里定义，foreach 语句也可以使用花括号，可以使用 break 退出迭代，示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QLinkedList&lt;QString&gt; list;...foreach (const QString &amp;str, list) &#123;    if (str.isEmpty())        break;    qDebug() &lt;&lt; str;&#125;</span><br></pre></td></tr></table></figure>

<p>对于 QMap 和 QHash，foreach 会自动访问“键-值”对里的值，所以无需调用 values()。如果需要访问键则可以调用 keys()，示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;QString, int&gt; map;...foreach (const QString &amp;str, map.keys())    qDebug() &lt;&lt; str &lt;&lt; &#x27;:&#x27; &lt;&lt; map.value(str);</span><br></pre></td></tr></table></figure>

<p>对于多值映射，可以使用两重 foreach 语句，示例代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMultiMap&lt;QString, int&gt; map;...foreach (const QString &amp;str, map.uniqueKeys()) &#123;    foreach (int i, map.values(str))        qDebug() &lt;&lt; str &lt;&lt; &#x27;:&#x27; &lt;&lt; i;&#125;</span><br></pre></td></tr></table></figure>

<p>注意，foreach 关徤字遍历一个容器变量是创建了容器的一个副本，所以不能修改原来容器变量的数据项。</p>
<ol start="20">
<li><p>编写第一个Qt程序</p>
</li>
<li><p>编写第一个Qt程序</p>
</li>
<li><p>编写第一个Qt程序</p>
</li>
<li><p>编写第一个Qt程序</p>
</li>
<li><p>编写第一个Qt程序</p>
</li>
</ol>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">OQS</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://cpp-memory-leaks.github.io/2024/09/13/QT%E8%AF%A6%E8%A7%A3/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://cpp-memory-leaks.github.io/2024/09/13/QT%E8%AF%A6%E8%A7%A3/')">QT详解</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://cpp-memory-leaks.github.io/2024/09/13/QT%E8%AF%A6%E8%A7%A3/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=QT详解&amp;url=https://cpp-memory-leaks.github.io/2024/09/13/QT%E8%AF%A6%E8%A7%A3/&amp;pic=https://raw.githubusercontent.com/cpp-memory-leaks/cpp-memory-leaks.github.io/refs/heads/master/img/qt_default_cover.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Qt/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Qt<span class="tagsPageCount">6</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/img/cpp_default_cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/08/07/Cpp%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/cpp_default_cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">C++代码规范</div></div></a></div><div class="next-post pull-right"><a href="/2024/11/07/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%91%87%E6%9D%86/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/cpp-memory-leaks/cpp-memory-leaks.github.io/refs/heads/master/img/qt_default_cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">自定义摇杆</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2024/12/25/QCheckBox%E7%9A%84%E4%B8%89%E6%80%81%E5%A4%8D%E9%80%89%E6%A1%86%E5%92%8C%E5%8F%8D%E9%80%89/" title="QCheckBox的三态复选框和反选"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/cpp-memory-leaks/cpp-memory-leaks.github.io/refs/heads/master/img/qt_default_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-12-25</div><div class="title">QCheckBox的三态复选框和反选</div></div></a></div><div><a href="/2024/12/25/Qt%E4%BD%BF%E7%94%A8libheif%E5%BA%93%E6%98%BE%E7%A4%BA%E8%8B%B9%E6%9E%9C%E7%9A%84heic%E5%9B%BE%E7%89%87/" title="Qt使用libheif库显示苹果的heic图片"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/cpp-memory-leaks/cpp-memory-leaks.github.io/refs/heads/master/img/qt_default_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-12-25</div><div class="title">Qt使用libheif库显示苹果的heic图片</div></div></a></div><div><a href="/2025/09/13/%E7%BB%99%E7%A8%8B%E5%BA%8F%E8%B5%8B%E4%BA%88%E2%80%9C%E7%8A%B6%E6%80%81%E2%80%9D%E6%80%9D%E7%BB%B4-%E8%81%8A%E8%81%8AQt%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%A5%87%E5%A6%99%E4%B8%96%E7%95%8C/" title="给程序赋予“状态”思维：聊聊Qt状态机的奇妙世界"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/cpp-memory-leaks/cpp-memory-leaks.github.io/refs/heads/master/img/qt_default_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-09-13</div><div class="title">给程序赋予“状态”思维：聊聊Qt状态机的奇妙世界</div></div></a></div><div><a href="/2024/12/17/Qt%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%97%E8%A1%A8%E6%8E%A7%E4%BB%B6%E4%B9%8BQListView%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E4%BC%98%E7%82%B9/" title="Qt高性能列表控件之QListView的使用及优点"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/cpp-memory-leaks/cpp-memory-leaks.github.io/refs/heads/master/img/qt_default_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-12-17</div><div class="title">Qt高性能列表控件之QListView的使用及优点</div></div></a></div><div><a href="/2025/01/22/Qt%E4%B8%AD%E5%90%84%E7%A7%8D%E5%9B%BE%E5%83%8F%E7%9A%84%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%BB%A5%E5%8F%8A%E4%B8%8Ecv-Mat%E5%9B%BE%E5%83%8F%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%BD%AC%E6%8D%A2/" title="Qt中各种图像的格式转换以及与cv::Mat图像格式之间的转换"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/cpp-memory-leaks/cpp-memory-leaks.github.io/refs/heads/master/img/qt_default_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-22</div><div class="title">Qt中各种图像的格式转换以及与cv::Mat图像格式之间的转换</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(null) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#QT%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">QT详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GNU-%E5%B7%A5%E5%85%B7%E9%9B%86-%E5%9C%A8-GNU-%E5%B7%A5%E5%85%B7%E9%9B%86%E9%87%8C%E9%9D%A2%EF%BC%8C%E5%BC%80%E5%8F%91%E6%97%B6%E5%B8%B8%E8%A7%81%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E7%BD%97%E5%88%97%E5%A6%82%E4%B8%8B%EF%BC%88%E8%BF%99%E4%BA%9B%E5%B7%A5%E5%85%B7%E9%80%9A%E5%B8%B8%E4%BD%8D%E4%BA%8E-Linux-%E6%88%96-Unix-%E7%B3%BB%E7%BB%9F%E9%87%8C%E7%9A%84-usr-bin-%E7%9B%AE%E5%BD%95%EF%BC%89%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">GNU 工具集 在 GNU 工具集里面，开发时常见到的几个罗列如下（这些工具通常位于 Linux 或 Unix 系统里的 &#x2F;usr&#x2F;bin&#x2F; 目录）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MinGW"><span class="toc-number">1.2.</span> <span class="toc-text">MinGW</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MSYS%EF%BC%88Minimal-SYStem%EF%BC%89"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">MSYS（Minimal SYStem）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CMake"><span class="toc-number">1.3.</span> <span class="toc-text">CMake</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt-%E5%B7%A5%E5%85%B7%E9%9B%86"><span class="toc-number">1.4.</span> <span class="toc-text">Qt 工具集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Project"><span class="toc-number">1.5.</span> <span class="toc-text">Project</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Makefile"><span class="toc-number">1.6.</span> <span class="toc-text">Makefile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Debug-%E5%92%8C-Release"><span class="toc-number">1.7.</span> <span class="toc-text">Debug 和 Release</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11-%E6%A0%87%E5%87%86"><span class="toc-number">1.8.</span> <span class="toc-text">C++11 标准</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dynamic-Link-%E5%92%8C-Static-Link"><span class="toc-number">1.9.</span> <span class="toc-text">Dynamic Link 和 Static Link</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93"><span class="toc-number">1.9.0.1.</span> <span class="toc-text">动态链接库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93"><span class="toc-number">1.9.0.2.</span> <span class="toc-text">静态链接库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%93%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80"><span class="toc-number">1.9.0.3.</span> <span class="toc-text">库文件后缀</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Explicit-Linking-%E5%92%8C-Implicit-Linking"><span class="toc-number">1.10.</span> <span class="toc-text">Explicit Linking 和 Implicit Linking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt-Creator-%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.11.</span> <span class="toc-text">Qt Creator 的设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.12.</span> <span class="toc-text">新建一个项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%96%87%E4%BB%B6%E7%BB%84%E6%88%90%E5%92%8C%E7%AE%A1%E7%90%86"><span class="toc-number">1.13.</span> <span class="toc-text">项目的文件组成和管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BC%96%E8%AF%91%E3%80%81%E8%B0%83%E8%AF%95%E4%B8%8E%E8%BF%90%E8%A1%8C"><span class="toc-number">1.14.</span> <span class="toc-text">项目的编译、调试与运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#widget-h-%E6%96%87%E4%BB%B6"><span class="toc-number">1.15.</span> <span class="toc-text">widget.h 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#namespace-%E5%A3%B0%E6%98%8E"><span class="toc-number">1.15.0.1.</span> <span class="toc-text">namespace 声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Widget-%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.15.0.2.</span> <span class="toc-text">Widget 类的定义</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#widget-cpp-%E6%96%87%E4%BB%B6"><span class="toc-number">1.16.</span> <span class="toc-text">widget.cpp 文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#widget-ui-%E6%96%87%E4%BB%B6"><span class="toc-number">1.17.</span> <span class="toc-text">widget.ui 文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ui-widget-h-%E6%96%87%E4%BB%B6"><span class="toc-number">1.18.</span> <span class="toc-text">ui_widget.h 文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E7%A8%8B%E5%BA%8F%E5%8A%9F%E8%83%BD"><span class="toc-number">1.19.</span> <span class="toc-text">实例程序功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%8C%E9%9D%A2%E7%BB%84%E4%BB%B6%E5%B8%83%E5%B1%80"><span class="toc-number">1.20.</span> <span class="toc-text">界面组件布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%95%8C%E9%9D%A2%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB"><span class="toc-number">1.20.0.1.</span> <span class="toc-text">界面组件的层次关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86"><span class="toc-number">1.20.0.2.</span> <span class="toc-text">布局管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%99%E4%BC%B4%E5%85%B3%E7%B3%BB%E4%B8%8E-Tab-%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.20.0.3.</span> <span class="toc-text">伙伴关系与 Tab 顺序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.21.</span> <span class="toc-text">项目功能实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.21.0.1.</span> <span class="toc-text">字体样式设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.21.0.2.</span> <span class="toc-text">字体颜色设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E6%8C%89%E9%92%AE%E7%9A%84%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.21.0.3.</span> <span class="toc-text">三个按钮的功能设计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8A%9F%E8%83%BD"><span class="toc-number">1.22.</span> <span class="toc-text">实例功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%8C%E9%9D%A2%E5%88%9B%E5%BB%BA"><span class="toc-number">1.23.</span> <span class="toc-text">界面创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#QWDlgManual-%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="toc-number">1.23.0.1.</span> <span class="toc-text">QWDlgManual 类定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%95%8C%E9%9D%A2%E7%BB%84%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%B8%83%E5%B1%80"><span class="toc-number">1.23.0.2.</span> <span class="toc-text">界面组件的创建与布局</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E7%9A%84%E5%85%B3%E8%81%94"><span class="toc-number">1.24.</span> <span class="toc-text">信号与槽的关联</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt-%E7%9A%84%E5%85%83%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.25.</span> <span class="toc-text">Qt 的元对象系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.26.</span> <span class="toc-text">属性系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89"><span class="toc-number">1.26.0.1.</span> <span class="toc-text">属性定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.26.0.2.</span> <span class="toc-text">属性的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%B1%9E%E6%80%A7"><span class="toc-number">1.26.0.3.</span> <span class="toc-text">动态属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF"><span class="toc-number">1.26.0.4.</span> <span class="toc-text">类的附加信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.27.</span> <span class="toc-text">全局变量定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-number">1.28.</span> <span class="toc-text">全局函数定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.29.</span> <span class="toc-text">全局宏定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E7%B1%BB"><span class="toc-number">1.30.</span> <span class="toc-text">顺序容器类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#QList"><span class="toc-number">1.30.0.1.</span> <span class="toc-text">QList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#QLinkedList"><span class="toc-number">1.30.0.2.</span> <span class="toc-text">QLinkedList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#QVector"><span class="toc-number">1.30.0.3.</span> <span class="toc-text">QVector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#QStack"><span class="toc-number">1.30.0.4.</span> <span class="toc-text">QStack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#QQueue"><span class="toc-number">1.30.0.5.</span> <span class="toc-text">QQueue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E7%B1%BB"><span class="toc-number">1.31.</span> <span class="toc-text">关联容器类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#QSet"><span class="toc-number">1.31.0.1.</span> <span class="toc-text">QSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#QMap"><span class="toc-number">1.31.0.2.</span> <span class="toc-text">QMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#QMultiMap"><span class="toc-number">1.31.0.3.</span> <span class="toc-text">QMultiMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#QHash"><span class="toc-number">1.31.0.4.</span> <span class="toc-text">QHash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#QMultiHash"><span class="toc-number">1.31.0.5.</span> <span class="toc-text">QMultiHash</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E7%B1%BB%E5%9E%8B%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.32.</span> <span class="toc-text">Java 类型迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.32.0.1.</span> <span class="toc-text">顺序容器类的迭代器的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.32.0.2.</span> <span class="toc-text">关联容器类的迭代器的使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E7%B1%BB%E5%9E%8B%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.33.</span> <span class="toc-text">STL类型迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.33.0.1.</span> <span class="toc-text">顺序容器类的迭代器的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.33.0.2.</span> <span class="toc-text">关联容器类的迭代器的用法</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/09/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3VisualStudio%E4%B8%ADCXX%E6%88%96Qt%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E5%88%99/" title="深入理解VisualStudio中CXX或Qt项目的编码一致性原则"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/cpp_default_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入理解VisualStudio中CXX或Qt项目的编码一致性原则"/></a><div class="content"><a class="title" href="/2025/09/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3VisualStudio%E4%B8%ADCXX%E6%88%96Qt%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E5%88%99/" title="深入理解VisualStudio中CXX或Qt项目的编码一致性原则">深入理解VisualStudio中CXX或Qt项目的编码一致性原则</a><time datetime="2025-09-13T10:22:31.000Z" title="Created 2025-09-13 18:22:31">2025-09-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/13/%E7%BB%99%E7%A8%8B%E5%BA%8F%E8%B5%8B%E4%BA%88%E2%80%9C%E7%8A%B6%E6%80%81%E2%80%9D%E6%80%9D%E7%BB%B4-%E8%81%8A%E8%81%8AQt%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%A5%87%E5%A6%99%E4%B8%96%E7%95%8C/" title="给程序赋予“状态”思维：聊聊Qt状态机的奇妙世界"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/cpp-memory-leaks/cpp-memory-leaks.github.io/refs/heads/master/img/qt_default_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="给程序赋予“状态”思维：聊聊Qt状态机的奇妙世界"/></a><div class="content"><a class="title" href="/2025/09/13/%E7%BB%99%E7%A8%8B%E5%BA%8F%E8%B5%8B%E4%BA%88%E2%80%9C%E7%8A%B6%E6%80%81%E2%80%9D%E6%80%9D%E7%BB%B4-%E8%81%8A%E8%81%8AQt%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%A5%87%E5%A6%99%E4%B8%96%E7%95%8C/" title="给程序赋予“状态”思维：聊聊Qt状态机的奇妙世界">给程序赋予“状态”思维：聊聊Qt状态机的奇妙世界</a><time datetime="2025-09-13T05:31:47.000Z" title="Created 2025-09-13 13:31:47">2025-09-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/12/C-REST-SDK-cpprestsdk-HTTPS-%E9%80%9A%E4%BF%A1/" title="C++ REST SDK (cpprestsdk) HTTPS 通信"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/cpp_default_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ REST SDK (cpprestsdk) HTTPS 通信"/></a><div class="content"><a class="title" href="/2025/09/12/C-REST-SDK-cpprestsdk-HTTPS-%E9%80%9A%E4%BF%A1/" title="C++ REST SDK (cpprestsdk) HTTPS 通信">C++ REST SDK (cpprestsdk) HTTPS 通信</a><time datetime="2025-09-12T15:30:32.000Z" title="Created 2025-09-12 23:30:32">2025-09-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/08/RAII%E6%80%9D%E6%83%B3/" title="RAII思想"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/cpp_default_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RAII思想"/></a><div class="content"><a class="title" href="/2025/09/08/RAII%E6%80%9D%E6%83%B3/" title="RAII思想">RAII思想</a><time datetime="2025-09-08T14:05:35.000Z" title="Created 2025-09-08 22:05:35">2025-09-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/21/CppRestSDK%E7%BC%96%E8%AF%91ASIO%E7%89%88%E6%9C%AC%E8%BF%87%E7%A8%8B/" title="C++ REST SDK (cpprestsdk)编译ASIO版本过程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/cpp_default_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ REST SDK (cpprestsdk)编译ASIO版本过程"/></a><div class="content"><a class="title" href="/2025/08/21/CppRestSDK%E7%BC%96%E8%AF%91ASIO%E7%89%88%E6%9C%AC%E8%BF%87%E7%A8%8B/" title="C++ REST SDK (cpprestsdk)编译ASIO版本过程">C++ REST SDK (cpprestsdk)编译ASIO版本过程</a><time datetime="2025-08-21T13:25:28.000Z" title="Created 2025-08-21 21:25:28">2025-08-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="OQS" target="_blank">OQS</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = []
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/cpp-memory-leaks" title="博客">博客</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">Articles</div><div class="length-num">13</div></a><a href="/tags/" title="tag"><div class="headline">Tags</div><div class="length-num">5</div></a><a href="/categories/" title="category"><div class="headline">Categories</div><div class="length-num">2</div></a></div><span class="sidebar-menu-item-title">Function</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="Display Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>Display Mode</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://cpp-memory-leaks.github.io" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/cpp-memory-leaks" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>3</sup></a><a href="/tags/C-cpprestsdk-openssl-tls-https/" style="font-size: 0.88rem;">C++ cpprestsdk openssl tls https<sup>1</sup></a><a href="/tags/C-libheif/" style="font-size: 0.88rem;">C++ libheif<sup>1</sup></a><a href="/tags/Qt/" style="font-size: 0.88rem;">Qt<sup>6</sup></a><a href="/tags/Qt-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/" style="font-size: 0.88rem;">Qt 自定义控件<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.cbd.int/@docsearch/css@3.5.2/dist/style.css"/><script src="https://cdn.cbd.int/@docsearch/js@3.5.2/dist/umd/index.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: '',
    apiKey: '',
    indexName: '',
    container: '#docsearch',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    anzhiyu.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 OQS 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>