<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stack Overflow</title>
  
  
  <link href="https://cpp-memory-leaks.github.io/atom.xml" rel="self"/>
  
  <link href="https://cpp-memory-leaks.github.io/"/>
  <updated>2025-03-17T11:59:23.656Z</updated>
  <id>https://cpp-memory-leaks.github.io/</id>
  
  <author>
    <name>OQS</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CodeStyle</title>
    <link href="https://cpp-memory-leaks.github.io/2025/03/17/CodeStyle-1/"/>
    <id>https://cpp-memory-leaks.github.io/2025/03/17/CodeStyle-1/</id>
    <published>2025-03-17T11:59:23.000Z</published>
    <updated>2025-03-17T11:59:23.656Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://cpp-memory-leaks.github.io/2025/01/06/%E6%91%87%E6%9D%86/"/>
    <id>https://cpp-memory-leaks.github.io/2025/01/06/%E6%91%87%E6%9D%86/</id>
    <published>2025-01-06T13:48:21.215Z</published>
    <updated>2024-12-30T06:19:59.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义摇杆"><a href="#自定义摇杆" class="headerlink" title="自定义摇杆"></a>自定义摇杆</h1><p>今天做项目的时候，接到一个需求，需要做一个摇杆去控制物体的移动，功能还是挺复杂的</p><h2 id="1-功能："><a href="#1-功能：" class="headerlink" title="1.功能："></a>1.功能：</h2><ol><li>点击内圈发送一次对应的方向的信号</li><li>松开鼠标的时候如果在内圈就发送结束信号（第一第二点总结起来就是按下跑，松开停）</li><li>松开的时候如果鼠标位置在外圈，就不发送结束信号，一直跑</li><li>点击结束按钮或者内圈范围都会发送信号</li></ol><h3 id="直接上图"><a href="#直接上图" class="headerlink" title="直接上图"></a>直接上图</h3><p>原始状态：</p><p>持续行走状态：</p><h2 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h2><p>DirectionalControl.h头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DIRECTIONALCONTROL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIRECTIONALCONTROL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMouseEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCheckBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPointF&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectionalControl</span> : <span class="keyword">public</span> QWidget &#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">DirectionButton</span></span><br><span class="line">&#123;</span><br><span class="line">UpButton,</span><br><span class="line">DownButton,</span><br><span class="line">LeftButton,</span><br><span class="line">RightButton,</span><br><span class="line">StopButton</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">DirectionalControl</span><span class="params">(QWidget* parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">resetDragPntPos</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendDirectionChanged</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">directionChanged</span><span class="params">(<span class="type">double</span> angle)</span></span>; <span class="comment">// 信号：方向改变</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">startMove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stopMove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handleClick</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent* event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent* event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent* event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent* event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateDragPntDirection</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">keyReleaseEvent</span><span class="params">(QKeyEvent* event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">keyPressEvent</span><span class="params">(QKeyEvent* event)</span><span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> outerRadius = <span class="number">80</span>; <span class="comment">// 外圈半径</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> innerRadius = <span class="number">45</span>;  <span class="comment">// 内圈半径</span></span><br><span class="line">QPointF center;              <span class="comment">// 中心点</span></span><br><span class="line">QPointF dragPoint;           <span class="comment">// 当前拖动点</span></span><br><span class="line"><span class="type">bool</span> isDragging = <span class="literal">false</span>;     <span class="comment">// 是否正在拖动</span></span><br><span class="line"><span class="type">double</span> m_angle;</span><br><span class="line"><span class="type">bool</span> m_moving = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">QPushButton* stopButton;    <span class="comment">//按钮</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QTimer* m_timer;            <span class="comment">//定时器，控制angleChange()发送频率</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isInsideOuterCircle</span><span class="params">(<span class="type">const</span> QPointF&amp; point)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isInsideInnerCircle</span><span class="params">(<span class="type">const</span> QPointF&amp; point)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calculateDirection</span><span class="params">()</span></span>; <span class="comment">// 计算当前方向</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setupButtons</span><span class="params">()</span></span>;       <span class="comment">// 初始化按钮布局</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DIRECTIONALCONTROL_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DirectionalControl.cpp源代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DirectionalControl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;corecrt_math_defines.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtMath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line"></span><br><span class="line">DirectionalControl::<span class="built_in">DirectionalControl</span>(QWidget* parent)</span><br><span class="line">: <span class="built_in">QWidget</span>(parent), <span class="built_in">center</span>(<span class="number">100</span>, <span class="number">100</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setFixedSize</span>(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line"><span class="built_in">setWindowFlags</span>(Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint);</span><br><span class="line"><span class="built_in">setAttribute</span>(Qt::WA_TranslucentBackground);</span><br><span class="line"><span class="built_in">setFocusPolicy</span>(Qt::StrongFocus);</span><br><span class="line"><span class="comment">//this-&gt;setCursor(Qt::CursorShape::PointingHandCursor);</span></span><br><span class="line">m_timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">dragPoint.<span class="built_in">setX</span>(center.<span class="built_in">x</span>());</span><br><span class="line">dragPoint.<span class="built_in">setY</span>(center.<span class="built_in">y</span>());</span><br><span class="line"></span><br><span class="line">QSize size = <span class="keyword">this</span>-&gt;<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">setupButtons</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;:/qss/resources/qss/DirectionControl.qss&quot;</span>)</span></span>;</span><br><span class="line">QByteArray style;</span><br><span class="line"><span class="keyword">if</span> (file.<span class="built_in">open</span>(QIODevice::ReadOnly))</span><br><span class="line">&#123;</span><br><span class="line">style += file.<span class="built_in">readAll</span>();</span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setStyleSheet</span>(style);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DirectionalControl::resetDragPntPos</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dragPoint.<span class="built_in">setX</span>(center.<span class="built_in">x</span>());</span><br><span class="line">dragPoint.<span class="built_in">setY</span>(center.<span class="built_in">y</span>());</span><br><span class="line"><span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DirectionalControl::sendDirectionChanged</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">emit <span class="title">directionChanged</span><span class="params">(m_angle)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DirectionalControl::setupButtons</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 中心按钮：开始/暂停</span></span><br><span class="line">stopButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">stopButton-&gt;<span class="built_in">move</span>(<span class="number">90</span>, <span class="number">90</span>);</span><br><span class="line">stopButton-&gt;<span class="built_in">setObjectName</span>(<span class="string">&quot;stopButton&quot;</span>);</span><br><span class="line"><span class="built_in">connect</span>(stopButton, &amp;QPushButton::clicked, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">emit <span class="built_in">stopMove</span>();</span><br><span class="line">m_moving = <span class="literal">false</span>;</span><br><span class="line">dragPoint.<span class="built_in">setX</span>(center.<span class="built_in">x</span>());</span><br><span class="line">dragPoint.<span class="built_in">setY</span>(center.<span class="built_in">y</span>());</span><br><span class="line">stopButton-&gt;<span class="built_in">hide</span>();</span><br><span class="line"><span class="built_in">update</span>();</span><br><span class="line">&#125;);</span><br><span class="line">stopButton-&gt;<span class="built_in">hide</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DirectionalControl::paintEvent</span><span class="params">(QPaintEvent* event)</span> </span>&#123;</span><br><span class="line"><span class="built_in">Q_UNUSED</span>(event);</span><br><span class="line"></span><br><span class="line"><span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"><span class="comment">// 抗锯齿</span></span><br><span class="line">painter.<span class="built_in">setRenderHint</span>(QPainter::Antialiasing, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无边框,直接刷色</span></span><br><span class="line">painter.<span class="built_in">setPen</span>(Qt::NoPen);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> QColor <span class="title">outerCircleColor</span><span class="params">(<span class="number">200</span>, <span class="number">220</span>, <span class="number">255</span>, <span class="number">200</span>)</span></span>; <span class="comment">// 外圈颜色</span></span><br><span class="line"><span class="function"><span class="type">const</span> QColor <span class="title">innerCircleColor</span><span class="params">(<span class="number">249</span>, <span class="number">249</span>, <span class="number">249</span>, <span class="number">150</span>)</span></span>; <span class="comment">// 内圈颜色</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> centerDotRadius = <span class="number">3</span>; <span class="comment">// 中心点半径</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dragRadius = <span class="number">15</span>;     <span class="comment">// 拖动点半径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制外圈</span></span><br><span class="line">painter.<span class="built_in">setBrush</span>(outerCircleColor);</span><br><span class="line">painter.<span class="built_in">drawEllipse</span>(center, outerRadius, outerRadius);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制内内圈</span></span><br><span class="line">painter.<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(<span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">150</span>), <span class="number">3</span>));<span class="comment">//外边框</span></span><br><span class="line">painter.<span class="built_in">setBrush</span>(innerCircleColor);</span><br><span class="line">painter.<span class="built_in">drawEllipse</span>(center, dragRadius, dragRadius);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制内圈</span></span><br><span class="line">painter.<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(<span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">150</span>), <span class="number">3</span>));<span class="comment">//外边框</span></span><br><span class="line">painter.<span class="built_in">setBrush</span>(innerCircleColor);</span><br><span class="line">painter.<span class="built_in">drawEllipse</span>(center, innerRadius, innerRadius);</span><br><span class="line"><span class="comment">// 确保 dragPoint 不进入内圈且不超出外圈</span></span><br><span class="line"><span class="type">double</span> dx = dragPoint.<span class="built_in">x</span>() - center.<span class="built_in">x</span>();</span><br><span class="line"><span class="type">double</span> dy = dragPoint.<span class="built_in">y</span>() - center.<span class="built_in">y</span>();</span><br><span class="line"><span class="type">double</span> distance = std::<span class="built_in">sqrt</span>(dx * dx + dy * dy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 dragPoint 超出了外圈，修正到外圈边缘</span></span><br><span class="line"><span class="keyword">if</span> (distance &gt; outerRadius) &#123;</span><br><span class="line"><span class="type">double</span> scale = outerRadius / distance;</span><br><span class="line">dragPoint.<span class="built_in">setX</span>(center.<span class="built_in">x</span>() + dx * scale);</span><br><span class="line">dragPoint.<span class="built_in">setY</span>(center.<span class="built_in">y</span>() + dy * scale);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">painter.<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(<span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)));</span><br><span class="line"><span class="function">QFont <span class="title">font</span><span class="params">(<span class="string">&quot;Arial&quot;</span>, <span class="number">20</span>, QFont::Bold)</span></span>;</span><br><span class="line"><span class="comment">// 设置画笔的字体</span></span><br><span class="line">painter.<span class="built_in">setFont</span>(font);</span><br><span class="line"></span><br><span class="line">painter.<span class="built_in">drawText</span>(<span class="number">87</span>, <span class="number">50</span>, <span class="string">&quot;W&quot;</span>);</span><br><span class="line">painter.<span class="built_in">drawText</span>(<span class="number">28</span>, <span class="number">110</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">painter.<span class="built_in">drawText</span>(<span class="number">90</span>, <span class="number">172</span>, <span class="string">&quot;S&quot;</span>);</span><br><span class="line">painter.<span class="built_in">drawText</span>(<span class="number">152</span>, <span class="number">110</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line"><span class="comment">// 设置画刷颜色为白色并绘制拖动点</span></span><br><span class="line">painter.<span class="built_in">setPen</span>(Qt::NoPen);</span><br><span class="line">painter.<span class="built_in">setBrush</span>(Qt::white);</span><br><span class="line">painter.<span class="built_in">drawEllipse</span>(dragPoint, dragRadius, dragRadius);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在拖动点的中心绘制中心点</span></span><br><span class="line">painter.<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(<span class="built_in">QColor</span>(<span class="number">0</span>, <span class="number">117</span>, <span class="number">255</span>), <span class="number">5</span>));</span><br><span class="line">painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">0</span>, <span class="number">117</span>, <span class="number">255</span>));</span><br><span class="line">painter.<span class="built_in">drawEllipse</span>(dragPoint, centerDotRadius, centerDotRadius);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DirectionalControl::mousePressEvent</span><span class="params">(QMouseEvent* event)</span> </span>&#123;</span><br><span class="line">QPointF pos = event-&gt;<span class="built_in">pos</span>();</span><br><span class="line"><span class="comment">//if (isInsideOuterCircle(pos) &amp;&amp; isInsideInnerCircle(pos)) &#123;</span></span><br><span class="line">isDragging = <span class="literal">true</span>;</span><br><span class="line">dragPoint = pos;</span><br><span class="line"><span class="function">emit <span class="title">startMove</span><span class="params">()</span></span>;</span><br><span class="line">m_moving = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">calculateDirection</span>();</span><br><span class="line"><span class="built_in">sendDirectionChanged</span>();</span><br><span class="line"><span class="comment">// 限制拖动点到外圈的范围</span></span><br><span class="line"><span class="type">double</span> dx = pos.<span class="built_in">x</span>() - center.<span class="built_in">x</span>();</span><br><span class="line"><span class="type">double</span> dy = pos.<span class="built_in">y</span>() - center.<span class="built_in">y</span>();</span><br><span class="line"><span class="type">double</span> distance = std::<span class="built_in">sqrt</span>(dx * dx + dy * dy);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (distance &lt; innerRadius) &#123;</span><br><span class="line"><span class="function">emit <span class="title">handleClick</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">m_timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">connect</span>(m_timer, &amp;QTimer::timeout, <span class="keyword">this</span>, &amp;DirectionalControl::sendDirectionChanged, Qt::<span class="built_in">ConnectionType</span>(Qt::AutoConnection | Qt::UniqueConnection));</span><br><span class="line"><span class="built_in">update</span>();</span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DirectionalControl::mouseMoveEvent</span><span class="params">(QMouseEvent* event)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isDragging) &#123;</span><br><span class="line">QPointF pos = event-&gt;<span class="built_in">pos</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限制拖动点到外圈的范围</span></span><br><span class="line"><span class="type">double</span> dx = pos.<span class="built_in">x</span>() - center.<span class="built_in">x</span>();</span><br><span class="line"><span class="type">double</span> dy = pos.<span class="built_in">y</span>() - center.<span class="built_in">y</span>();</span><br><span class="line"><span class="type">double</span> distance = std::<span class="built_in">sqrt</span>(dx * dx + dy * dy);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (distance &gt; outerRadius) &#123;</span><br><span class="line"><span class="comment">// 将拖动点限制在外圈的边界</span></span><br><span class="line"><span class="type">double</span> scale = outerRadius / distance;</span><br><span class="line">dragPoint.<span class="built_in">setX</span>(center.<span class="built_in">x</span>() + dx * scale);</span><br><span class="line">dragPoint.<span class="built_in">setY</span>(center.<span class="built_in">y</span>() + dy * scale);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*else if (distance &gt; innerRadius)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">dragPoint.setX(center.x());</span></span><br><span class="line"><span class="comment">dragPoint.setY(center.y());</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">dragPoint = pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">calculateDirection</span>();</span><br><span class="line"><span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DirectionalControl::mouseReleaseEvent</span><span class="params">(QMouseEvent* event)</span> </span>&#123;</span><br><span class="line"><span class="built_in">Q_UNUSED</span>(event);</span><br><span class="line">isDragging = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// TODO 点击内圈跑一步，点击外圈持续跑</span></span><br><span class="line"><span class="comment">// 释放时恢复到中心</span></span><br><span class="line"><span class="comment">// dragPoint = center;</span></span><br><span class="line"></span><br><span class="line">QPointF pos = event-&gt;<span class="built_in">pos</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限制拖动点到外圈的范围</span></span><br><span class="line"><span class="type">double</span> dx = pos.<span class="built_in">x</span>() - center.<span class="built_in">x</span>();</span><br><span class="line"><span class="type">double</span> dy = pos.<span class="built_in">y</span>() - center.<span class="built_in">y</span>();</span><br><span class="line"><span class="type">double</span> distance = std::<span class="built_in">sqrt</span>(dx * dx + dy * dy);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (distance &gt; innerRadius) &#123;</span><br><span class="line"><span class="comment">// 将拖动点限制在外圈的边界</span></span><br><span class="line"><span class="type">double</span> distanceFromCenter = (outerRadius + innerRadius) / <span class="number">2</span>;</span><br><span class="line">dragPoint.<span class="built_in">setX</span>(center.<span class="built_in">x</span>() +</span><br><span class="line">distanceFromCenter * std::<span class="built_in">cos</span>(<span class="built_in">qDegreesToRadians</span>(m_angle)));</span><br><span class="line">dragPoint.<span class="built_in">setY</span>(center.<span class="built_in">y</span>() -</span><br><span class="line">distanceFromCenter * std::<span class="built_in">sin</span>(<span class="built_in">qDegreesToRadians</span>(m_angle)));</span><br><span class="line">stopButton-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (distance &lt; innerRadius)<span class="comment">//拖动点释放前在内圈，就停止</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">calculateDirection</span>();</span><br><span class="line">dragPoint.<span class="built_in">setX</span>(center.<span class="built_in">x</span>());</span><br><span class="line">dragPoint.<span class="built_in">setY</span>(center.<span class="built_in">y</span>());</span><br><span class="line">stopButton-&gt;<span class="built_in">hide</span>();</span><br><span class="line"><span class="function">emit <span class="title">stopMove</span><span class="params">()</span></span>;</span><br><span class="line">m_moving = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*else &#123;</span></span><br><span class="line"><span class="comment">dragPoint = pos;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">/*double distanceFromCenter = (outerRadius + innerRadius) / 2;</span></span><br><span class="line"><span class="comment">dragPoint.setX(center.x() +</span></span><br><span class="line"><span class="comment">distanceFromCenter * std::cos(qDegreesToRadians(m_angle)));</span></span><br><span class="line"><span class="comment">dragPoint.setY(center.y() -</span></span><br><span class="line"><span class="comment">distanceFromCenter * std::sin(qDegreesToRadians(m_angle)));*/</span></span><br><span class="line">m_timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line"><span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DirectionalControl::updateDragPntDirection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> distanceFromCenter = (outerRadius + innerRadius) / <span class="number">2</span>;</span><br><span class="line">dragPoint.<span class="built_in">setX</span>(center.<span class="built_in">x</span>() + distanceFromCenter * std::<span class="built_in">cos</span>(<span class="built_in">qDegreesToRadians</span>(m_angle)));</span><br><span class="line">dragPoint.<span class="built_in">setY</span>(center.<span class="built_in">y</span>() - distanceFromCenter * std::<span class="built_in">sin</span>(<span class="built_in">qDegreesToRadians</span>(m_angle)));</span><br><span class="line"><span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DirectionalControl::keyPressEvent</span><span class="params">(QKeyEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QWidget::<span class="built_in">keyPressEvent</span>(event);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 防止重复触发按键，这是官方文档的描述</span></span><br><span class="line"><span class="comment">* bool QKeyEvent::isAutoRepeat() const</span></span><br><span class="line"><span class="comment">* Returns true if this event comes from an auto-repeating key; </span></span><br><span class="line"><span class="comment">* returns false if it comes from an initial key press.</span></span><br><span class="line"><span class="comment">* Note that if the event is a multiple-key compressed event that is partly due to auto-repeat,</span></span><br><span class="line"><span class="comment">* this function could return either true or false indeterminately.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (event-&gt;<span class="built_in">isAutoRepeat</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (event-&gt;<span class="built_in">key</span>()) &#123;</span><br><span class="line"><span class="keyword">case</span> Qt::Key_W:</span><br><span class="line">m_angle = <span class="number">90</span>;</span><br><span class="line"><span class="built_in">sendDirectionChanged</span>();</span><br><span class="line"><span class="function">emit <span class="title">handleClick</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">emit <span class="title">startMove</span><span class="params">()</span></span>;</span><br><span class="line">stopButton-&gt;<span class="built_in">show</span>();</span><br><span class="line">m_moving = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">updateDragPntDirection</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Qt::Key_A:</span><br><span class="line">m_angle = <span class="number">180</span>;</span><br><span class="line"><span class="built_in">sendDirectionChanged</span>();</span><br><span class="line"><span class="function">emit <span class="title">handleClick</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">emit <span class="title">startMove</span><span class="params">()</span></span>;</span><br><span class="line">stopButton-&gt;<span class="built_in">show</span>();</span><br><span class="line">m_moving = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">updateDragPntDirection</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Qt::Key_S:</span><br><span class="line">m_angle = <span class="number">270</span>;</span><br><span class="line"><span class="built_in">sendDirectionChanged</span>();</span><br><span class="line"><span class="function">emit <span class="title">handleClick</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">emit <span class="title">startMove</span><span class="params">()</span></span>;</span><br><span class="line">stopButton-&gt;<span class="built_in">show</span>();</span><br><span class="line">m_moving = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">updateDragPntDirection</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Qt::Key_D:</span><br><span class="line">m_angle = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">sendDirectionChanged</span>();</span><br><span class="line"><span class="function">emit <span class="title">handleClick</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">emit <span class="title">startMove</span><span class="params">()</span></span>;</span><br><span class="line">stopButton-&gt;<span class="built_in">show</span>();</span><br><span class="line">m_moving = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">updateDragPntDirection</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 标记事件为已处理</span></span><br><span class="line">event-&gt;<span class="built_in">accept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DirectionalControl::keyReleaseEvent</span><span class="params">(QKeyEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QWidget::<span class="built_in">keyReleaseEvent</span>(event);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只处理非自动重复的松键事件</span></span><br><span class="line"><span class="keyword">if</span> (event-&gt;<span class="built_in">isAutoRepeat</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (event-&gt;<span class="built_in">key</span>()) &#123;</span><br><span class="line"><span class="keyword">case</span> Qt::Key_W:</span><br><span class="line"><span class="function">emit <span class="title">stopMove</span><span class="params">()</span></span>;</span><br><span class="line">m_moving = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">resetDragPntPos</span>();</span><br><span class="line">stopButton-&gt;<span class="built_in">hide</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Qt::Key_A:</span><br><span class="line"><span class="function">emit <span class="title">stopMove</span><span class="params">()</span></span>;</span><br><span class="line">m_moving = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">resetDragPntPos</span>();</span><br><span class="line">stopButton-&gt;<span class="built_in">hide</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Qt::Key_S:</span><br><span class="line"><span class="function">emit <span class="title">stopMove</span><span class="params">()</span></span>;</span><br><span class="line">m_moving = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">resetDragPntPos</span>();</span><br><span class="line">stopButton-&gt;<span class="built_in">hide</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Qt::Key_D:</span><br><span class="line"><span class="function">emit <span class="title">stopMove</span><span class="params">()</span></span>;</span><br><span class="line">m_moving = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">resetDragPntPos</span>();</span><br><span class="line">stopButton-&gt;<span class="built_in">hide</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Qt::Key_Space:</span><br><span class="line"><span class="function">emit <span class="title">stopMove</span><span class="params">()</span></span>;</span><br><span class="line">m_moving = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">resetDragPntPos</span>();</span><br><span class="line">stopButton-&gt;<span class="built_in">hide</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记事件为已处理</span></span><br><span class="line">event-&gt;<span class="built_in">accept</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DirectionalControl::isInsideOuterCircle</span><span class="params">(<span class="type">const</span> QPointF&amp; point)</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> dx = point.<span class="built_in">x</span>() - center.<span class="built_in">x</span>();</span><br><span class="line"><span class="type">double</span> dy = point.<span class="built_in">y</span>() - center.<span class="built_in">y</span>();</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">sqrt</span>(dx * dx + dy * dy) &lt;= outerRadius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DirectionalControl::isInsideInnerCircle</span><span class="params">(<span class="type">const</span> QPointF&amp; point)</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> dx = point.<span class="built_in">x</span>() - center.<span class="built_in">x</span>();</span><br><span class="line"><span class="type">double</span> dy = point.<span class="built_in">y</span>() - center.<span class="built_in">y</span>();</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">sqrt</span>(dx * dx + dy * dy) &lt;= innerRadius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DirectionalControl::calculateDirection</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> dx = dragPoint.<span class="built_in">x</span>() - center.<span class="built_in">x</span>();</span><br><span class="line"><span class="comment">// Y 轴正方向向下，所以取反</span></span><br><span class="line"><span class="type">double</span> dy = center.<span class="built_in">y</span>() - dragPoint.<span class="built_in">y</span>();</span><br><span class="line"><span class="type">double</span> angle = std::<span class="built_in">atan2</span>(dy, dx) * (<span class="number">180.0</span> / M_PI);</span><br><span class="line"><span class="comment">// 保证角度为 0-360 度</span></span><br><span class="line"><span class="keyword">if</span> (angle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">angle += <span class="number">360.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_angle = angle;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;自定义摇杆&quot;&gt;&lt;a href=&quot;#自定义摇杆&quot; class=&quot;headerlink&quot; title=&quot;自定义摇杆&quot;&gt;&lt;/a&gt;自定义摇杆&lt;/h1&gt;&lt;p&gt;今天做项目的时候，接到一个需求，需要做一个摇杆去控制物体的移动，功能还是挺复杂的&lt;/p&gt;
&lt;h2 id=&quot;1-功能：</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://cpp-memory-leaks.github.io/2025/01/06/%E4%BD%BF%E7%94%A8Qt%E7%A7%81%E6%9C%89%E6%8E%A5%E5%8F%A3%E7%BB%98%E5%88%B6%E5%9B%BE%E7%89%87%E4%BD%9C%E7%AA%97%E5%8F%A3%E9%98%B4%E5%BD%B1/"/>
    <id>https://cpp-memory-leaks.github.io/2025/01/06/%E4%BD%BF%E7%94%A8Qt%E7%A7%81%E6%9C%89%E6%8E%A5%E5%8F%A3%E7%BB%98%E5%88%B6%E5%9B%BE%E7%89%87%E4%BD%9C%E7%AA%97%E5%8F%A3%E9%98%B4%E5%BD%B1/</id>
    <published>2025-01-06T13:48:21.212Z</published>
    <updated>2024-12-31T02:28:31.936Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://cpp-memory-leaks.github.io/2025/01/06/%E4%BD%BF%E7%94%A8libheif%E5%BA%93%E8%AF%BB%E5%8F%96heic%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%A9%E7%95%A5%E5%9B%BE/"/>
    <id>https://cpp-memory-leaks.github.io/2025/01/06/%E4%BD%BF%E7%94%A8libheif%E5%BA%93%E8%AF%BB%E5%8F%96heic%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%A9%E7%95%A5%E5%9B%BE/</id>
    <published>2025-01-06T13:48:21.209Z</published>
    <updated>2024-12-31T02:34:36.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用libheif库读取heic文件的缩略图"><a href="#使用libheif库读取heic文件的缩略图" class="headerlink" title="使用libheif库读取heic文件的缩略图"></a>使用libheif库读取heic文件的缩略图</h1><h2 id="1-先使用vcpkg安装libheif库"><a href="#1-先使用vcpkg安装libheif库" class="headerlink" title="1.先使用vcpkg安装libheif库"></a>1.先使用vcpkg安装libheif库</h2><p>在开始之前，我们需要安装 libheif 库。通过 vcpkg 工具可以方便地安装所需的依赖，根据实际需求选择适合的位数以及动态库或静态库版本。</p><p>安装命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install libheif:x86-windows-static</span><br><span class="line">vcpkg install libheif:x64-windows-static</span><br></pre></td></tr></table></figure><p>完成安装后，确保正确配置 vcpkg 环境，能够被 CMake 或其他构建工具找到。</p><h2 id="2-解码缩略图和解码原图的区别"><a href="#2-解码缩略图和解码原图的区别" class="headerlink" title="2.解码缩略图和解码原图的区别"></a>2.解码缩略图和解码原图的区别</h2><p>在处理 HEIC 格式文件时，缩略图解码和原图解码的使用场景有所不同。以下从资源占用和代码实现两方面进行比较。</p><p>1.解码原图</p><p>解码原图时，图像数据会被完全加载到内存中，适合用于查看高清图片或后续进行深度处理。但这也意味着需要更多的内存和 CPU 资源。</p><p>2.解码缩略图</p><p>如果仅用于预览或快速浏览，可以选择解码缩略图。这种方法占用资源更少，加载速度更快，非常适合需要快速显示大量图片的场景。</p><p>解码原图（查看图片使用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heifToQPixmap</span><span class="params">(<span class="type">const</span> QString&amp; filePath, QPixmap&amp; pixmap)</span> </span>&#123;</span><br><span class="line">QString extension = <span class="built_in">QFileInfo</span>(filePath).<span class="built_in">suffix</span>().<span class="built_in">toLower</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (extension == <span class="string">&quot;jpg&quot;</span> || extension == <span class="string">&quot;jpeg&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!pixmap.<span class="built_in">load</span>(filePath)) &#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to load JPG image.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::string filePathStd = filePath.<span class="built_in">toStdString</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">heif_context</span>* ctx = <span class="built_in">heif_context_alloc</span>();</span><br><span class="line"><span class="keyword">if</span> (!ctx) &#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to allocate HEIF context.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">heif_error</span> err = <span class="built_in">heif_context_read_from_file</span>(ctx, filePathStd.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line"><span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to read HEIF file: &quot;</span> + std::<span class="built_in">string</span>(err.message));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">heif_image_handle</span>* handle = <span class="literal">nullptr</span>;</span><br><span class="line">err = <span class="built_in">heif_context_get_primary_image_handle</span>(ctx, &amp;handle);</span><br><span class="line"><span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line"><span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to get primary image handle: &quot;</span> + std::<span class="built_in">string</span>(err.message));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">heif_image</span>* img = <span class="literal">nullptr</span>;</span><br><span class="line">err = <span class="built_in">heif_decode_image</span>(handle, &amp;img, heif_colorspace_RGB, heif_chroma_interleaved_RGBA, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line"><span class="built_in">heif_image_handle_release</span>(handle);</span><br><span class="line"><span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to decode HEIF image: &quot;</span> + std::<span class="built_in">string</span>(err.message));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> width = <span class="built_in">heif_image_get_width</span>(img, heif_channel_interleaved);</span><br><span class="line"><span class="type">int</span> height = <span class="built_in">heif_image_get_height</span>(img, heif_channel_interleaved);</span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span>* data = <span class="built_in">heif_image_get_plane_readonly</span>(img, heif_channel_interleaved, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">QVector&lt;uchar&gt; <span class="title">buffer</span><span class="params">(width * height * <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="built_in">memcpy</span>(buffer.<span class="built_in">data</span>(), data, buffer.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="function">QImage <span class="title">image</span><span class="params">(buffer.data(), width, height, QImage::Format_RGBA8888)</span></span>;</span><br><span class="line">pixmap = QPixmap::<span class="built_in">fromImage</span>(image);</span><br><span class="line"></span><br><span class="line"><span class="built_in">heif_image_release</span>(img);</span><br><span class="line"><span class="built_in">heif_image_handle_release</span>(handle);</span><br><span class="line"><span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解码缩略图（供预览使用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">loadHeicThumbnail</span><span class="params">(<span class="type">const</span> QString&amp; filePath, QPixmap&amp; thumbnail)</span> </span>&#123;</span><br><span class="line">QString extension = <span class="built_in">QFileInfo</span>(filePath).<span class="built_in">suffix</span>().<span class="built_in">toLower</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (extension == <span class="string">&quot;jpg&quot;</span> || extension == <span class="string">&quot;jpeg&quot;</span>) &#123;</span><br><span class="line"><span class="function">QImageReader <span class="title">reader</span><span class="params">(filePath)</span></span>;</span><br><span class="line">reader.<span class="built_in">setAutoTransform</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">QSize originalSize = reader.<span class="built_in">size</span>(); </span><br><span class="line"><span class="keyword">if</span> (originalSize.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Failed to read image size:&quot;</span> &lt;&lt; reader.<span class="built_in">errorString</span>() &lt;&lt; filePath;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">QSize scaledSize = originalSize.<span class="built_in">scaled</span>(<span class="built_in">QSize</span>(originalSize/<span class="number">20</span>), Qt::KeepAspectRatio);</span><br><span class="line"></span><br><span class="line">reader.<span class="built_in">setScaledSize</span>(scaledSize);</span><br><span class="line"></span><br><span class="line">QImage image = reader.<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">if</span> (image.<span class="built_in">isNull</span>()) &#123;</span><br><span class="line"><span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;Failed to load image:&quot;</span> &lt;&lt; reader.<span class="built_in">errorString</span>() &lt;&lt; filePath;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thumbnail = QPixmap::<span class="built_in">fromImage</span>(image);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">heif_context* ctx = <span class="built_in">heif_context_alloc</span>();</span><br><span class="line">heif_error err = <span class="built_in">heif_context_read_from_file</span>(ctx, filePath.<span class="built_in">toStdString</span>().<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Failed to read HEIF file: &quot;</span>;</span><br><span class="line"><span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">heif_image_handle* handle = <span class="literal">nullptr</span>;</span><br><span class="line">err = <span class="built_in">heif_context_get_primary_image_handle</span>(ctx, &amp;handle);</span><br><span class="line"><span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Failed to get primary image handle: &quot;</span>;</span><br><span class="line"><span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">heif_image_handle* thumbnail_handle = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">int</span> num_thumbnails = <span class="built_in">heif_image_handle_get_number_of_thumbnails</span>(handle);</span><br><span class="line"><span class="keyword">if</span> (num_thumbnails &gt; <span class="number">0</span>) &#123;</span><br><span class="line">heif_item_id thumbnail_id;</span><br><span class="line"><span class="built_in">heif_image_handle_get_list_of_thumbnail_IDs</span>(handle, &amp;thumbnail_id, <span class="number">1</span>);</span><br><span class="line">err = <span class="built_in">heif_image_handle_get_thumbnail</span>(handle, thumbnail_id, &amp;thumbnail_handle);</span><br><span class="line"><span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Failed to get thumbnail handle: &quot;</span>;</span><br><span class="line"><span class="built_in">heif_image_handle_release</span>(handle);</span><br><span class="line"><span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码缩略图</span></span><br><span class="line">heif_image* thumbnail_image = <span class="literal">nullptr</span>;</span><br><span class="line">err = <span class="built_in">heif_decode_image</span>(thumbnail_handle, &amp;thumbnail_image, heif_colorspace_RGB, heif_chroma_interleaved_RGB, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Failed to decode thumbnail: &quot;</span> &lt;&lt; err.message;</span><br><span class="line"><span class="built_in">heif_image_handle_release</span>(thumbnail_handle);</span><br><span class="line"><span class="built_in">heif_image_handle_release</span>(handle);</span><br><span class="line"><span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> width = <span class="built_in">heif_image_get_width</span>(thumbnail_image, heif_channel_interleaved);</span><br><span class="line"><span class="type">int</span> height = <span class="built_in">heif_image_get_height</span>(thumbnail_image, heif_channel_interleaved);</span><br><span class="line"><span class="type">int</span> stride;</span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span>* data = <span class="built_in">heif_image_get_plane_readonly</span>(thumbnail_image, heif_channel_interleaved, &amp;stride);</span><br><span class="line"><span class="function">QImage <span class="title">image</span><span class="params">(data, width, height, stride, QImage::Format_RGB888)</span></span>; \</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (image.<span class="built_in">isNull</span>()) &#123;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Failed to convert HEIF thumbnail to QImage.&quot;</span>;</span><br><span class="line"><span class="built_in">heif_image_release</span>(thumbnail_image);</span><br><span class="line"><span class="built_in">heif_image_handle_release</span>(thumbnail_handle);</span><br><span class="line"><span class="built_in">heif_image_handle_release</span>(handle);</span><br><span class="line"><span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thumbnail = QPixmap::<span class="built_in">fromImage</span>(image.<span class="built_in">copy</span>());<span class="comment">//不使用copy data释放掉后内存访问冲突</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">heif_image_release</span>(thumbnail_image);</span><br><span class="line"><span class="built_in">heif_image_handle_release</span>(thumbnail_handle);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;No thumbnails found in the HEIF file.&quot;</span>;</span><br><span class="line"><span class="built_in">heif_image_handle_release</span>(handle);</span><br><span class="line"><span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">heif_image_handle_release</span>(handle);</span><br><span class="line"><span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-测试代码"><a href="#3-测试代码" class="headerlink" title="3.测试代码"></a>3.测试代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QImage&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPixmap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libheif/heif.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">QImage <span class="title">heifToQImage</span><span class="params">(<span class="type">const</span> std::string&amp; filePath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 libheif 句柄</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">heif_context</span>* ctx = <span class="built_in">heif_context_alloc</span>();</span><br><span class="line">    <span class="keyword">if</span> (!ctx) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to allocate HEIF context.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 HEIF 文件</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">heif_error</span> err = <span class="built_in">heif_context_read_from_file</span>(ctx, filePath.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line">        <span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to read HEIF file: &quot;</span> + std::<span class="built_in">string</span>(err.message));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取主图像句柄</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">heif_image_handle</span>* handle = <span class="literal">nullptr</span>;</span><br><span class="line">    err = <span class="built_in">heif_context_get_primary_image_handle</span>(ctx, &amp;handle);</span><br><span class="line">    <span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line">        <span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to get primary image handle: &quot;</span> + std::<span class="built_in">string</span>(err.message));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码图像</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">heif_image</span>* img = <span class="literal">nullptr</span>;</span><br><span class="line">    err = <span class="built_in">heif_decode_image</span>(handle, &amp;img, heif_colorspace_RGB, heif_chroma_interleaved_RGBA, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line">        <span class="built_in">heif_image_handle_release</span>(handle);</span><br><span class="line">        <span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to decode HEIF image: &quot;</span> + std::<span class="built_in">string</span>(err.message));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取图像数据</span></span><br><span class="line">    <span class="type">int</span> width = <span class="built_in">heif_image_get_width</span>(img, heif_channel_interleaved);</span><br><span class="line">    <span class="type">int</span> height = <span class="built_in">heif_image_get_height</span>(img, heif_channel_interleaved);</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span>* data = <span class="built_in">heif_image_get_plane_readonly</span>(img, heif_channel_interleaved, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建缓冲区并复制数据</span></span><br><span class="line">    <span class="function">QVector&lt;uchar&gt; <span class="title">buffer</span><span class="params">(width * height * <span class="number">4</span>)</span></span>; <span class="comment">// RGBA8888，每像素4字节</span></span><br><span class="line">    <span class="built_in">memcpy</span>(buffer.<span class="built_in">data</span>(), data, buffer.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为 QImage</span></span><br><span class="line">    <span class="function">QImage <span class="title">qimage</span><span class="params">(buffer.data(), width, height, QImage::Format_RGBA8888)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="built_in">heif_image_release</span>(img);</span><br><span class="line">    <span class="built_in">heif_image_handle_release</span>(handle);</span><br><span class="line">    <span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> qimage.<span class="built_in">copy</span>(); <span class="comment">// 确保 QImage 独立持有数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        QImage image = <span class="built_in">heifToQImage</span>(<span class="string">&quot;C:/Users/lianx/Pictures/IMG_0001.HEIC&quot;</span>);</span><br><span class="line"></span><br><span class="line">        QLabel label;</span><br><span class="line">        label.<span class="built_in">setPixmap</span>(QPixmap::<span class="built_in">fromImage</span>(image));</span><br><span class="line">        label.<span class="built_in">setScaledContents</span>(<span class="literal">true</span>);</span><br><span class="line">        label.<span class="built_in">resize</span>(image.<span class="built_in">size</span>()/<span class="number">2</span>);</span><br><span class="line">        label.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-效果如图"><a href="#4-效果如图" class="headerlink" title="4.效果如图"></a>4.效果如图</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用libheif库读取heic文件的缩略图&quot;&gt;&lt;a href=&quot;#使用libheif库读取heic文件的缩略图&quot; class=&quot;headerlink&quot; title=&quot;使用libheif库读取heic文件的缩略图&quot;&gt;&lt;/a&gt;使用libheif库读取heic文件的缩</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://cpp-memory-leaks.github.io/2025/01/06/Qt%E4%BD%BF%E7%94%A8libheif%E5%BA%93%E6%98%BE%E7%A4%BA%E8%8B%B9%E6%9E%9C%E7%9A%84heic%E5%9B%BE%E7%89%87/"/>
    <id>https://cpp-memory-leaks.github.io/2025/01/06/Qt%E4%BD%BF%E7%94%A8libheif%E5%BA%93%E6%98%BE%E7%A4%BA%E8%8B%B9%E6%9E%9C%E7%9A%84heic%E5%9B%BE%E7%89%87/</id>
    <published>2025-01-06T13:48:21.206Z</published>
    <updated>2024-12-25T15:55:31.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Qt使用libheif库显示苹果的heic图片"><a href="#Qt使用libheif库显示苹果的heic图片" class="headerlink" title="Qt使用libheif库显示苹果的heic图片"></a>Qt使用libheif库显示苹果的heic图片</h1><h2 id="1-先使用vcpkg安装libheif库"><a href="#1-先使用vcpkg安装libheif库" class="headerlink" title="1.先使用vcpkg安装libheif库"></a>1.先使用vcpkg安装libheif库</h2><p>自己根据需要选择位数以及动态库还是静态库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install libheif:x86-windows-static</span><br><span class="line">vcpkg install libheif:x64-windows-static</span><br></pre></td></tr></table></figure><h2 id="2-直接上代码"><a href="#2-直接上代码" class="headerlink" title="2.直接上代码"></a>2.直接上代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QImage&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPixmap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libheif/heif.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">QImage <span class="title">heifToQImage</span><span class="params">(<span class="type">const</span> std::string&amp; filePath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 libheif 句柄</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">heif_context</span>* ctx = <span class="built_in">heif_context_alloc</span>();</span><br><span class="line">    <span class="keyword">if</span> (!ctx) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to allocate HEIF context.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 HEIF 文件</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">heif_error</span> err = <span class="built_in">heif_context_read_from_file</span>(ctx, filePath.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line">        <span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to read HEIF file: &quot;</span> + std::<span class="built_in">string</span>(err.message));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取主图像句柄</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">heif_image_handle</span>* handle = <span class="literal">nullptr</span>;</span><br><span class="line">    err = <span class="built_in">heif_context_get_primary_image_handle</span>(ctx, &amp;handle);</span><br><span class="line">    <span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line">        <span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to get primary image handle: &quot;</span> + std::<span class="built_in">string</span>(err.message));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码图像</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">heif_image</span>* img = <span class="literal">nullptr</span>;</span><br><span class="line">    err = <span class="built_in">heif_decode_image</span>(handle, &amp;img, heif_colorspace_RGB, heif_chroma_interleaved_RGBA, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line">        <span class="built_in">heif_image_handle_release</span>(handle);</span><br><span class="line">        <span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to decode HEIF image: &quot;</span> + std::<span class="built_in">string</span>(err.message));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取图像数据</span></span><br><span class="line">    <span class="type">int</span> width = <span class="built_in">heif_image_get_width</span>(img, heif_channel_interleaved);</span><br><span class="line">    <span class="type">int</span> height = <span class="built_in">heif_image_get_height</span>(img, heif_channel_interleaved);</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span>* data = <span class="built_in">heif_image_get_plane_readonly</span>(img, heif_channel_interleaved, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建缓冲区并复制数据</span></span><br><span class="line">    <span class="function">QVector&lt;uchar&gt; <span class="title">buffer</span><span class="params">(width * height * <span class="number">4</span>)</span></span>; <span class="comment">// RGBA8888，每像素4字节</span></span><br><span class="line">    <span class="built_in">memcpy</span>(buffer.<span class="built_in">data</span>(), data, buffer.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为 QImage</span></span><br><span class="line">    <span class="function">QImage <span class="title">qimage</span><span class="params">(buffer.data(), width, height, QImage::Format_RGBA8888)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="built_in">heif_image_release</span>(img);</span><br><span class="line">    <span class="built_in">heif_image_handle_release</span>(handle);</span><br><span class="line">    <span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> qimage.<span class="built_in">copy</span>(); <span class="comment">// 确保 QImage 独立持有数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        QImage image = <span class="built_in">heifToQImage</span>(<span class="string">&quot;C:/Users/lianx/Pictures/IMG_0001.HEIC&quot;</span>);</span><br><span class="line"></span><br><span class="line">        QLabel label;</span><br><span class="line">        label.<span class="built_in">setPixmap</span>(QPixmap::<span class="built_in">fromImage</span>(image));</span><br><span class="line">        label.<span class="built_in">setScaledContents</span>(<span class="literal">true</span>);</span><br><span class="line">        label.<span class="built_in">resize</span>(image.<span class="built_in">size</span>()/<span class="number">2</span>);</span><br><span class="line">        label.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-效果如图"><a href="#3-效果如图" class="headerlink" title="3.效果如图"></a>3.效果如图</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Qt使用libheif库显示苹果的heic图片&quot;&gt;&lt;a href=&quot;#Qt使用libheif库显示苹果的heic图片&quot; class=&quot;headerlink&quot; title=&quot;Qt使用libheif库显示苹果的heic图片&quot;&gt;&lt;/a&gt;Qt使用libheif库显示苹果的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://cpp-memory-leaks.github.io/2025/01/06/Qt%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%97%E8%A1%A8%E6%8E%A7%E4%BB%B6%E4%B9%8BQListView%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E4%BC%98%E7%82%B9/"/>
    <id>https://cpp-memory-leaks.github.io/2025/01/06/Qt%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%97%E8%A1%A8%E6%8E%A7%E4%BB%B6%E4%B9%8BQListView%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E4%BC%98%E7%82%B9/</id>
    <published>2025-01-06T13:48:21.203Z</published>
    <updated>2024-12-25T15:59:53.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Qt高性能列表控件之QListView的使用及优点"><a href="#Qt高性能列表控件之QListView的使用及优点" class="headerlink" title="Qt高性能列表控件之QListView的使用及优点"></a>Qt高性能列表控件之QListView的使用及优点</h1><h2 id="1-高性能列表如何能实线高性能？"><a href="#1-高性能列表如何能实线高性能？" class="headerlink" title="1.高性能列表如何能实线高性能？"></a>1.高性能列表如何能实线高性能？</h2><p>高性能列表无非就解决两个痛点：</p><p><strong>数据存放在哪里</strong></p><p><strong>数据如何展示</strong></p><p>为何QListWidget就不能高性能呢？<code>QListWidget</code> 是一个方便的控件，它内部管理了一个项目列表，并提供了一些简单的接口来添加、删除和修改这些项目。但<strong>没有对数据存储和数据展示进行过多的优化</strong>，这种方式适合于简单的应用场景，其中列表的大小不会很大，因为每个项目都会被存储为一个 <code>QListWidgetItem</code> 对象。</p><p>在QListView体系里，<strong>QAbstractListModel</strong>解决的是“<strong>数据存哪</strong>”，解决的是第一个问题，而<strong>QAbstractItemDelegate</strong>解决的是数据“<strong>如何展示</strong>”，解决的是第二个问题。</p><h2 id="2-QListView和QAbstractListModel解决数据存哪"><a href="#2-QListView和QAbstractListModel解决数据存哪" class="headerlink" title="2.QListView和QAbstractListModel解决数据存哪"></a>2.QListView和QAbstractListModel解决数据存哪</h2><p>这里就不从QAbstractListModel派生写自定义的类了，直接使用Qt从QAbstractListModel派生的类QStandardItemModel</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化QListView</span></span><br><span class="line">QListView* photoListViewphotoListView = <span class="keyword">new</span> <span class="built_in">QListView</span>(<span class="keyword">this</span>);</span><br><span class="line">photoListView-&gt;<span class="built_in">setViewMode</span>(QListView::IconMode);</span><br><span class="line">photoListView-&gt;<span class="built_in">setResizeMode</span>(QListView::Adjust);</span><br><span class="line">photoListView-&gt;<span class="built_in">setIconSize</span>(<span class="built_in">QSize</span>(<span class="number">150</span>, <span class="number">150</span>));</span><br><span class="line">photoListView-&gt;<span class="built_in">setSpacing</span>(<span class="number">10</span>);</span><br><span class="line">photoListView-&gt;<span class="built_in">setSelectionMode</span>(QAbstractItemView::ExtendedSelection);</span><br><span class="line">photoListView-&gt;<span class="built_in">setUniformItemSizes</span>(<span class="literal">true</span>);</span><br><span class="line">photoListView-&gt;<span class="built_in">setVerticalScrollBarPolicy</span>(Qt::ScrollBarAlwaysOff);</span><br><span class="line">photoListView-&gt;<span class="built_in">setAttribute</span>(Qt::WA_Hover); <span class="comment">// 启用 Hover 事件</span></span><br><span class="line">photoListView-&gt;<span class="built_in">viewport</span>()-&gt;<span class="built_in">setAttribute</span>(Qt::WA_Hover);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化QStandardItemModel</span></span><br><span class="line">QStandardItemModel* m_photoModel = <span class="keyword">new</span> <span class="built_in">QStandardItemModel</span>(<span class="keyword">this</span>);</span><br><span class="line">ui-&gt;listView_Photos-&gt;<span class="built_in">setItemDelegate</span>(<span class="keyword">new</span> <span class="built_in">PhotoDelegate</span>(ui-&gt;listView_Photos));<span class="comment">//这是解决数据如何展示的</span></span><br><span class="line">ui-&gt;listView_Photos-&gt;<span class="built_in">model</span>()-&gt;<span class="built_in">removeRows</span>(<span class="number">0</span>, ui-&gt;listView_Photos-&gt;<span class="built_in">model</span>()-&gt;<span class="built_in">rowCount</span>(<span class="built_in">QModelIndex</span>()));</span><br><span class="line"><span class="comment">//模拟数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> photoInfo : m_vecPhoto) &#123;</span><br><span class="line">QStandardItem* item = <span class="keyword">new</span> QStandardItem;</span><br><span class="line">item-&gt;<span class="built_in">setEditable</span>(<span class="literal">false</span>);</span><br><span class="line">item-&gt;<span class="built_in">setData</span>(<span class="string">&quot;:/images/Demo.png&quot;</span>, Qt::UserRole);</span><br><span class="line"><span class="comment">//item-&gt;setData(photoInfo.duration,Qt::UserRole);</span></span><br><span class="line">item-&gt;<span class="built_in">setData</span>(photoInfo.fileName, Qt::UserRole + <span class="number">1</span>);</span><br><span class="line">item-&gt;<span class="built_in">setData</span>(photoInfo.width + <span class="string">&quot;x&quot;</span> + photoInfo.height, Qt::UserRole + <span class="number">2</span>);</span><br><span class="line">item-&gt;<span class="built_in">setData</span>(photoInfo.dateCreated, Qt::UserRole + <span class="number">3</span>);</span><br><span class="line">item-&gt;<span class="built_in">setData</span>(photoInfo.fileSize, Qt::UserRole + <span class="number">4</span>);</span><br><span class="line">item-&gt;<span class="built_in">setData</span>(photoInfo.dir, Qt::UserRole + <span class="number">5</span>);</span><br><span class="line"><span class="comment">//将数据存放到QStandardItemModel里面</span></span><br><span class="line">m_photoModel-&gt;<span class="built_in">appendRow</span>(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-QListView和QAbstractItemDelegate解决数据如何展示"><a href="#3-QListView和QAbstractItemDelegate解决数据如何展示" class="headerlink" title="3.QListView和QAbstractItemDelegate解决数据如何展示"></a>3.QListView和QAbstractItemDelegate解决数据如何展示</h2><p>QStyledItemDelegate是从QAbstractItemDelegate派生的类，<strong>QListView的View模型采用的是paint函数来呈现，paint的形式用起来更复杂，但性能天花板更高</strong>。这就是QListView的性能如此高的原因。</p><p>包括了IconMode以及ListMode的显示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhotoDelegate</span> : <span class="keyword">public</span> QStyledItemDelegate &#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ViewMode</span> &#123; ListMode, GridMode &#125;;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">PhotoDelegate</span><span class="params">(QListView* parent = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">: QStyledItemDelegate(parent) &#123;</span></span><br><span class="line">listView = parent;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paint</span><span class="params">(QPainter* painter, <span class="type">const</span> QStyleOptionViewItem&amp; option, <span class="type">const</span> QModelIndex&amp; index)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">painter-&gt;<span class="built_in">save</span>();</span><br><span class="line">painter-&gt;<span class="built_in">setRenderHint</span>(QPainter::Antialiasing);</span><br><span class="line">QListView::ViewMode viewMode = listView-&gt;<span class="built_in">viewMode</span>();</span><br><span class="line"><span class="function">QPixmap <span class="title">pixmap</span><span class="params">(index.data(Qt::UserRole).toString())</span></span>;</span><br><span class="line"><span class="comment">//图片信息</span></span><br><span class="line">QString fileName = index.<span class="built_in">data</span>(Qt::UserRole + <span class="number">1</span>).<span class="built_in">toString</span>();</span><br><span class="line">QString fileReso = index.<span class="built_in">data</span>(Qt::UserRole + <span class="number">2</span>).<span class="built_in">toString</span>();</span><br><span class="line">QString fileDate = index.<span class="built_in">data</span>(Qt::UserRole + <span class="number">3</span>).<span class="built_in">toString</span>();</span><br><span class="line">QString fileSize = index.<span class="built_in">data</span>(Qt::UserRole + <span class="number">4</span>).<span class="built_in">toString</span>();</span><br><span class="line"></span><br><span class="line">QRect iconRect = <span class="built_in">QRect</span>(option.rect.<span class="built_in">left</span>() + <span class="number">5</span>, option.rect.<span class="built_in">top</span>() + <span class="number">5</span>, <span class="number">50</span>, <span class="number">50</span>); <span class="comment">// 图标区域</span></span><br><span class="line">QRect nameRect = <span class="built_in">QRect</span>(iconRect.<span class="built_in">right</span>() - <span class="number">50</span>, option.rect.<span class="built_in">top</span>() + <span class="number">100</span>, option.rect.<span class="built_in">width</span>(), <span class="number">20</span>); <span class="comment">// 文件名</span></span><br><span class="line">QRect dateRect = <span class="built_in">QRect</span>(iconRect.<span class="built_in">right</span>() - <span class="number">50</span>, option.rect.<span class="built_in">top</span>() + <span class="number">120</span>, option.rect.<span class="built_in">width</span>(), <span class="number">20</span>); <span class="comment">// 日期</span></span><br><span class="line">QRect sizeRect = <span class="built_in">QRect</span>(iconRect.<span class="built_in">right</span>() - <span class="number">50</span>, option.rect.<span class="built_in">top</span>() + <span class="number">140</span>, option.rect.<span class="built_in">width</span>(), <span class="number">20</span>); <span class="comment">// 大小</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isSelected = option.state &amp; QStyle::State_Selected;</span><br><span class="line"><span class="type">bool</span> isHovered = option.state &amp; QStyle::State_MouseOver;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (viewMode == QListView::ViewMode::IconMode)</span><br><span class="line">&#123;</span><br><span class="line">QString filePath = index.<span class="built_in">data</span>(Qt::UserRole).<span class="built_in">value</span>&lt;QString&gt;();</span><br><span class="line">QRect imageRect = option.rect;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置图片为正方形，填充区域</span></span><br><span class="line"><span class="type">int</span> size = <span class="built_in">qMin</span>(imageRect.<span class="built_in">width</span>(), imageRect.<span class="built_in">height</span>());</span><br><span class="line"><span class="function">QRect <span class="title">squareRect</span><span class="params">(imageRect.topLeft(), QSize(size, size))</span></span>;</span><br><span class="line">squareRect.<span class="built_in">moveCenter</span>(imageRect.<span class="built_in">center</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抗锯齿</span></span><br><span class="line">painter-&gt;<span class="built_in">setRenderHint</span>(QPainter::Antialiasing);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 裁剪，绘图</span></span><br><span class="line">QPainterPath clipPath;</span><br><span class="line">clipPath.<span class="built_in">addRoundedRect</span>(squareRect, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">painter-&gt;<span class="built_in">setClipPath</span>(clipPath);</span><br><span class="line">painter-&gt;<span class="built_in">drawPixmap</span>(squareRect, pixmap, pixmap.<span class="built_in">rect</span>());</span><br><span class="line"><span class="keyword">if</span> (!isSelected)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 图标</span></span><br><span class="line"><span class="function">QPixmap <span class="title">checkIcon</span><span class="params">(<span class="string">&quot;:/images/unselect.png&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">QRect <span class="title">checkRect</span><span class="params">(squareRect.topRight() - QPoint(SELECT_ICON_SIZE + <span class="number">5</span>, <span class="number">-5</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">QSize(SELECT_ICON_SIZE, SELECT_ICON_SIZE))</span></span>;</span><br><span class="line">painter-&gt;<span class="built_in">drawPixmap</span>(checkRect, checkIcon);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制选中时的边框和勾选图标</span></span><br><span class="line"><span class="keyword">if</span> (isSelected) &#123;</span><br><span class="line"><span class="comment">// 蓝框</span></span><br><span class="line">painter-&gt;<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(<span class="built_in">QColor</span>(<span class="number">41</span>, <span class="number">95</span>, <span class="number">204</span>), <span class="number">3</span>));</span><br><span class="line">painter-&gt;<span class="built_in">drawRoundedRect</span>(squareRect, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图标</span></span><br><span class="line"><span class="function">QPixmap <span class="title">checkIcon</span><span class="params">(<span class="string">&quot;:/images/selected.png&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">QRect <span class="title">checkRect</span><span class="params">(squareRect.topRight() - QPoint(SELECT_ICON_SIZE + <span class="number">5</span>, <span class="number">-5</span>), QSize(SELECT_ICON_SIZE, SELECT_ICON_SIZE))</span></span>;</span><br><span class="line">painter-&gt;<span class="built_in">drawPixmap</span>(checkRect, checkIcon);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isHovered)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 蓝框</span></span><br><span class="line">painter-&gt;<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(<span class="built_in">QColor</span>(<span class="number">41</span>, <span class="number">95</span>, <span class="number">204</span>), <span class="number">3</span>));</span><br><span class="line">painter-&gt;<span class="built_in">drawRoundedRect</span>(squareRect, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">painter-&gt;<span class="built_in">setPen</span>(Qt::black);</span><br><span class="line">painter-&gt;<span class="built_in">drawText</span>(nameRect, Qt::AlignLeft | Qt::AlignVCenter, fileName);</span><br><span class="line">painter-&gt;<span class="built_in">drawText</span>(dateRect, Qt::AlignLeft | Qt::AlignVCenter, fileDate);</span><br><span class="line">painter-&gt;<span class="built_in">drawText</span>(sizeRect, Qt::AlignLeft | Qt::AlignVCenter, fileSize);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (viewMode == QListView::ViewMode::ListMode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//listView-&gt;setSpacing(5);</span></span><br><span class="line"><span class="keyword">if</span> (isHovered)</span><br><span class="line">&#123;</span><br><span class="line">QRect <span class="built_in">fileRect</span>(option.rect.<span class="built_in">topLeft</span>(), option.rect.<span class="built_in">size</span>());</span><br><span class="line"><span class="type">int</span> borderRadius = <span class="number">10</span>; <span class="comment">// 圆角的半径</span></span><br><span class="line"></span><br><span class="line">painter-&gt;<span class="built_in">setPen</span>(Qt::NoPen); <span class="comment">// 去掉边框</span></span><br><span class="line">painter-&gt;<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">235</span>, <span class="number">241</span>, <span class="number">255</span>)); <span class="comment">// 设置填充颜色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆角背景</span></span><br><span class="line">painter-&gt;<span class="built_in">drawRoundedRect</span>(fileRect, borderRadius, borderRadius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选中状态边框</span></span><br><span class="line"><span class="keyword">if</span> (isSelected) &#123;</span><br><span class="line"><span class="function">QRect <span class="title">fileRect</span><span class="params">(option.rect.topLeft(), option.rect.size())</span></span>;</span><br><span class="line"><span class="type">int</span> borderRadius = <span class="number">10</span>; <span class="comment">// 圆角的半径</span></span><br><span class="line">painter-&gt;<span class="built_in">setPen</span>(Qt::NoPen);</span><br><span class="line"><span class="comment">// 设置背景颜色</span></span><br><span class="line">painter-&gt;<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">235</span>, <span class="number">241</span>, <span class="number">255</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制带圆角的背景</span></span><br><span class="line">painter-&gt;<span class="built_in">drawRoundedRect</span>(fileRect, borderRadius, borderRadius);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制选中图标</span></span><br><span class="line">QRect checkIconRect = <span class="built_in">QRect</span>(option.rect.<span class="built_in">left</span>() + <span class="number">15</span>, option.rect.<span class="built_in">top</span>() + <span class="number">20</span>, SELECT_ICON_SIZE, SELECT_ICON_SIZE);</span><br><span class="line"><span class="function">QPixmap <span class="title">checkIcon</span><span class="params">(<span class="string">&quot;:/images/selected.png&quot;</span>)</span></span>;</span><br><span class="line">painter-&gt;<span class="built_in">drawPixmap</span>(checkIconRect, checkIcon);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">QRect checkIconRect = <span class="built_in">QRect</span>(option.rect.<span class="built_in">left</span>() + <span class="number">15</span>, option.rect.<span class="built_in">top</span>() + <span class="number">20</span>, SELECT_ICON_SIZE, SELECT_ICON_SIZE);</span><br><span class="line"><span class="function">QPixmap <span class="title">checkIcon</span><span class="params">(<span class="string">&quot;:/images/unselect.png&quot;</span>)</span></span>;</span><br><span class="line">painter-&gt;<span class="built_in">drawPixmap</span>(checkIconRect, checkIcon);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制区域</span></span><br><span class="line">QRect iconRect = <span class="built_in">QRect</span>(option.rect.<span class="built_in">left</span>() + <span class="number">45</span>, option.rect.<span class="built_in">top</span>() + <span class="number">7</span>, <span class="number">44</span>, <span class="number">44</span>); <span class="comment">// 图标区域</span></span><br><span class="line">QRect nameRect = <span class="built_in">QRect</span>(iconRect.<span class="built_in">right</span>() + <span class="number">40</span>, option.rect.<span class="built_in">top</span>() + <span class="number">20</span>, <span class="number">200</span>, <span class="number">20</span>); <span class="comment">// 文件名</span></span><br><span class="line">QRect resoRect = <span class="built_in">QRect</span>(nameRect.<span class="built_in">right</span>() + <span class="number">40</span>, option.rect.<span class="built_in">top</span>() + <span class="number">20</span>, <span class="number">100</span>, <span class="number">20</span>); <span class="comment">// 分辨率</span></span><br><span class="line">QRect dateRect = <span class="built_in">QRect</span>(resoRect.<span class="built_in">right</span>() + <span class="number">40</span>, option.rect.<span class="built_in">top</span>() + <span class="number">20</span>, <span class="number">200</span>, <span class="number">20</span>); <span class="comment">// 日期</span></span><br><span class="line">QRect sizeRect = <span class="built_in">QRect</span>(dateRect.<span class="built_in">right</span>() + <span class="number">40</span>, option.rect.<span class="built_in">top</span>() + <span class="number">20</span>, <span class="number">100</span>, <span class="number">20</span>); <span class="comment">// 大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制圆角图标</span></span><br><span class="line"><span class="type">int</span> borderRadius = <span class="number">10</span>;</span><br><span class="line">QPainterPath path;</span><br><span class="line">path.<span class="built_in">addRoundedRect</span>(iconRect, borderRadius, borderRadius);</span><br><span class="line"></span><br><span class="line">painter-&gt;<span class="built_in">save</span>();</span><br><span class="line"><span class="comment">// 抗锯齿</span></span><br><span class="line">painter-&gt;<span class="built_in">setRenderHint</span>(QPainter::Antialiasing, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 裁剪区域</span></span><br><span class="line">painter-&gt;<span class="built_in">setClipPath</span>(path);</span><br><span class="line">painter-&gt;<span class="built_in">drawPixmap</span>(iconRect, pixmap);</span><br><span class="line">painter-&gt;<span class="built_in">restore</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制文件名、日期和大小</span></span><br><span class="line">painter-&gt;<span class="built_in">setPen</span>(Qt::black);</span><br><span class="line">painter-&gt;<span class="built_in">drawText</span>(nameRect, Qt::AlignLeft | Qt::AlignVCenter, fileName);</span><br><span class="line">painter-&gt;<span class="built_in">setPen</span>(Qt::gray);</span><br><span class="line">painter-&gt;<span class="built_in">drawText</span>(resoRect, Qt::AlignLeft | Qt::AlignVCenter, fileReso);</span><br><span class="line">painter-&gt;<span class="built_in">drawText</span>(dateRect, Qt::AlignLeft | Qt::AlignVCenter, fileDate);</span><br><span class="line"></span><br><span class="line">painter-&gt;<span class="built_in">drawText</span>(sizeRect, Qt::AlignLeft | Qt::AlignVCenter, fileSize);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">painter-&gt;<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">QSize <span class="title">sizeHint</span><span class="params">(<span class="type">const</span> QStyleOptionViewItem&amp; option, <span class="type">const</span> QModelIndex&amp; index)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">Q_UNUSED</span>(index);</span><br><span class="line"><span class="comment">//固定大小</span></span><br><span class="line"><span class="keyword">if</span> (listView-&gt;<span class="built_in">viewMode</span>() == QListView::ViewMode::IconMode) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">QSize</span>(<span class="number">170</span>, <span class="number">170</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  <span class="built_in">QSize</span>(<span class="number">50</span>, <span class="number">60</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">editorEvent</span><span class="params">(QEvent* event, QAbstractItemModel* model, <span class="type">const</span> QStyleOptionViewItem&amp; option,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> QModelIndex&amp; index)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == QEvent::MouseButtonPress) &#123;</span><br><span class="line">QMouseEvent* mouseEvent = <span class="built_in">static_cast</span>&lt;QMouseEvent*&gt;(event);</span><br><span class="line">QListView::ViewMode viewMode = listView-&gt;<span class="built_in">viewMode</span>();</span><br><span class="line"></span><br><span class="line">QRect checkRect;</span><br><span class="line"><span class="keyword">if</span> (viewMode == QListView::ViewMode::IconMode) &#123;</span><br><span class="line">checkRect = <span class="built_in">QRect</span>(option.rect.<span class="built_in">topRight</span>() - <span class="built_in">QPoint</span>(SELECT_ICON_SIZE + <span class="number">5</span>, <span class="number">-5</span>),</span><br><span class="line"><span class="built_in">QSize</span>(SELECT_ICON_SIZE, SELECT_ICON_SIZE));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">checkRect = <span class="built_in">QRect</span>(option.rect.<span class="built_in">left</span>() + <span class="number">15</span>, option.rect.<span class="built_in">top</span>() + <span class="number">20</span>, SELECT_ICON_SIZE, SELECT_ICON_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (checkRect.<span class="built_in">contains</span>(mouseEvent-&gt;<span class="built_in">pos</span>())) &#123;</span><br><span class="line"><span class="type">bool</span> isSelected = index.<span class="built_in">data</span>(Qt::UserRole + <span class="number">15</span>).<span class="built_in">toBool</span>();</span><br><span class="line">model-&gt;<span class="built_in">setData</span>(index, !isSelected, Qt::UserRole + <span class="number">15</span>);</span><br><span class="line">QItemSelectionModel* selectionModel = listView-&gt;<span class="built_in">selectionModel</span>();</span><br><span class="line"><span class="keyword">if</span> (!isSelected) &#123;</span><br><span class="line">selectionModel-&gt;<span class="built_in">select</span>(index, QItemSelectionModel::Select);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">selectionModel-&gt;<span class="built_in">select</span>(index, QItemSelectionModel::Deselect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> QStyledItemDelegate::<span class="built_in">editorEvent</span>(event, model, option, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">QListView* listView;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-效果图"><a href="#4-效果图" class="headerlink" title="4.效果图"></a>4.效果图</h2><img src="/2025/01/06/Qt%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%97%E8%A1%A8%E6%8E%A7%E4%BB%B6%E4%B9%8BQListView%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E4%BC%98%E7%82%B9/image-20241225153907663.png" class="" title="image-20241225153907663"><img src="/2025/01/06/Qt%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%97%E8%A1%A8%E6%8E%A7%E4%BB%B6%E4%B9%8BQListView%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E4%BC%98%E7%82%B9/image-20241225153943414.png" class="" title="image-20241225153943414"><img src="/2025/01/06/Qt%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%97%E8%A1%A8%E6%8E%A7%E4%BB%B6%E4%B9%8BQListView%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E4%BC%98%E7%82%B9/image-20241225154833298.png" class="" title="image-20241225154833298">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Qt高性能列表控件之QListView的使用及优点&quot;&gt;&lt;a href=&quot;#Qt高性能列表控件之QListView的使用及优点&quot; class=&quot;headerlink&quot; title=&quot;Qt高性能列表控件之QListView的使用及优点&quot;&gt;&lt;/a&gt;Qt高性能列表控件之Q</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>QCheckBox的三态复选框和反选</title>
    <link href="https://cpp-memory-leaks.github.io/2024/12/25/QCheckBox%E7%9A%84%E4%B8%89%E6%80%81%E5%A4%8D%E9%80%89%E6%A1%86%E5%92%8C%E5%8F%8D%E9%80%89/"/>
    <id>https://cpp-memory-leaks.github.io/2024/12/25/QCheckBox%E7%9A%84%E4%B8%89%E6%80%81%E5%A4%8D%E9%80%89%E6%A1%86%E5%92%8C%E5%8F%8D%E9%80%89/</id>
    <published>2024-12-25T11:10:56.000Z</published>
    <updated>2025-03-17T12:10:21.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="QCheckBox的三态复选框以及反选"><a href="#QCheckBox的三态复选框以及反选" class="headerlink" title="QCheckBox的三态复选框以及反选"></a>QCheckBox的三态复选框以及反选</h1><p>在使用这个控件的时候，需求有可能是：<strong>点击复选框实线反选，并且选中项目的时候需要显示未选中、部分选中和全选</strong>。在这个需求当中，首先想到的是直接启用三态复选框，但是点击的时候就变成了可以点三次，这就和反选冲突了。</p><h2 id="1-QCheckBox的三种状态："><a href="#1-QCheckBox的三种状态：" class="headerlink" title="1.QCheckBox的三种状态："></a>1.QCheckBox的三种状态：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">CheckState</span> &#123;</span><br><span class="line">    Unchecked,</span><br><span class="line">    PartiallyChecked,</span><br><span class="line">    Checked</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-如何启用三态复选框"><a href="#2-如何启用三态复选框" class="headerlink" title="2.如何启用三态复选框"></a>2.如何启用三态复选框</h2><p>使用setTristate(true)即可开启，使用void QCheckBox::setCheckState(<a href="../qtcore/qt.html#CheckState-enum">Qt::CheckState</a> <em>state</em>)参数为Qt::PartiallyChecked也会启用三态</p><img src="/2024/12/25/QCheckBox%E7%9A%84%E4%B8%89%E6%80%81%E5%A4%8D%E9%80%89%E6%A1%86%E5%92%8C%E5%8F%8D%E9%80%89/image-20241225165142718.png" class="" title="image-20241225165142718"><h2 id="3-如何实现需求"><a href="#3-如何实现需求" class="headerlink" title="3.如何实现需求"></a>3.如何实现需求</h2><p>显示选中状态：选择项目的时候根据选中情况设置QCheckBox的状态（如在QListView中可以通过QItemSelectionModel::selectionChanged信号实时统计）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (selectedItems == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ui-&gt;checkBox_select-&gt;<span class="built_in">setCheckState</span>(Qt::Unchecked);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (selectedItems &lt; totalItems)</span><br><span class="line">&#123;</span><br><span class="line">ui-&gt;checkBox_select-&gt;<span class="built_in">setCheckState</span>(Qt::PartiallyChecked);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ui-&gt;checkBox_select-&gt;<span class="built_in">setCheckState</span>(Qt::Checked);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反选：点击checkBox后关掉三态，当你再次触发selectionChanged时三态复选框重新启用，即可实现实时选中及反选功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ui-&gt;checkBox_select, &amp;QCheckBox::clicked, <span class="keyword">this</span>, &amp;MainWindow::selectAll);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PhoneToPCPage::selectAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ui-&gt;checkBox_select-&gt;<span class="built_in">setTristate</span>(<span class="literal">false</span>);</span><br><span class="line">QListView* listView = <span class="built_in">getListView</span>();</span><br><span class="line"><span class="keyword">if</span> (listView == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">QItemSelectionModel* selectionModel = listView-&gt;<span class="built_in">selectionModel</span>();</span><br><span class="line">QAbstractItemModel* model = listView-&gt;<span class="built_in">model</span>();</span><br><span class="line"><span class="type">bool</span> selectAll = ui-&gt;checkBox_select-&gt;<span class="built_in">checkState</span>() == Qt::Checked;</span><br><span class="line"><span class="keyword">if</span> (selectAll) &#123;</span><br><span class="line">QItemSelection selection;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; model-&gt;<span class="built_in">rowCount</span>(); ++row) &#123;</span><br><span class="line">QModelIndex index = model-&gt;<span class="built_in">index</span>(row, <span class="number">0</span>);</span><br><span class="line">selection.<span class="built_in">select</span>(index, index);</span><br><span class="line">&#125;</span><br><span class="line">selectionModel-&gt;<span class="built_in">select</span>(selection, QItemSelectionModel::Select);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">selectionModel-&gt;<span class="built_in">clearSelection</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-效果图"><a href="#3-效果图" class="headerlink" title="3.效果图"></a>3.效果图</h2><img src="/2024/12/25/QCheckBox%E7%9A%84%E4%B8%89%E6%80%81%E5%A4%8D%E9%80%89%E6%A1%86%E5%92%8C%E5%8F%8D%E9%80%89/image-20241225170603608.png" class="" title="image-20241225170603608"><img src="/2024/12/25/QCheckBox%E7%9A%84%E4%B8%89%E6%80%81%E5%A4%8D%E9%80%89%E6%A1%86%E5%92%8C%E5%8F%8D%E9%80%89/image-20241225170618346.png" class="" title="image-20241225170618346"><img src="/2024/12/25/QCheckBox%E7%9A%84%E4%B8%89%E6%80%81%E5%A4%8D%E9%80%89%E6%A1%86%E5%92%8C%E5%8F%8D%E9%80%89/image-20241225170629562.png" class="" title="image-20241225170629562">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;QCheckBox的三态复选框以及反选&quot;&gt;&lt;a href=&quot;#QCheckBox的三态复选框以及反选&quot; class=&quot;headerlink&quot; title=&quot;QCheckBox的三态复选框以及反选&quot;&gt;&lt;/a&gt;QCheckBox的三态复选框以及反选&lt;/h1&gt;&lt;p&gt;在使</summary>
      
    
    
    
    <category term="Qt" scheme="https://cpp-memory-leaks.github.io/categories/Qt/"/>
    
    
  </entry>
  
  <entry>
    <title>学习和工作过程中总结到的代码规范</title>
    <link href="https://cpp-memory-leaks.github.io/2024/08/07/CodeStyle/"/>
    <id>https://cpp-memory-leaks.github.io/2024/08/07/CodeStyle/</id>
    <published>2024-08-07T10:57:16.000Z</published>
    <updated>2025-03-17T12:12:15.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. <strong>概述</strong></h2><p>旨在提高代码的可读性、可维护性，特此制定本规范。参考《Google C++ Style Guide》以及《Effective C++》等规范基础上，结合项目开发经验，汇总整理成本规范。</p><h2 id="2-头文件"><a href="#2-头文件" class="headerlink" title="2. 头文件"></a>2. <strong>头文件</strong></h2><h3 id="2-1-头文件保护"><a href="#2-1-头文件保护" class="headerlink" title="2.1 头文件保护"></a>2.1 <strong>头文件保护</strong></h3><p>所有头文件都应该使用****#define****防止头文件被重复包含，命名格式为<FileName>_H，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><h3 id="2-2前置声明"><a href="#2-2前置声明" class="headerlink" title="2.2前置声明"></a>2.2<strong>前置声明</strong></h3><p>“前置声明”是类、函数和模板的纯粹声明，没伴随着其定义。</p><p>在头文件中进行前置声明，可以减少****#include****的数量，避免多重包含，减少头文件展开的次数，有效的提高编译效率。对于库工程使用前置声明，可以减少内部类的导出。</p><p><em><strong>*注意：前置类型的类是不完全类型，只能定义指向该类型的指针或引用，或者声明(但不能定义)以不完全类型作为参数或者返回类型的函数。*</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;QJsonValue&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;QJsonObject&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用前置声明形式代替</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QJsonValue</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QJsonObject</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 库工程不希望导出的内部类才使用前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IDictionaryPrivate</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SVSEMSHARE_EXPORT</span> IDictionary : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> QString&amp; key, <span class="type">const</span> QJsonValue&amp; value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> QJsonObject&amp; valus)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-3内联函数"><a href="#2-3内联函数" class="headerlink" title="2.3内联函数"></a>2.3<strong>内联函数</strong></h3><p>当函数被声明为内联函数之后，编译器会将其内联展开，而不是按通常的函数调用机制进行调用。</p><p><em><strong>*只要当函数只有1*</strong></em><em><strong>*0*</strong></em>****行甚至更少时才将其定义为内联函数****，只有内联的函数体较小，内联该函数才可以令目标代码更加高效。对于存取函数以及其他函数比较短，性能关键的函数，鼓励使用内联。</p><p><em><strong>*注意：不要内联包含循环或switch语句的函数，可能导致增加代码大小。*</strong></em></p><h3 id="2-4-include的路径及次序"><a href="#2-4-include的路径及次序" class="headerlink" title="2.4**#include的路径及次序**"></a>2.4**#include的路径及次序**</h3><p>项目内的头文件按照项目源代码目录树结构排列，头文件包含顺序****项目内头文件*<em><strong>、</strong></em>*其他库头文件*<em><strong>、</strong></em>*Qt库*<em><strong>、</strong></em>*C++库****、C库，通过空行分隔相关头文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 项目内头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Base/NameSpace.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他库头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foo/bar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Qt库头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++库头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C库头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="3-作用域"><a href="#3-作用域" class="headerlink" title="3. 作用域"></a>3. <strong>作用域</strong></h2><h3 id="3-1-命名空间"><a href="#3-1-命名空间" class="headerlink" title="3.1 命名空间"></a>3.1 <strong>命名空间</strong></h3><p>命名空间将全局作用域细分为独立的、具名的作用域，可以有效防止全局作用域的命名冲突。举例来说，两个不同项目的全局作用域都有一个类Foo，这样在编译或运行时会造成冲突。如果每个项目将代码置于不同命名空间中，project1::Foo和project2::Foo作为不同符号自然不会冲突。命名方式参考<a href="#_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%91%BD%E5%90%8D">7.7 命名空间命名</a>，使用方式如下：</p><p>全局定义宏包括了以下，所有项目内开发头文件均包含以下内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NameSpace.h</span></span><br><span class="line"><span class="comment">/** 命名空间定义</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIQTEK_NAMESPACE ciqtek</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 命名空间开始</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEGIN_NAMESPACE_CIQTEK namespace CIQTEK_NAMESPACE &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 命名空间结束</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> END_NAMESPACE_CIQTEK &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 命名空间修饰符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIQTEK_QUALIFIER     ::CIQTEK_NAMESPACE::</span></span><br></pre></td></tr></table></figure><p>根据全局定义宏文件，头文件以及源文件遵循以下规则编写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h文件</span></span><br><span class="line">BEGIN_NAMESPACE_CIQTEK</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有声明(前置声明除外)都置于命名空间中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">END_NAMESPACE_CIQTEK</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp文件</span></span><br><span class="line">BEGIN_NAMESPACE_CIQTEK</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义都至于命名空间中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BEGIN_NAMESPACE_CIQTEK</span><br></pre></td></tr></table></figure><p><strong>结论：</strong></p><p>不建议使用using指示引入整个命名空间的标识符号，在.cpp和.h文件的函数、方法或者类中，可以使用using声明；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在.cpp文件中</span></span><br><span class="line"><span class="comment">// .h文件的话,必须在函数,方法或类的内部使用</span></span><br><span class="line"><span class="keyword">using</span> ::foo::bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不建议 -- 污染命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> foo;</span><br></pre></td></tr></table></figure><p><strong>不要在头文件中使用命名空间别名</strong>，因为头文件的别名对包含了该头文件的所有人可见，所以递归包含到其他头文件里；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用别名缩短常用的命名空间——可以在.cpp文件</span></span><br><span class="line"><span class="comment">// .h文件的话,必须在函数,方法或类的内部使用,否则污染命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> fbz = ::foo::bar::baz;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在.h文件里</span></span><br><span class="line"><span class="keyword">namespace</span> librarian &#123;</span><br><span class="line"><span class="comment">// 以下别名在所有包含了该头文件的文件中生效</span></span><br><span class="line"><span class="keyword">namespace</span> pd_s = ::pipeline_diagnostics::sidetable;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">my_inline_function</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 在函数(方法)使用命名别名,限制在函数中</span></span><br><span class="line"><span class="keyword">namespace</span> fbz = ::foo::bar::baz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace librarian</span></span><br></pre></td></tr></table></figure><h3 id="3-2非成员函数、静态成员函数和全局函数"><a href="#3-2非成员函数、静态成员函数和全局函数" class="headerlink" title="3.2非成员函数、静态成员函数和全局函数"></a>3.2<strong>非成员函数、静态成员函数和全局函数</strong></h3><p>使用静态成员函数或命名空间内的非成员函数，尽量不要用裸的全局函数。将一些列函数直接至于命名空间，不要用类的静态函数模拟出命名空间的效果，类的静态方法应该和类的实例或数据紧密相关。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="keyword">namespace</span> foo_bar &#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;  <span class="comment">// namespace foo_bar</span></span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐,类的内部并没有静态变量,类的实体也没具体功能</span></span><br><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></table></figure><h3 id="3-3局部变量"><a href="#3-3局部变量" class="headerlink" title="3.3局部变量"></a>3.3<strong>局部变量</strong></h3><p>尽量将函数变量****尽可能置于最小作用域内，并在变量声明时进行初始化****。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line">i = <span class="built_in">f</span>(); <span class="comment">// 不推荐——初始化和声明分离</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> j = <span class="built_in">g</span>(); <span class="comment">// 推荐——初始化时声明</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">// 不推荐——用花括号初始化更好</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 推荐——v 一开始就初始化</span></span><br></pre></td></tr></table></figure><p>属于while和for语句的变量尽量在这些语句中正常地声明，这样变量的作用域就被限制在这些语句中了，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在作用域内声明</span></span><br><span class="line"><span class="keyword">while</span> (<span class="type">const</span> <span class="type">char</span>* p = <span class="built_in">strchr</span>(str, <span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">str = p + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果变量是一个对象,则不适用该方法</span></span><br><span class="line"><span class="comment">// 低效的实现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    Foo f;                  <span class="comment">// 构造函数和析构函数分别调用 1000000 次!</span></span><br><span class="line">    f.<span class="built_in">DoSomething</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应该作用域外声明</span></span><br><span class="line">Foo f;                      <span class="comment">// 构造函数和析构函数只调用 1 次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    f.<span class="built_in">DoSomething</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-类"><a href="#4-类" class="headerlink" title="4. 类"></a>4. <strong>类</strong></h2><h3 id="4-1-构造函数的职责"><a href="#4-1-构造函数的职责" class="headerlink" title="4.1 构造函数的职责"></a>4.1 <strong>构造函数的职责</strong></h3><p>****构造函数不得调用虚函数*<em><strong>，如果在构造函数内调用了自身的虚函数，这类调用是不会重定向到子类的虚函数实现的，即当前没有子类化实现，存在隐患。</strong></em>*构造函数不能报告一个非致命错误*<em><strong>，即</strong></em>*构造函数必须成功****，不然会获得一个初始化失败的对象，有可能进入不正常的状态。</p><p>如果对象需要进行初始化，考虑使用明确的<em><strong>*init*</strong></em>****()*<em><strong>方法或使用</strong></em>*工厂模式****。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init方法形式, 需要在类的注释里说明用法</span></span><br><span class="line">&#123;</span><br><span class="line">    Foo *foo = <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line">    <span class="keyword">if</span> (!foo-&gt;<span class="built_in">init</span>()) &#123;</span><br><span class="line">        <span class="keyword">delete</span> foo;</span><br><span class="line">        foo = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐,容易误用 — 工厂方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Foo *<span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Foo *foo = <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line">        <span class="keyword">if</span> (!foo-&gt;<span class="built_in">init</span>()) &#123;</span><br><span class="line">            <span class="keyword">delete</span> foo;</span><br><span class="line">            foo = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> foo;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    Foo *foo = Foo::<span class="built_in">create</span>();</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">nullptr</span> != foo) &#123; <span class="comment">// 功能逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2初始化"><a href="#4-2初始化" class="headerlink" title="4.2初始化"></a>4.2<strong>初始化</strong></h3><p>如果类中定义了成员变量，则必须在类中为每个类提供初始化函数或定义一个构造函数。若未声明构造函数，则编译器会生成一个默认的构造函数，这有可能导致某些成员未被初始化或初始化未不恰当的值。</p><p>所以，<em><strong>*确保构造函数将对象的每一个成员变量进行了初始化，且初始化顺序和声明顺序保持一致。*</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ABEntry</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ABEntry</span>(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> std::string &amp;address,</span><br><span class="line">            <span class="type">const</span> std::List&lt;PhoneNumber&gt;&amp; phones);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;</span><br><span class="line">    std::string theAddress;</span><br><span class="line">    std::list&lt;PhoneNumber&gt; thePhones;</span><br><span class="line">    <span class="type">int</span> numTimesConsulted;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐写法 —— 会导致多调用赋值操作函数降低效率</span></span><br><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> std::string &amp;address,</span><br><span class="line">                 <span class="type">const</span> std::List&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">&#123;</span><br><span class="line">    theName = name;             <span class="comment">// 这些是赋值操作</span></span><br><span class="line">    theAddress = address;       <span class="comment">// 而非初始化</span></span><br><span class="line">    thePhones = phones;</span><br><span class="line">    numTimesConsulted = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐写法 —— 只调用拷贝构造函数</span></span><br><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> std::string &amp;address,</span><br><span class="line">                 <span class="type">const</span> std::List&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">    : <span class="built_in">theName</span>(name),            <span class="comment">// 这些是初始化操作</span></span><br><span class="line">      <span class="built_in">theAddress</span>(address),</span><br><span class="line">      <span class="built_in">thePhones</span>(phones),</span><br><span class="line">      <span class="built_in">numTimesConsulted</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者在类的成员变量声明时进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ABEntry</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 不需要对变量进行初始化</span></span><br><span class="line">    <span class="built_in">ABEntry</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">ABEntry</span>(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> std::string &amp;address,</span><br><span class="line">            <span class="type">const</span> std::List&lt;PhoneNumber&gt;&amp; phones) </span><br><span class="line">    : <span class="built_in">theName</span>(name), <span class="built_in">theAddress</span>(address),      <span class="comment">// 重复操作,会覆盖初值</span></span><br><span class="line">      <span class="built_in">thePhones</span>(phones), <span class="built_in">numTimesConsulted</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 在声明时就初始化成员变量</span></span><br><span class="line">    std::string theName&#123;<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">    std::string theAddress&#123;<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">    std::list&lt;PhoneNumber&gt; thePhones&#123;&#125;;</span><br><span class="line">    <span class="type">int</span> numTimesConsulted = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-3-显式构造函数"><a href="#4-3-显式构造函数" class="headerlink" title="4.3  显式构造函数"></a>4.3  <strong>显式构造函数</strong></h3><p>对于单个参数的构造函数，不要定义为隐式类型转换，使用C++关键字<em><strong>*e*</strong></em>****xplicit****。</p><p>****隐式类型转换：****即允许某种类型(称作 源类型)的对象被用于需要另一种类型(称作 目的类型)。例如将一个int类型的参数传递给需要double类型的函数。通常只有一个参数的构造函数，被看作是一种隐式转换。</p><p>除了单参数构造函数外，也适用于除第一个参数以外的其他参数都具有默认参数的构造函数，例如Foo::Foo(string name, int id &#x3D; 42)。****拷贝和移动构造函数****不需要被标记为explicit，因为它们并不进行类型转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 以下都需要进行explicit进行显示转换</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Foo</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Foo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> a, <span class="type">const</span> <span class="type">int</span> b = <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 不需要使用explicit</span></span><br><span class="line"><span class="built_in">Foo</span>(<span class="type">const</span> <span class="type">int</span> a, <span class="type">const</span> <span class="type">float</span> b);</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;);        <span class="comment">// 拷贝构造</span></span><br><span class="line">    <span class="built_in">Foo</span>(Foo&amp;&amp;);             <span class="comment">// 移动构造</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当设计目的用于其他类型进行透明封装的类来说，隐式类型转换是合适的，例如QJsonValue和QVariant。</p><h3 id="4-4-结构体-VS-类"><a href="#4-4-结构体-VS-类" class="headerlink" title="4.4 结构体** VS. 类"></a>4.4 结构体** <strong>VS</strong><strong>.</strong> <strong>类</strong></h3><p>在C++中struct和class关键词几乎含义一样。对两个关键字进行进一步规定是，<em><strong>*struct用来定义包含数据的被动式对象，也可以包含相关的常量*<em><strong>。但除了存取数据成员以外，没有别的操作函数功能。并且</strong></em>*存取功能通过直接访问位域，而非函数调用*<em><strong>。除了构</strong></em>*造函数、析构函数、initialize初始化数据、reset重置数据、operator&#x3D;&#x3D;数据对比操作符重载等</strong></em>*类似用于设定数据成员的函数外，不能提供其他功能函数*<em><strong>。</strong></em>*如果需要更多函数功能，使用class代替struct****。</p><h3 id="4-5-接口"><a href="#4-5-接口" class="headerlink" title="4.5 接口"></a>4.5 <strong>接口</strong></h3><p>当一个类满足以下要求时，称之为纯接口。类应以I为开头命名，如IFoo。</p><ul><li>l 只有纯虚函数(“&#x3D;0”)和静态函数(析构函数除外)；</li><li>l 没有定义任何构造函数。如果有，也不能带有参数，并且必须为****protected****；</li><li>l 如果它是一个子类，也只能从满足上述条件的类继承。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类为非接口类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误 —— 基类非接口类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IBar</span> : <span class="keyword">public</span> Foo</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有纯虚函数 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IProcessCommunicationCallback</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onConnected</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onDisconnected</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承于接口类才能定义为接口类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IBar</span> : <span class="keyword">public</span> IProcessCommunicationCallback</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以I为前缀可以提醒该类为纯接口类，这一点对于****多重继承****尤其重要。</p><p>​    由于接口类不能被直接实例化，为确保接口类的所有实现可被正确销毁，必须为之声明****虚析构函数****。</p><h3 id="4-6继承"><a href="#4-6继承" class="headerlink" title="4.6继承"></a>4.6继承</h3><p>当子类继承基类时，子类包含了父基类所有数据及操作的定义。继承主要用于两种场景：实现继承，子类继承父类的实现代码；接口继承，子类仅继承父类的接口名称。</p><p>****尽量使用public继承，不要使用private继承，而应该替换成把类的实例作为成员对象的方式****。避免过度使用继承，要尽量做到只在“是一种”的情况下使用继承，例如QFrame是“是一种”控件，QFrame继承于QWidget。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> : <span class="keyword">private</span> Foo <span class="comment">// 禁止</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; <span class="built_in">foo</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; f.<span class="built_in">foo</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Foo f&#123;&#125;;    <span class="comment">// 应该以类的成员变量形式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果类确定存在继承关系，作为基类应该将****析构函数***<em>声明为virtual。相反，当类的设计目的不是作为基类，或不具有多态性，就不将析构函数声明为</em>virtual*。而当类中存在虚函数，则析构函数也应该声明为virtual。</p><p><em><strong>*注意：析构函数与构造函数相同，也不应该调用虚函数或者发生错误。*</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为基类,必须将析构函数声明为virtual</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类中存在virtual函数,必须将析构函数声明为virtual</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Foo</span>();       <span class="comment">// 定义虚函数foo,析构函数声明为virtual</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-7多重继承"><a href="#4-7多重继承" class="headerlink" title="4.7多重继承"></a>4.7多重继承</h3><p>只有以下情况允许多重继承：****只有一个基类是非抽象类，其他基类都是以I为前缀的纯接口类。****继承顺序应从非抽象类，再到纯接口类的顺序进行继承。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IBar</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误 —— Foo和Bar都是非抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Baz</span> : <span class="keyword">public</span> Foo, <span class="keyword">public</span> Bar</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确 —— Foo为非抽象类,IBar为纯接口类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Baz</span> : <span class="keyword">public</span> Foo, <span class="keyword">public</span> IBar</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-8-声明顺序"><a href="#4-8-声明顺序" class="headerlink" title="4.8 声明顺序**"></a>4.8 声明顺序**</h3><p>类的访问控制区段的声明为：public:、protected:、private:。如果某区段没有内容可以不声明，注释方式参考<a href="#_%E6%B3%A8%E9%87%8A">8. 注释</a>。每个区段内的声明通常按以下顺序：</p><ul><li>l typedefs和枚举</li><li>l 常量</li><li>l 构造函数</li><li>l 析构函数</li><li>l 成员函数，包含静态成员函数</li><li>l 槽函数(公有继承后跟信号)</li><li>l 数据成员，包含静态数据成员</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Q_OBJECT</span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(<span class="type">int</span> m_foo READ foo)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span>:</span></span><br><span class="line"><span class="function">    // 公有成员</span></span><br><span class="line"><span class="function">    Foo();</span></span><br><span class="line">    ~<span class="built_in">Foo</span>();</span><br><span class="line">    <span class="comment">// 成员函数，包含静态成员函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> Q_SLOTS:</span><br><span class="line">    <span class="comment">// 公有槽函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">slotFoo</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">Q_SIGNALS:</span><br><span class="line">    <span class="comment">// 信号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">signalFoo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 保护成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Q_SLOTS:</span><br><span class="line">    <span class="comment">// 保护槽函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">slotBar</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">baz</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> Q_SLOTS:</span><br><span class="line">    <span class="comment">// 私有槽函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">slotBar</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有成员,友元类</span></span><br><span class="line">    <span class="type">int</span> m_foo;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">faz</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-9存取控制"><a href="#4-9存取控制" class="headerlink" title="4.9存取控制"></a>4.9<strong>存取控制</strong></h3><p>将****所有数据成员*<em><strong>声明为</strong></em>*private****，并根据需要提供响应的存取函数。静态常量数据成员可以不是私有成员。</p><p>存取函数一般在头文件中定义为内联函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getBar</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">setBar</span><span class="params">(<span class="type">const</span> <span class="type">int</span> value)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_bar;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-函数"><a href="#5-函数" class="headerlink" title="5. 函数"></a>5. <strong>函数</strong></h2><p>函数命名规则参考<a href="#_%E5%87%BD%E6%95%B0%E5%91%BD%E5%90%8D">7.6函数命名</a>。</p><h3 id="5-1-参数"><a href="#5-1-参数" class="headerlink" title="5.1 参数"></a>5.1 <strong>参数</strong></h3><p>函数的参数顺序为：输入参数在前，输出参数包含输入输出参数在后</p><p>C&#x2F;C++中的函数参数可能是输入参数，也可能是输出参数，或者是输入输出参数。输入参数通常是****const值传递***<em>或者const引用或指针*<strong>，输出参数或输入输出参数则为</strong></em>*非const指针或引用****。更多说明参考<a href="#_const%E7%94%A8%E6%B3%95">6.4 const用法</a>。</p><p>在加入新参数时不要因为它们时新参数就置于参数列表最后，而是仍然要按照输入参数在前，输入参数在后的原则。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 内置类型输入参数或者STL的迭代器,用const值传递</span></span><br><span class="line">    <span class="comment">// baz作为输出参数用非const指针形式传入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> <span class="type">int</span> bar, <span class="type">float</span> *baz)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *bar, <span class="type">float</span> *baz)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> std::vector::iterator iter, <span class="type">float</span> *baz)</span></span>;</span><br><span class="line">    <span class="comment">// 当输入参数为对象,则用const引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> std::string&amp; bar, <span class="type">float</span> *baz)</span></span>;<span class="comment">// 推荐—直观看出输入/输出参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> std::string&amp; bar, <span class="type">float</span> &amp;baz)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em><strong>*注意：这一条不是硬性规定，属于推荐写法，实际情况复杂时，可以进行更改。*</strong></em></p><h3 id="5-2编写简短函数"><a href="#5-2编写简短函数" class="headerlink" title="5.2编写简短函数"></a>5.2<strong>编写简短函数</strong></h3><p>函数的编写尽量简练。目的是使函数实现的逻辑结构化、清晰化，便于阅读与维护。</p><p>如果函数行数太多(超过40行，后成为长函数)，可以考虑将长函数拆分成几个短函数，是函数尽量简短，便于阅读和维护。</p><p><em><strong>*注意：长函数按照具体情况而定，例如对于部分if和switch逻辑，分支过长就不遵行本条规定。*</strong></em></p><h2 id="6-其他C-特性"><a href="#6-其他C-特性" class="headerlink" title="6. 其他C++特性"></a>6. <strong>其他C++特性</strong></h2><h3 id="6-1-异常"><a href="#6-1-异常" class="headerlink" title="6.1 异常"></a>6.1 <strong>异常</strong></h3><p><em><strong>*禁止C++异常机制*<em><strong>，所有错误都应该通过错误值在函数之间传递并做出相应判断，而不应该通过异常进行错误处理。</strong></em>*例外：在接管C*</strong></em><em><strong>*++*</strong></em><em><strong>*语言本身抛出的异常(例如new失败、S*</strong></em><em><strong>*TL)*</strong></em><em><strong>*、第三方库(例如Qt*</strong></em><em><strong>*)*</strong></em>****抛出的异常时，可以使用异常机制****。</p><p>面对异常首先考虑是否为操作错误，例如参数范围问题，应该在代码进行入参检测；例如Qt库中出现私有类指针为野指针，应该从析构问题解决；这些问题都不应该从接异常解决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = ...;</span><br><span class="line"><span class="type">char</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (bad_alloc) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-类型转换"><a href="#6-2-类型转换" class="headerlink" title="6.2 类型转换"></a>6.2 <strong>类型转换</strong></h3><p>使用C++的类型转换，如static_cast&lt;&gt;()。而不是使用int y &#x3D; (int)x或int y &#x3D; int(x)等转换形式。即****不要使用C风格进行类型转换，而应该使用C++**风格****。</p><ul><li>l 用static_cast替代C风格的值转换，或某个类的指针需要明确向上转换为父类指针；</li><li>l 用const_cast去掉const限定符；</li><li>l 用reinterpret_cast指针类型和整型和其他类型指针进行转换；</li><li>l 用dynamic_cast转换存在继承关系的对象。</li></ul><h3 id="6-3前置自增和自减"><a href="#6-3前置自增和自减" class="headerlink" title="6.3前置自增和自减"></a>6.3<strong>前置自增和自减</strong></h3><p><em><strong>*对于迭代器和其他模板类型使用前缀形式(++i)*<strong>的自增、自减运算符，对于简单数值*</strong></strong></em><em>*(*</em><em><strong><strong>*非对象*</strong></strong></em><em>*)*</em>******，两种都无所谓****。在不考虑返回值的情况，前置自增(++i)通常要比后置自增(i++)效率更高。因为后置自增(或自减)需要对表达式的值i进行一次拷贝。如果i是迭代器或其他非数值类型，拷贝的代价比较大。所以推荐使用前置自增。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector vec;</span><br><span class="line"><span class="keyword">for</span>(std::vector::iterator iter = vec.<span class="built_in">begin</span>();</span><br><span class="line">    iter != vec.<span class="built_in">end</span>(); ++iter); <span class="comment">// 推荐 —— 效率更高</span></span><br><span class="line"><span class="keyword">for</span>(std::vector::iterator iter = vec.<span class="built_in">begin</span>();</span><br><span class="line">    iter != vec.<span class="built_in">end</span>(); iter++); <span class="comment">// 不推荐 —— 需要进行多次拷贝构造</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 简单数值(内置类型),两者均可</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++); </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i); <span class="comment">// 更推荐,保证习惯一致</span></span><br></pre></td></tr></table></figure><h3 id="6-4-const用法"><a href="#6-4-const用法" class="headerlink" title="6.4 const用法"></a>6.4 <strong>const用法</strong></h3><p>const变量、数据成员、函数和参数为编译时进行类型检测增加了一道屏障，便于尽早发现问题，参考<a href="#_%E5%8F%82%E6%95%B0">5.1 参数</a>。因此尽可能的情况下使用const，参考：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getBar</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_bar; &#125; <span class="comment">// 访问函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setBar</span><span class="params">(<span class="type">const</span> <span class="type">int</span> b)</span></span>; &#123; m_bar = b &#125;; <span class="comment">// 函数传入不会修改的参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sum</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">getBar</span>() + m_CONST_VALUE; &#125; <span class="comment">// 未调用非const函数</span></span><br><span class="line"><span class="function"><span class="type">const</span> Bar&amp; <span class="title">getCBar</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_cBar; &#125; <span class="comment">// 返回const引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_bar;</span><br><span class="line">Bar m_cBar;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> m_CONST_VALUE = <span class="number">10</span>; <span class="comment">// 构造之后不会修改的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>l 如果函数不会修改传入的引用或指针类型参数，该参数应声明为const；</li><li>l 尽可能将函数声明为const。访问函数应该总是const。其他不会修改任何数据成员，未调用非const函数，返回数据成员为指针或引用也应该声明成const；</li><li>l 如果数据成员在对象构造之后不再发生变化，可将其定义未const。</li></ul><h3 id="6-5-预处理宏"><a href="#6-5-预处理宏" class="headerlink" title="6.5 预处理宏"></a>6.5 <strong>预处理宏</strong></h3><p>宏意味着你和编译器看到的代码时不同的，这可能会导致异常行为，而且宏具有全局作用域。尽量****以内联函数、枚举和常量代替宏定义****。命名规则参考<a href="#_%E5%B8%B8%E9%87%8F%E5%91%BD%E5%90%8D">7.5 常量命名</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const替换#define</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASPECT_RATIO 1.653</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> ASPECT_RATIO = <span class="number">1.653</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AUTHOR_NAME <span class="string">&quot;Scott Meyers&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> std::string <span class="title">AUTHOR_NAME</span><span class="params">(<span class="string">&quot;Scott Meyers&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inline替换#define</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_MAX(a,b) f((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a, b);       <span class="comment">// a被累加两次</span></span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a, b + <span class="number">10</span>);  <span class="comment">// a被累加一次</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">callWithMax</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// enum替换#define</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_TURNS 5</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CostEstimate</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> scores[NUM_TURNS];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CostEstimate</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; NumTurns = <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="type">int</span> scores[NumTurns];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-6-sieof"><a href="#6-6-sieof" class="headerlink" title="6.6 sieof"></a>6.6 <strong>sieof</strong></h3><p>尽可能用sizeof(varname)代替sizeof(type)。使用sizeof(varname)时因为当代码中变量类型改变时会自动更新。当用sizeof(type)处理不涉及任何变量的代码，比如处理来自外部或内部的数据格式时，sizeof(varname)就不适用了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Struct data;</span><br><span class="line"><span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="built_in">sizeof</span>(data));     <span class="comment">// 推荐 —— 当data改成其他类型时不影响运行</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="built_in">sizeof</span>(Struct));   <span class="comment">// 不推荐 —— 改为其他类型未做修改可能导致BUG</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不适用sizeof(varname)情况</span></span><br><span class="line"><span class="keyword">if</span> (raw_size &lt; <span class="built_in">sizeof</span>(<span class="type">int</span>)) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;compressed record not big enough for count:&quot;</span> &lt;&lt; raw_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-7-auto"><a href="#6-7-auto" class="headerlink" title="6.7 auto"></a>6.7 <strong>auto</strong></h3><p>C++11中，若变量被声明为auto，类型就会被自动匹配成初始化表达式的类型。用auto绕过繁琐的类型名，只要可读性好就可以使用，但不要用在局部变量之外的地方。****auto不要用在初始化列表*<em><strong>，会导致歧义，同时要注意区分</strong></em>*auto**<em>和const</em> *<strong>auto</strong>&amp;*。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 涉及模板类或命名空间时,类型名会很复杂</span></span><br><span class="line">sparse_hash_map&lt;string, <span class="type">int</span>&gt;::iterator iter = m.<span class="built_in">find</span>(val);</span><br><span class="line"><span class="comment">// 修改为auto显得直观(因为iter一般是迭代器变量,即m的迭代器)</span></span><br><span class="line"><span class="keyword">auto</span> iter = m.<span class="built_in">find</span>(val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有auto的话，我们不得不在同一个表达式出现两次类型名</span></span><br><span class="line">diagnostics::ErrorStatus* status = <span class="keyword">new</span> diagnostics::<span class="built_in">ErrorStatus</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line"><span class="comment">// 使用auto就简单且不会有歧义</span></span><br><span class="line"><span class="keyword">auto</span> status = <span class="keyword">new</span> diagnostics::<span class="built_in">ErrorStatus</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> i = x.<span class="built_in">Lookup</span>(key); <span class="comment">// 不推荐 —— 代码不能直观看出i是何种类型</span></span><br><span class="line">vector&lt;string&gt; v;</span><br><span class="line"><span class="keyword">auto</span> s1 = v[<span class="number">0</span>]; <span class="comment">// 创建一份v[0]的拷贝</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; s2 = v[<span class="number">0</span>]; <span class="comment">// s2是v[0]的一个引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// auto不要用在初始化列表</span></span><br><span class="line"><span class="keyword">auto</span> d = &#123;<span class="number">1.23</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> d&#123;<span class="number">1.23</span>&#125;;           <span class="comment">// d是std::initialzer_list&lt;double&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> d = <span class="type">double</span>&#123;<span class="number">1.23</span>&#125;;  <span class="comment">// d是double,并非std::initialzer_list</span></span><br></pre></td></tr></table></figure><h3 id="6-8-Lambda表达式"><a href="#6-8-Lambda表达式" class="headerlink" title="6.8 Lambda表达式"></a>6.8 <strong>Lambda表达式</strong></h3><p>Lambda表达式是创建匿名函数对象的一种简易途径，常用于把函数当参数传递，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Weight</span>(x) &lt; <span class="built_in">Weight</span>(y);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当Lambda变量需要捕获识，****禁止使用通用捕获，将所有的捕获都显式写出来****，增加可读性。使用引用捕获时，变量名和&amp;之间不留空格</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">[=](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x + n; &#125;    <span class="comment">// 不推荐—使用默认捕获</span></span><br><span class="line">[n](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x + n; &#125;    <span class="comment">// 推荐—显式捕获n写出来</span></span><br><span class="line">[&amp;n](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x + n; &#125;    <span class="comment">// &amp;和n不留空格</span></span><br></pre></td></tr></table></figure><p>Lambda表达式用于参数传递时，如果函数体超过五行，应当将Lambda表达式转换为std::function对象；如果是作为connect的槽函数，则改用函数的形式。</p><h2 id="7-命名约定"><a href="#7-命名约定" class="headerlink" title="7 命名约定"></a>7 <strong>命名约定</strong></h2><p>命名的风格能让我们在不需要去查找类型声明的条件下快速了解某个名字代表的含义：****类型、变量、函数、常量、宏、信号、槽函数****等等。</p><h3 id="7-1-通用命名约定"><a href="#7-1-通用命名约定" class="headerlink" title="7.1 通用命名约定"></a>7.1 <strong>通用命名约定</strong></h3><p>名称由****字母、数字以及下划线组合而成，且第一位不能为数字，小驼峰命名方式****。</p><p>尽量使用描述性的命名，少用缩写(除了一些广泛接受的缩写，例如iter表示迭代器、用T表示模板参数)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> priceCountReader;       <span class="comment">// 无缩写</span></span><br><span class="line"><span class="type">int</span> numError;               <span class="comment">// &quot;num&quot;是常见的缩写</span></span><br><span class="line"><span class="type">int</span> numDNSConnection;       <span class="comment">// DNS是都知道的概念</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;                      <span class="comment">// 不清楚作用和意义</span></span><br><span class="line"><span class="type">int</span> nCompConns;             <span class="comment">// 缩写不知道代表何种意思</span></span><br><span class="line"><span class="type">int</span> wgcConnections;         <span class="comment">// &quot;wgc&quot;是何种意思</span></span><br><span class="line"><span class="type">int</span> pcReader;               <span class="comment">// &quot;pc&quot;可能出现歧义</span></span><br><span class="line"><span class="type">int</span> cstmrID;                <span class="comment">// 缩写若干字母</span></span><br></pre></td></tr></table></figure><h3 id="7-2文件命名"><a href="#7-2文件命名" class="headerlink" title="7.2文件命名"></a>7.2<strong>文件命名</strong></h3><p>文件命名****使用大驼峰命名方式，定义类和文件名一般成对出现****。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NameSpace.h</span></span><br><span class="line"><span class="comment">// 文件名说明作用,如NameSpace.h存放关于NameSpace的声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 命名空间定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIQTEK_NAMESPACE ciqtek</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 命名空间开始</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEGIN_NAMESPACE_CIQTEK namespace CIQTEK_NAMESPACE &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 命名空间结束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> END_NAMESPACE_CIQTEK &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 命名空间修饰符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIQTEK_QUALIFIER     ::CIQTEK_NAMESPACE::</span></span><br><span class="line"><span class="comment">// AlgorithmAutogamma.h</span></span><br><span class="line"><span class="comment">// 文件名和类名一一对应,成对存在</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AlgorithmAutogamma</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="7-3-类型命名"><a href="#7-3-类型命名" class="headerlink" title="7.3 类型命名"></a>7.3 <strong>类型命名</strong></h3><p>类型命名的****每个单词首字母都是大写，不包含下划线，大驼峰命名方式****。所有类型命名——类、结构体、类型定义(typedef)、枚举、类型模板参数均使用本约定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类和结构体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UrlTable</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UrlTableTester</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UrlTableProperties</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// using 别名</span></span><br><span class="line"><span class="keyword">using</span> PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">UrlTableErrors</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型模板参数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> UrlInfo&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setUrl</span><span class="params">(<span class="type">const</span> UrlInfo&amp;)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="7-4-变量命名"><a href="#7-4-变量命名" class="headerlink" title="7.4 变量命名"></a>7.4 <strong>变量命名</strong></h3><p>变量(包含函数参数)和数据成员名****一律用小驼峰命名方式，每行一个变量，单字符的变量只在循环计数中使用****。对于不同作用域的变量遵循以下规则：</p><ul><li>l 类成员变量须在变量名前加m_前缀。</li><li>l 局部变量等到需要使用时再定义，且定义是必须要初始化，整数为0，实数用0.0，指针用nullptr，字符(串)用’\0’。</li><li>l 全局变量命名时须在变量前加g_前缀。</li><li>l 静态变量名以s_开头。</li></ul><table><thead><tr><th>前缀</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>无</td><td>局部变量(local)</td><td>oldValue</td></tr><tr><td>m_</td><td>类的成员变量(member)</td><td>int m_width</td></tr><tr><td>ms_</td><td>类的静态成员变量(static member)</td><td>static int ms_initValue</td></tr><tr><td>s_</td><td>静态变量(static)</td><td>static int s_initValue</td></tr><tr><td>g_</td><td>外部全局变量</td><td>int g_maxCount</td></tr><tr><td>sg_</td><td>静态全局变量(static global)</td><td>static int sg_example</td></tr><tr><td>gg_</td><td>进程间共享的数据段全局变量(global global)</td><td>int gg_shareValue</td></tr></tbody></table><h3 id="7-5-常量命名"><a href="#7-5-常量命名" class="headerlink" title="7.5 常量命名"></a>7.5 <strong>常量命名</strong></h3><p>常量****不含前缀且应该大写，单词间由下滑线，包含constexpr***、const以及宏定义。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> DAYS_IN_AWEEK = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> DAYS_IN_AWEEK = <span class="number">7</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DAYS_IN_AWEEK 7 <span class="comment">// 不推荐写法,命名方式按常量命名规则</span></span></span><br></pre></td></tr></table></figure><h3 id="7-6-函数命名"><a href="#7-6-函数命名" class="headerlink" title="7.6 函数命名"></a>7.6 <strong>函数命名</strong></h3><p>函数命名以及函数参数****都使用小驼峰命名方式，函数名时动词或含有动词的短语，函数参数若非基础数据类型，使用对象引用****。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> value)</span></span>;         <span class="comment">// 基础类型(迭代器)值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setColor</span><span class="params">(<span class="type">const</span> QColor&amp; newColor)</span></span>;  <span class="comment">// 非基础类型引用传递</span></span><br></pre></td></tr></table></figure><p><strong>*当函数为信号或者槽函数时，应分别在前加上signal*\和slot前缀。*</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">signalLogWritten</span><span class="params">(<span class="type">const</span> LogLevel &amp;level, <span class="type">const</span> QString &amp;log)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slotLogWrite</span><span class="params">(<span class="type">const</span> LogLevel &amp;level, <span class="type">const</span> QString &amp;log)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="7-7-命名空间命名"><a href="#7-7-命名空间命名" class="headerlink" title="7.7 命名空间命名"></a>7.7 <strong>命名空间命名</strong></h3><p>命名空间的名称是名词，****用小写字母命名****，每个单词以下划线分割，例如：ciqtek。</p><h3 id="7-8-枚举命名"><a href="#7-8-枚举命名" class="headerlink" title="7.8 枚举命名"></a>7.8 <strong>枚举命名</strong></h3><p>枚举名和枚举值****都是名词*<em><strong>，和常量或宏规则一致，</strong></em>*枚举值每个字母均为大写，单词之间以下划线间隔，枚举名为大驼峰命名方式****。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyColor</span> <span class="comment">// 枚举名</span></span><br><span class="line">&#123;</span><br><span class="line">    WHITE, <span class="comment">// 枚举值</span></span><br><span class="line">BLACK,</span><br><span class="line">SKY_BLUE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="7-9-结构体命名"><a href="#7-9-结构体命名" class="headerlink" title="7.9 结构体命名"></a>7.9 <strong>结构体命名</strong></h3><p>结构体中只定义变量，不定义函数。需要定义函数的结构体，转换成类实现。</p><p>****结构体名*<em><strong>是名词，</strong></em>*每个单词以大写字母开头，大驼峰命名方式*<em><strong>。</strong></em>*结构体成员*<em><strong>是名词，以</strong></em>*小驼峰命名方式****，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyColor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> isMyColor;</span><br><span class="line">    <span class="type">int</span> white;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="7-10-获取器和设置器命名"><a href="#7-10-获取器和设置器命名" class="headerlink" title="7.10 获取器和设置器命名"></a>7.10 <strong>获取器和设置器命名</strong></h3><p>获取器和设置器都是根据约定俗成的命名规则：</p><ul><li>l 非布尔型的获取器****color()*<em><strong>或者</strong></em>*getColor()****；</li><li>l 布尔型的获取器****isChecked()****；</li><li>l 设置器**Color(const Color&amp; newColor)**。</li></ul><h3 id="7-11-界面控件命名"><a href="#7-11-界面控件命名" class="headerlink" title="7.11 界面控件命名"></a>7.11 <strong>界面控件命名</strong></h3><p>控件命名应以控件类型结尾，以说明控件的类型，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 界面中有且仅有一种该类型控件</span></span><br><span class="line">QPlainTextEdit *textEdit;</span><br><span class="line">QLabel *label;</span><br><span class="line">QLineEdit *lineEdit;</span><br><span class="line"><span class="comment">// 界面中出现多种重复的控件,应将前面补充说明</span></span><br><span class="line">QLabel *contentsLabel;</span><br><span class="line">QPushButton *findButton;</span><br><span class="line">QToolBar *fileToolBar;</span><br><span class="line">QComboBox *caseComboBox;</span><br><span class="line">QSpinBox *maxVisibleSpinBox;</span><br><span class="line">QCheckBox *wrapCheckBox;</span><br></pre></td></tr></table></figure><h2 id="8-注释"><a href="#8-注释" class="headerlink" title="8. 注释"></a>8. <strong>注释</strong></h2><p>一般情况下源程序有效注释量必须在20%以上，不易理解的地方都需加上注释，需要简单精炼。</p><h3 id="8-1-注释风格"><a href="#8-1-注释风格" class="headerlink" title="8.1 注释风格"></a>8.1 <strong>注释风格</strong></h3><p>头文件注释风格需要兼容Doxygen注释方式，便于生成说明文档。源文件注释使用&#x2F;&#x2F;或&#x2F;* *&#x2F;都可以。</p><h3 id="8-2-头文件注释"><a href="#8-2-头文件注释" class="headerlink" title="8.2 头文件注释"></a>8.2 <strong>头文件注释</strong></h3><p>头文件注释包括****版权说明、版本号、作者、生成日期、描述信息****等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************************</span></span><br><span class="line"><span class="comment">**Copyright(C), 2021-2022, Ciqtek Technology.</span></span><br><span class="line"><span class="comment">**Version:     1.0</span></span><br><span class="line"><span class="comment">**Author:      dingyy</span></span><br><span class="line"><span class="comment">**Date:        $DATE$</span></span><br><span class="line"><span class="comment">**Description: </span></span><br><span class="line"><span class="comment">*****************************************************/</span></span><br></pre></td></tr></table></figure><h3 id="8-3-类注释"><a href="#8-3-类注释" class="headerlink" title="8.3 类注释"></a>8.3 <strong>类注释</strong></h3><p>类注释****包括描述信息，有必要时需将使用方法加到注释中****。</p><p>简单类只需要包含简要说明信息即可，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief    类描述信息</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>当类需要添加实例代码时候，按以下方式进行备注：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief    类描述信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   Example of usage:</span></span><br><span class="line"><span class="comment"> *   @code</span></span><br><span class="line"><span class="comment"> *       示例代码</span></span><br><span class="line"><span class="comment"> *   @endcode</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="8-4-函数注释"><a href="#8-4-函数注释" class="headerlink" title="8.4 函数注释"></a>8.4 <strong>函数注释</strong></h3><p>函数注释主要****包括描述信息、参数信息、返回值以及返回值说明，有必要时加入注解信息****。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief          函数名 函数简介</span></span><br><span class="line"><span class="comment"> * @param          形参 参数说明</span></span><br><span class="line"><span class="comment"> * @return         返回说明</span></span><br><span class="line"><span class="comment"> *   @retval 0     (非必要)返回值说明</span></span><br><span class="line"><span class="comment"> *   @retval 1     (非必要)返回值说明</span></span><br><span class="line"><span class="comment"> * @note           (非必要)注释信息</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="8-5-变量注释"><a href="#8-5-变量注释" class="headerlink" title="8.5 变量注释"></a>8.5 <strong>变量注释</strong></h3><p>类的数据成员变量按需进行注释，****全局变量需要注释说明含义及用途*<em><strong>。变量注释</strong></em>*置于变量的上方****。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 回归测试用例总数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_TEST_CASES = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><h3 id="8-6-实现注释"><a href="#8-6-实现注释" class="headerlink" title="8.6 实现注释"></a>8.6 <strong>实现注释</strong></h3><p>对于实现代码中巧妙的、隐晦的、重要的地方加以注释。****注意后跟一个空格****。</p><p>****巧妙或复杂的代码在代码块上方注释****，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将结果除以2,考虑到x包含加法的进位</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; result-&gt;<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    x = (x &lt;&lt; <span class="number">8</span>) + (*result)[i];</span><br><span class="line">    (*result)[i] = x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    x &amp;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-7-枚举和结构体注释"><a href="#8-7-枚举和结构体注释" class="headerlink" title="8.7  枚举和结构体注释"></a>8.7  <strong>枚举和结构体注释</strong></h2><p>枚举注释需要对****枚举、枚举值****进行说明。</p><p>结构体注释需要对****结构体、成员变量****进行说明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief     日志类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">LogLevel</span> </span><br><span class="line">&#123;</span><br><span class="line">    LOG_LEVEL_TRACE = <span class="number">0</span>,             <span class="comment">///&lt; TARCE输出 </span></span><br><span class="line">    LOG_LEVEL_DEBUG = <span class="number">10000</span>,         <span class="comment">///&lt; DEBUG输出 </span></span><br><span class="line">    LOG_LEVEL_INFO = <span class="number">20000</span>,          <span class="comment">///&lt; INFO输出 </span></span><br><span class="line">    LOG_LEVEL_WARN = <span class="number">30000</span>,          <span class="comment">///&lt; WARN输出 </span></span><br><span class="line">    LOG_LEVEL_ERROR = <span class="number">40000</span>,         <span class="comment">///&lt; ERROR输出 </span></span><br><span class="line">    LOG_LEVEL_FATAL = <span class="number">50000</span>,         <span class="comment">///&lt; FATAL输出 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief     自定义颜色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyColor</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> red;        <span class="comment">///&lt; 红色分量</span></span><br><span class="line">    <span class="type">int</span> green;      <span class="comment">///&lt; 绿色分量</span></span><br><span class="line">    <span class="type">int</span> blue;       <span class="comment">///&lt; 蓝色分量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="8-8TODO注释"><a href="#8-8TODO注释" class="headerlink" title="8.8TODO注释"></a>8.8<strong>TODO注释</strong></h2><p>对于****临时的、短期的方案，或计划中但未完成的代码，或已实现功能但待优化的代码*<em><strong>使用TODO注释。TODO注释需要</strong></em>*作者、日期****利于后期检索，避免查找困难，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MyClass::test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 计划但未完成</span></span><br><span class="line"><span class="comment">// TODO - Barmaco 2022/01/18 9:59 实现xx相关功能</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO - Barmaco 2022/01/18 9:59 临时方案</span></span><br><span class="line">    <span class="keyword">return</span> (a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// TODO - Barmaco 2022/01/18 9:59 待优化</span></span><br><span class="line">    <span class="type">int</span> x = (x &lt;&lt; <span class="number">8</span>) + (*result)[i];</span><br><span class="line">    (*result)[i] = x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    x &amp;= <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="9-格式"><a href="#9-格式" class="headerlink" title="9. 格式"></a>9. <strong>格式</strong></h2><h3 id="9-1-行长度"><a href="#9-1-行长度" class="headerlink" title="9.1 行长度"></a>9.1 <strong>行长度</strong></h3><p>较长的语句(&gt;80字符)要分成多行书写，长表达式要****在较低优先级操作符处划分新行，操作符放在新行之首，逗号放在一行的结束，划分出的新行要进行适当的缩进****，使排版整齐，语句可读，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((taskOne &lt; taskNumber) &amp;&amp; (taskTwo &lt; taskNumber) </span><br><span class="line">    &amp;&amp; (taskThree &lt; taskNumber) &amp;&amp;(taskFour &lt; taskNumber)) &#123;</span><br><span class="line">&#125; <span class="comment">// 操作符放在新行之首</span></span><br><span class="line"><span class="type">bool</span> retval = <span class="built_in">doSomething</span>(averyveryveryveryveryverylongargument1,</span><br><span class="line">                          argument2, argument3); <span class="comment">// 后一行与第一个实参对齐</span></span><br></pre></td></tr></table></figure><h3 id="9-2-文件编码"><a href="#9-2-文件编码" class="headerlink" title="9.2 文件编码"></a>9.2 <strong>文件编码</strong></h3><p>为了统一文件编码，避免开发过程中文件编码混乱问题，文件保存过程中，****统一使用**<em>UTF-8无签名</em>编码。编码转换时，默认在UTF-8中转换。</p><p>下载VS插件Force UTF-8(No BOM)，选择第一个点击下载→关闭并重启VS安装插件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. &lt;strong&gt;概述&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;旨在提高代码的可读性、可维护性，特此制定本规范。参考《Google C++ Style</summary>
      
    
    
    
    
  </entry>
  
</feed>
