<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OQS.com 知识分享</title>
  
  
  <link href="https://cpp-memory-leaks.github.io/atom.xml" rel="self"/>
  
  <link href="https://cpp-memory-leaks.github.io/"/>
  <updated>2024-12-10T14:43:29.967Z</updated>
  <id>https://cpp-memory-leaks.github.io/</id>
  
  <author>
    <name>OQS</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hhh</title>
    <link href="https://cpp-memory-leaks.github.io/2024/12/06/hhh/"/>
    <id>https://cpp-memory-leaks.github.io/2024/12/06/hhh/</id>
    <published>2024-12-06T15:58:58.000Z</published>
    <updated>2024-12-10T14:43:29.967Z</updated>
    
    <content type="html"><![CDATA[<img src="/2024/12/06/hhh/404.gif" class="" width="404">]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/2024/12/06/hhh/404.gif&quot; class=&quot;&quot; width=&quot;404&quot;&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>bugRecord</title>
    <link href="https://cpp-memory-leaks.github.io/2024/12/06/bugRecord/"/>
    <id>https://cpp-memory-leaks.github.io/2024/12/06/bugRecord/</id>
    <published>2024-12-06T14:19:47.000Z</published>
    <updated>2024-12-06T16:02:21.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Qt相关"><a href="#Qt相关" class="headerlink" title="Qt相关"></a>Qt相关</h1><h3 id="1-编码问题"><a href="#1-编码问题" class="headerlink" title="1. 编码问题"></a>1. 编码问题</h3><h4 id="1-1-乱码问题"><a href="#1-1-乱码问题" class="headerlink" title="1.1 乱码问题"></a>1.1 乱码问题</h4><p><strong>现象</strong></p><p>​编译通过、运行通过</p><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20231106230450303-16992854916522.png" alt="图片" title="bug"></p><p><strong>根本原因：</strong></p><p>​vs显示无乱码-&gt;源码字符集正确</p><p>​编译通过-&gt;编译字符集正确</p><p>​执行有乱码-&gt;执行字符集不正常</p><p>​源码字符集与执行字符集不一致，GCC的源码字符集与执行字符集默认是UTF-8编码，这是因为现在的Linux系统大多使用UTF-8编码。就算调整了Linux系统语言后，只是区域发生了变化，字符编码依然是UTF-8。所以我们的程序在“简体中文”与“英语”下，均能正确的显示中文字符。<br>　　MinGW中的GCC也是这样的，源码字符集与执行字符集默认是UTF-8编码。但是简体中文的Windows的默认编码是GB2312，会将printf输出UTF-8字符串误认为是GB2312，造成乱码。</p><p><strong>解决方案：</strong></p><ol><li><h5 id="源码字符集的设置"><a href="#源码字符集的设置" class="headerlink" title="源码字符集的设置"></a><strong>源码字符集的设置</strong></h5></li></ol><p>​（1）将所有的源代码格式设置为UTF-8（no Bom），VS：扩展—&gt;搜索Force UTF-8（no Bom）—&gt;关闭重启</p><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20231106232320714.png" alt="image-20231106232320714"></p><p>​</p><p>​（2）添加：&#x2F;source-charset:utf-8</p><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20231106232607624-16992855068795.png" alt="image-20231106232607624"></p><ol start="2"><li><h5 id="执行字符集的设置"><a href="#执行字符集的设置" class="headerlink" title="执行字符集的设置"></a><strong>执行字符集的设置</strong></h5>命令行添加：&#x2F;execution-charset:utf-8</li></ol><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20231106233002744-16992855114728.png" alt="image-20231106233002744"></p><h4 id="1-2-由编码问题出现的报错"><a href="#1-2-由编码问题出现的报错" class="headerlink" title="1.2 由编码问题出现的报错"></a>1.2 由编码问题出现的报错</h4><p><strong>现象：</strong></p><p>​编译不通过，明显语法没有错误，编译出现大量的错误</p><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20231108213720896.png" alt="image-20231108213720896"></p><p><strong>根本原因：</strong></p><ol><li>源码字符集与编译字符集不一致</li></ol><p><strong>解决方案：</strong></p><p>​在命令行追加&#x2F;source-charset:utf-8 &#x2F;execution-charset:utf-8 </p><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20231109122230384.png" alt="image-20231109122230384"></p><h3 id="3-编译器、编译套件等问题"><a href="#3-编译器、编译套件等问题" class="headerlink" title="3.  编译器、编译套件等问题"></a>3.  编译器、编译套件等问题</h3><h4 id="1-打开项目出现错误-qmake-16968-Project-ERROR-msvc-version-conf-loaded-but-QMAKE-MSC-VER-isn’t-set"><a href="#1-打开项目出现错误-qmake-16968-Project-ERROR-msvc-version-conf-loaded-but-QMAKE-MSC-VER-isn’t-set" class="headerlink" title="1. 打开项目出现错误&gt;&gt;&gt; qmake(16968): Project ERROR: msvc-version.conf loaded but QMAKE_MSC_VER isn’t set"></a>1. 打开项目出现错误&gt;&gt;&gt; qmake(16968): Project ERROR: msvc-version.conf loaded but QMAKE_MSC_VER isn’t set</h4><p><strong>现象：</strong></p><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20231129220235374.png" alt="image-20231129220235374"></p><p><strong>错误原因：</strong></p><p>Qt中的版本与VS的版本不匹配</p><p>D:\Qt5.12.9\msvc2017_64\mkspecs\common\msvc-version.conf</p><p><strong>总结：</strong>在Windows系统上设置<code>QMAKE_MSC_VER</code>环境变量通常是为了告诉Qt使用的MSVC（Microsoft Visual C++）编译器的版本。这个环境变量的值应该与当前使用的Visual Studio版本相对应。</p><p><strong>解决办法：</strong></p><ol><li><strong>找到Visual Studio安装目录：</strong> 在通常情况下，Visual Studio被安装在<code>C:\Program Files (x86)\Microsoft Visual Studio</code>目录下。</li><li><strong>找到MSVC版本号：</strong> 进入Visual Studio安装目录，然后进入<code>VC\Tools\MSVC</code>目录，你会看到一个或多个以版本号命名的子目录，比如<code>14.0xxxxx</code>、<code>14.1</code>xxxxxxx、<code>14.3x</code>xxxxxx等。这个版本号就是需要设置的<code>QMAKE_MSC_VER</code>的值。<img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20231129221006595.png" alt="image-20231129221006595"></li><li><strong>根据下载安装QT路径修改：msvc-version.conf配置文件</strong><br>D:\Qt\Qt5.12.9\5.12.9\msvc2017_64\mkspecs\common\msvc-version.conf</li></ol><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20231129220809867.png" alt="image-20231129220809867"></p><p>我用的是msvc_2017所有对应的msvc版本是1916</p><p><strong>对应表如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">MSC 1.0 _MSC_VER == 100</span><br><span class="line">MSC 2.0 _MSC_VER == 200</span><br><span class="line">MSC 3.0 _MSC_VER == 300</span><br><span class="line">MSC 4.0 _MSC_VER == 400</span><br><span class="line">MSC 5.0 _MSC_VER == 500</span><br><span class="line">MSC 6.0 _MSC_VER == 600</span><br><span class="line">MSC 7.0 _MSC_VER == 700</span><br><span class="line">MSVC++ 1.0 _MSC_VER == 800</span><br><span class="line">MSVC++ 2.0 _MSC_VER == 900</span><br><span class="line">MSVC++ 4.0 _MSC_VER == 1000 (Developer Studio 4.0)</span><br><span class="line">MSVC++ 4.2 _MSC_VER == 1020 (Developer Studio 4.2)</span><br><span class="line">MSVC++ 5.0 _MSC_VER == 1100 (Visual Studio 97 version 5.0)</span><br><span class="line">MSVC++ 6.0 _MSC_VER == 1200 (Visual Studio 6.0 version 6.0)</span><br><span class="line">MSVC++ 7.0 _MSC_VER == 1300 (Visual Studio .NET 2002 version 7.0)</span><br><span class="line">MSVC++ 7.1 _MSC_VER == 1310 (Visual Studio .NET 2003 version 7.1)</span><br><span class="line">MSVC++ 8.0 _MSC_VER == 1400 (Visual Studio 2005 version 8.0)</span><br><span class="line">MSVC++ 9.0 _MSC_VER == 1500 (Visual Studio 2008 version 9.0)</span><br><span class="line">MSVC++ 10.0 _MSC_VER == 1600 (Visual Studio 2010 version 10.0)</span><br><span class="line">MSVC++ 11.0 _MSC_VER == 1700 (Visual Studio 2012 version 11.0)</span><br><span class="line">MSVC++ 12.0 _MSC_VER == 1800 (Visual Studio 2013 version 12.0)</span><br><span class="line">MSVC++ 14.0 _MSC_VER == 1900 (Visual Studio 2015 version 14.0)</span><br><span class="line">MSVC++ 14.1 _MSC_VER == 1910 (Visual Studio 2017 version 15.0)</span><br><span class="line">MSVC++ 14.11 _MSC_VER == 1911 (Visual Studio 2017 version 15.3)</span><br><span class="line">MSVC++ 14.12 _MSC_VER == 1912 (Visual Studio 2017 version 15.5)</span><br><span class="line">MSVC++ 14.13 _MSC_VER == 1913 (Visual Studio 2017 version 15.6)</span><br><span class="line">MSVC++ 14.14 _MSC_VER == 1914 (Visual Studio 2017 version 15.7)</span><br><span class="line">MSVC++ 14.15 _MSC_VER == 1915 (Visual Studio 2017 version 15.8)</span><br><span class="line">MSVC++ 14.16 _MSC_VER == 1916 (Visual Studio 2017 version 15.9)</span><br><span class="line">MSVC++ 14.2 _MSC_VER == 1920 (Visual Studio 2019 Version 16.0)</span><br><span class="line">MSVC++ 14.21 _MSC_VER == 1921 (Visual Studio 2019 Version 16.1)</span><br><span class="line">MSVC++ 14.22 _MSC_VER == 1922 (Visual Studio 2019 Version 16.2)</span><br></pre></td></tr></table></figure><h4 id="2-编译套件配置路径错误导致"><a href="#2-编译套件配置路径错误导致" class="headerlink" title="2.  编译套件配置路径错误导致"></a>2.  编译套件配置路径错误导致</h4><h3 id="4-QT-VS-FFmpeg编译找不到库"><a href="#4-QT-VS-FFmpeg编译找不到库" class="headerlink" title="4.  QT+VS+FFmpeg编译找不到库"></a>4.  QT+VS+FFmpeg编译找不到库</h3><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20240106104221786.png" alt="image-20240106104221786"></p><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20240106104320454.png" alt="image-20240106104320454"></p><p>项目-&gt;属性-&gt;C&#x2F;C++-&gt;附加包含目录</p><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20240106104527988.png" alt="image-20240106104527988"></p><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20240106104634876.png" alt="image-20240106104634876"></p><p>再不行就将FFmpeg的bin目录下的所有文件*.dll都拷贝到我们的运行环境下（.exe所在的目录）</p><p>动态库下载路径<a href="https://github.com/BtbN/FFmpeg-Builds/releases?page=4">https://github.com/BtbN/FFmpeg-Builds/releases?page=4</a></p><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20240106113003741.png" alt="image-20240106113003741"></p><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20240106113104030.png" alt="image-20240106113104030"></p><h3 id="5-MySQL-—–-ERR-1273-Unknown-collation-‘utf8mb4-0900-ai-ci’"><a href="#5-MySQL-—–-ERR-1273-Unknown-collation-‘utf8mb4-0900-ai-ci’" class="headerlink" title="5.  MySQL —–[ERR] 1273 - Unknown collation: ‘utf8mb4_0900_ai_ci’"></a>5.  MySQL —–[ERR] 1273 - Unknown collation: ‘utf8mb4_0900_ai_ci’</h3><p>原因：这是8.0以上的新版本数据库的编码，旧版本不支持</p><p>更新数据库版本或者更改为旧版本支持的编码格式</p><p>推荐：更改编码格式</p><p>复制数据库脚本到word，全部替换为utf8mb4_unicode_ci</p><h3 id="6-SpringBoot项目启动命令过长！-Error-running-Application-Command-line-is-too-long-Shorten-the-command-line-via-JAR-manifest-or-via-a-classpath-file-and-rerun"><a href="#6-SpringBoot项目启动命令过长！-Error-running-Application-Command-line-is-too-long-Shorten-the-command-line-via-JAR-manifest-or-via-a-classpath-file-and-rerun" class="headerlink" title="6.  SpringBoot项目启动命令过长！-Error running Application. Command line is too long. Shorten the command line via JAR manifest or via a classpath file and rerun"></a>6.  SpringBoot项目启动命令过长！-Error running Application. Command line is too long. Shorten the command line via JAR manifest or via a classpath file and rerun</h3><ol><li>点击项目启动配置项</li><li><em>shorten command line</em> 选项选择 JAR manifest 或者 classpath file 选项</li><li>重新启动工程运行即可</li></ol><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/1709906746564-f5718283-4321-4e77-982e-a4c22333aa3a.png"></p><h3 id="7-sha256加盐加密踩坑"><a href="#7-sha256加盐加密踩坑" class="headerlink" title="7. sha256加盐加密踩坑"></a>7. sha256加盐加密踩坑</h3><p>注册：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">QByteArray salt = QCryptographicHash::<span class="built_in">hash</span>(QByteArray::<span class="built_in">number</span>(QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">1000000000</span>)), QCryptographicHash::Sha256);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; salt &lt;&lt; endl;</span><br><span class="line">QByteArray passwordHash = QCryptographicHash::<span class="built_in">hash</span>((password + salt).<span class="built_in">toUtf8</span>(), QCryptographicHash::Sha256);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; passwordHash;</span><br><span class="line"></span><br><span class="line">QString sql = <span class="string">&quot;INSERT INTO users (username, salt ,password_hash) VALUES (:username,:salt, :password_hash )&quot;</span>;</span><br><span class="line">QSqlQuery query;</span><br><span class="line"></span><br><span class="line">query.<span class="built_in">prepare</span>(sql);</span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="string">&quot;:username&quot;</span>, userName);</span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="string">&quot;:salt&quot;</span>, salt.<span class="built_in">toHex</span>()); </span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="string">&quot;:password_hash&quot;</span>, passwordHash.<span class="built_in">toHex</span>());</span><br></pre></td></tr></table></figure><p>注册时存储在数据库中的salt是经过了从ByteArray经过toHex()的转换，登录的时候不要将salt取出来后直接toByteArray()否则这样的盐值是无法读取的，而是需要将salt以字符串的形式读取，然后使用ByteArray::fromHex()转换为ByteArray</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> QByteArray storedHash = query.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toByteArray</span>();</span><br><span class="line"><span class="type">const</span> QString salt111 = query.<span class="built_in">value</span>(<span class="number">1</span>).<span class="built_in">toString</span>();</span><br><span class="line"><span class="type">const</span> QByteArray salt = QByteArray::<span class="built_in">fromHex</span>(salt<span class="number">111.</span><span class="built_in">toUtf8</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用相同的哈希算法和盐值对用户提供的密码进行哈希处理  </span></span><br><span class="line">QByteArray passwordHash = QCryptographicHash::<span class="built_in">hash</span>((password + salt).<span class="built_in">toUtf8</span>(), QCryptographicHash::Sha256).<span class="built_in">toHex</span>();</span><br><span class="line"><span class="comment">// 比较存储的哈希值和计算的哈希值是否相同  </span></span><br><span class="line"><span class="keyword">if</span> (passwordHash==storedHash) &#123;</span><br><span class="line">    <span class="comment">// 哈希值匹配，登录成功  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-Qtimer踩坑"><a href="#8-Qtimer踩坑" class="headerlink" title="8.  Qtimer踩坑"></a>8.  Qtimer踩坑</h3><p>点击 <code>startBtn</code> 时，如果 <code>timer</code> 已经处于活动状态（即已经在计时），那么它不会停止并重新开始计时，而是会继续计时直到达到设定的时间间隔（在这个例子中是1000毫秒）。如果希望点击 <code>startBtn</code> 时能够重置计时器（即无论它是否正在计时，都停止当前计时并重新开始），需要在启动计时器之前先调用 <code>stop()</code> 方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QTimer* timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">connect</span>(timer, &amp;QTimer::timeout, []() &#123; <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;hhhhhhhhhh&quot;</span>; &#125;);</span><br><span class="line"><span class="built_in">connect</span>(ui.stopBtn, &amp;QPushButton::clicked, timer, &amp;QTimer::stop);</span><br><span class="line"><span class="built_in">connect</span>(ui.startBtn, &amp;QPushButton::clicked, <span class="keyword">this</span>, [<span class="keyword">this</span>, timer]() &#123;</span><br><span class="line">    <span class="comment">// 无论timer是否正在计时，都先停止它  </span></span><br><span class="line">    timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">    <span class="comment">// 然后重新启动计时器  </span></span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h3 id="9-Windows文件系统重定向问题"><a href="#9-Windows文件系统重定向问题" class="headerlink" title="9. Windows文件系统重定向问题"></a>9. Windows文件系统重定向问题</h3><p>现象：</p><p>今天做项目的时候发现了一个奇怪的问题，我的项目是32位的Qt程序，需求是要将一个程序运行目录下的一个dll文件拷贝到C:&#x2F;Windows&#x2F;System32目录下，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QString sourcePath = QApplication::<span class="built_in">applicationDirPath</span>() + <span class="string">&quot;/wintun.dll&quot;</span>;</span><br><span class="line">QString destinationPath = <span class="string">&quot;C:/Windows/System32/wintun.dll&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isDestinationExists = QFile::<span class="built_in">exists</span>(destinationPath);</span><br><span class="line"><span class="type">bool</span> isSourceExists = QFile::<span class="built_in">exists</span>(sourcePath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isSourceExists) QFile::<span class="built_in">copy</span>(sourcePath, destinationPath);</span><br></pre></td></tr></table></figure><p>这是很简单的一个代码，仅仅是将文件简单的复制到目标位置，但是在目标路径上死活没看到文件，isDestinationExists和isSourceExists都是true，执行QFile::copy(sourcePath, destinationPath)也是true，当我是用remove()函数尝试删除destinationPath文件后，再次运行，isDestinationExists返回的是false，证明目标文件已经被删除了，在C盘的其他目录下如C:&#x2F;Windows&#x2F;System都是成功的能拷贝成功，而且QFile::copy(sourcePath, destinationPath)也是true，使用的是管理员打开，证明不存在权限问题。</p><p>这是由于Windows的文件系统重定向导致的。%windir%\System32 目录是为 64 位 Windows 上的 64 位应用程序保留的。 创建 64 位版本的 DLL 时，大多数 DLL 文件名未更改，因此 32 位版本的 DLL 存储在不同的目录中。 WOW64 通过使用 <em>文件系统重定向程序</em>来隐藏此差异。</p><p>在大多数情况下，每当 32 位应用程序尝试访问 %windir%\System32、%windir%\lastgood\system32 或 %windir%\regedit.exe时，访问都会重定向到特定于体系结构的路径。</p><p>如：</p><ol><li>有一个 64 位的 DLL 文件放在 <code>C:\Windows\System32\example.dll</code>，同时有一个 32 位的 DLL 文件放在 <code>C:\Windows\SysWOW64\example.dll</code>。</li><li>当一个 32 位应用程序尝试 <code>LoadLibrary</code> 去加载 <code>C:\Windows\System32\example.dll</code>，实际上它会加载 <code>C:\Windows\SysWOW64\example.dll</code>，因为系统的重定向机制将请求指向了 <code>SysWOW64</code>。</li></ol><p>如图所示：</p><p><img src="F:/Tools/hexo/blog/source/_posts/image-20240929214652413.png" alt="image-20240929214652413"></p><p>而我的程序，也正是被强大的Windows重定向到了C:\Windows\SysWOW64目录下</p><p>解决办法：</p><ol><li>64位程序访问32位系统目录：若要检索 32 位系统目录的名称，64 位应用程序应使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/wow64apiset/nf-wow64apiset-getsystemwow64directory2a"><strong>GetSystemWow64Directory2</strong></a> 函数 (Windows 10版本 1511) 或 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/wow64apiset/nf-wow64apiset-getsystemwow64directorya"><strong>GetSystemWow64Directory</strong></a> 函数。</li><li>32位程序访问64位系统目录：<strong>32 位应用程序可以通过将 %windir%\Sysnative 替换为 %windir%\System32 来访问本机系统目录。 WOW64 将 Sysnative 识别为用于指示文件系统不应重定向访问的特殊别名，官方建议使用此机制绕过文件系统重定向。</strong> 应用程序也可以使用 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/wow64apiset/nf-wow64apiset-wow64disablewow64fsredirection"><strong>Wow64DisableWow64FsRedirection、Wow64EnableWow64FsRedirection</strong></a> 和 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/wow64apiset/nf-wow64apiset-wow64revertwow64fsredirection"><strong>Wow64RevertWow64FsRedirection 函数来控制 WOW64</strong></a> 文件系统重定向程序。 禁用文件系统重定向会影响调用线程执行的所有文件操作，因此仅当单个 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea"><strong>CreateFile</strong></a> 调用需要时才禁用它，并在函数返回后立即重新启用。 长时间禁用文件系统重定向可能会阻止 32 位应用程序加载系统 DLL，从而导致应用程序失败。</li></ol><p>在我们的例子当中，根据官方建议的做法，32位程序想要访问64位的系统目录，需要通过 <code>C:\Windows\Sysnative\example.dll</code> 访问。</p><p>第二种做法是利用windows的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Wow64Redirection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PVOID OldValue;</span><br><span class="line">    <span class="comment">//禁止文件系统重定向</span></span><br><span class="line">   <span class="built_in">Wow64DisableWow64FsRedirection</span>(&amp;OldValue)) &#123;</span><br><span class="line">       <span class="comment">//现在进入的是C:\\Windows\\System32目录下</span></span><br><span class="line">        <span class="keyword">if</span> (QFile::<span class="built_in">exists</span>(<span class="string">&quot;C:\\Windows\\System32\\wintun.dll&quot;</span>)) &#123;</span><br><span class="line">        QFile::<span class="built_in">copy</span>(QFile::<span class="built_in">copy</span>( QApplication::<span class="built_in">applicationDirPath</span>() + <span class="string">&quot;/wintun.dll&quot;</span>, <span class="string">&quot;C:\\Windows\\System32\\wintun.dll&quot;</span>););</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//打开文件系统重定向</span></span><br><span class="line">    <span class="built_in">Wow64RevertWow64FsRedirection</span>(OldValue);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Qt相关&quot;&gt;&lt;a href=&quot;#Qt相关&quot; class=&quot;headerlink&quot; title=&quot;Qt相关&quot;&gt;&lt;/a&gt;Qt相关&lt;/h1&gt;&lt;h3 id=&quot;1-编码问题&quot;&gt;&lt;a href=&quot;#1-编码问题&quot; class=&quot;headerlink&quot; title=&quot;1. 编码</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Bug</title>
    <link href="https://cpp-memory-leaks.github.io/2024/12/06/Bug/"/>
    <id>https://cpp-memory-leaks.github.io/2024/12/06/Bug/</id>
    <published>2024-12-05T16:15:59.692Z</published>
    <updated>2024-12-06T14:17:02.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Qt相关"><a href="#Qt相关" class="headerlink" title="Qt相关"></a>Qt相关</h1><h3 id="1-编码问题"><a href="#1-编码问题" class="headerlink" title="1. 编码问题"></a>1. 编码问题</h3><h4 id="1-1-乱码问题"><a href="#1-1-乱码问题" class="headerlink" title="1.1 乱码问题"></a>1.1 乱码问题</h4><p><strong>现象</strong></p><p>​编译通过、运行通过</p><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20231106230450303-16992854916522.png" alt="image-20231106230450303"></p><p><strong>根本原因：</strong></p><p>​vs显示无乱码-&gt;源码字符集正确</p><p>​编译通过-&gt;编译字符集正确</p><p>​执行有乱码-&gt;执行字符集不正常</p><p>​源码字符集与执行字符集不一致，GCC的源码字符集与执行字符集默认是UTF-8编码，这是因为现在的Linux系统大多使用UTF-8编码。就算调整了Linux系统语言后，只是区域发生了变化，字符编码依然是UTF-8。所以我们的程序在“简体中文”与“英语”下，均能正确的显示中文字符。<br>　　MinGW中的GCC也是这样的，源码字符集与执行字符集默认是UTF-8编码。但是简体中文的Windows的默认编码是GB2312，会将printf输出UTF-8字符串误认为是GB2312，造成乱码。</p><p><strong>解决方案：</strong></p><ol><li><h5 id="源码字符集的设置"><a href="#源码字符集的设置" class="headerlink" title="源码字符集的设置"></a><strong>源码字符集的设置</strong></h5></li></ol><p>​（1）将所有的源代码格式设置为UTF-8（no Bom），VS：扩展—&gt;搜索Force UTF-8（no Bom）—&gt;关闭重启</p><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20231106232320714.png" alt="image-20231106232320714"></p><p>​</p><p>​（2）添加：&#x2F;source-charset:utf-8</p><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20231106232607624-16992855068795.png" alt="image-20231106232607624"></p><ol start="2"><li><h5 id="执行字符集的设置"><a href="#执行字符集的设置" class="headerlink" title="执行字符集的设置"></a><strong>执行字符集的设置</strong></h5>命令行添加：&#x2F;execution-charset:utf-8</li></ol><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20231106233002744-16992855114728.png" alt="image-20231106233002744"></p><h4 id="1-2-由编码问题出现的报错"><a href="#1-2-由编码问题出现的报错" class="headerlink" title="1.2 由编码问题出现的报错"></a>1.2 由编码问题出现的报错</h4><p><strong>现象：</strong></p><p>​编译不通过，明显语法没有错误，编译出现大量的错误</p><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20231108213720896.png" alt="image-20231108213720896"></p><p><strong>根本原因：</strong></p><ol><li>源码字符集与编译字符集不一致</li></ol><p><strong>解决方案：</strong></p><p>​在命令行追加&#x2F;source-charset:utf-8 &#x2F;execution-charset:utf-8 </p><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20231109122230384.png" alt="image-20231109122230384"></p><h3 id="3-编译器、编译套件等问题"><a href="#3-编译器、编译套件等问题" class="headerlink" title="3.  编译器、编译套件等问题"></a>3.  编译器、编译套件等问题</h3><h4 id="1-打开项目出现错误-qmake-16968-Project-ERROR-msvc-version-conf-loaded-but-QMAKE-MSC-VER-isn’t-set"><a href="#1-打开项目出现错误-qmake-16968-Project-ERROR-msvc-version-conf-loaded-but-QMAKE-MSC-VER-isn’t-set" class="headerlink" title="1. 打开项目出现错误&gt;&gt;&gt; qmake(16968): Project ERROR: msvc-version.conf loaded but QMAKE_MSC_VER isn’t set"></a>1. 打开项目出现错误&gt;&gt;&gt; qmake(16968): Project ERROR: msvc-version.conf loaded but QMAKE_MSC_VER isn’t set</h4><p><strong>现象：</strong></p><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20231129220235374.png" alt="image-20231129220235374"></p><p><strong>错误原因：</strong></p><p>Qt中的版本与VS的版本不匹配</p><p>D:\Qt5.12.9\msvc2017_64\mkspecs\common\msvc-version.conf</p><p><strong>总结：</strong>在Windows系统上设置<code>QMAKE_MSC_VER</code>环境变量通常是为了告诉Qt使用的MSVC（Microsoft Visual C++）编译器的版本。这个环境变量的值应该与当前使用的Visual Studio版本相对应。</p><p><strong>解决办法：</strong></p><ol><li><strong>找到Visual Studio安装目录：</strong> 在通常情况下，Visual Studio被安装在<code>C:\Program Files (x86)\Microsoft Visual Studio</code>目录下。</li><li><strong>找到MSVC版本号：</strong> 进入Visual Studio安装目录，然后进入<code>VC\Tools\MSVC</code>目录，你会看到一个或多个以版本号命名的子目录，比如<code>14.0xxxxx</code>、<code>14.1</code>xxxxxxx、<code>14.3x</code>xxxxxx等。这个版本号就是需要设置的<code>QMAKE_MSC_VER</code>的值。<img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20231129221006595.png" alt="image-20231129221006595"></li><li><strong>根据下载安装QT路径修改：msvc-version.conf配置文件</strong><br>D:\Qt\Qt5.12.9\5.12.9\msvc2017_64\mkspecs\common\msvc-version.conf</li></ol><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20231129220809867.png" alt="image-20231129220809867"></p><p>我用的是msvc_2017所有对应的msvc版本是1916</p><p><strong>对应表如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">MSC 1.0 _MSC_VER == 100</span><br><span class="line">MSC 2.0 _MSC_VER == 200</span><br><span class="line">MSC 3.0 _MSC_VER == 300</span><br><span class="line">MSC 4.0 _MSC_VER == 400</span><br><span class="line">MSC 5.0 _MSC_VER == 500</span><br><span class="line">MSC 6.0 _MSC_VER == 600</span><br><span class="line">MSC 7.0 _MSC_VER == 700</span><br><span class="line">MSVC++ 1.0 _MSC_VER == 800</span><br><span class="line">MSVC++ 2.0 _MSC_VER == 900</span><br><span class="line">MSVC++ 4.0 _MSC_VER == 1000 (Developer Studio 4.0)</span><br><span class="line">MSVC++ 4.2 _MSC_VER == 1020 (Developer Studio 4.2)</span><br><span class="line">MSVC++ 5.0 _MSC_VER == 1100 (Visual Studio 97 version 5.0)</span><br><span class="line">MSVC++ 6.0 _MSC_VER == 1200 (Visual Studio 6.0 version 6.0)</span><br><span class="line">MSVC++ 7.0 _MSC_VER == 1300 (Visual Studio .NET 2002 version 7.0)</span><br><span class="line">MSVC++ 7.1 _MSC_VER == 1310 (Visual Studio .NET 2003 version 7.1)</span><br><span class="line">MSVC++ 8.0 _MSC_VER == 1400 (Visual Studio 2005 version 8.0)</span><br><span class="line">MSVC++ 9.0 _MSC_VER == 1500 (Visual Studio 2008 version 9.0)</span><br><span class="line">MSVC++ 10.0 _MSC_VER == 1600 (Visual Studio 2010 version 10.0)</span><br><span class="line">MSVC++ 11.0 _MSC_VER == 1700 (Visual Studio 2012 version 11.0)</span><br><span class="line">MSVC++ 12.0 _MSC_VER == 1800 (Visual Studio 2013 version 12.0)</span><br><span class="line">MSVC++ 14.0 _MSC_VER == 1900 (Visual Studio 2015 version 14.0)</span><br><span class="line">MSVC++ 14.1 _MSC_VER == 1910 (Visual Studio 2017 version 15.0)</span><br><span class="line">MSVC++ 14.11 _MSC_VER == 1911 (Visual Studio 2017 version 15.3)</span><br><span class="line">MSVC++ 14.12 _MSC_VER == 1912 (Visual Studio 2017 version 15.5)</span><br><span class="line">MSVC++ 14.13 _MSC_VER == 1913 (Visual Studio 2017 version 15.6)</span><br><span class="line">MSVC++ 14.14 _MSC_VER == 1914 (Visual Studio 2017 version 15.7)</span><br><span class="line">MSVC++ 14.15 _MSC_VER == 1915 (Visual Studio 2017 version 15.8)</span><br><span class="line">MSVC++ 14.16 _MSC_VER == 1916 (Visual Studio 2017 version 15.9)</span><br><span class="line">MSVC++ 14.2 _MSC_VER == 1920 (Visual Studio 2019 Version 16.0)</span><br><span class="line">MSVC++ 14.21 _MSC_VER == 1921 (Visual Studio 2019 Version 16.1)</span><br><span class="line">MSVC++ 14.22 _MSC_VER == 1922 (Visual Studio 2019 Version 16.2)</span><br></pre></td></tr></table></figure><h4 id="2-编译套件配置路径错误导致"><a href="#2-编译套件配置路径错误导致" class="headerlink" title="2.  编译套件配置路径错误导致"></a>2.  编译套件配置路径错误导致</h4><h3 id="4-QT-VS-FFmpeg编译找不到库"><a href="#4-QT-VS-FFmpeg编译找不到库" class="headerlink" title="4.  QT+VS+FFmpeg编译找不到库"></a>4.  QT+VS+FFmpeg编译找不到库</h3><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20240106104221786.png" alt="image-20240106104221786"></p><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20240106104320454.png" alt="image-20240106104320454"></p><p>项目-&gt;属性-&gt;C&#x2F;C++-&gt;附加包含目录</p><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20240106104527988.png" alt="image-20240106104527988"></p><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20240106104634876.png" alt="image-20240106104634876"></p><p>再不行就将FFmpeg的bin目录下的所有文件*.dll都拷贝到我们的运行环境下（.exe所在的目录）</p><p>动态库下载路径<a href="https://github.com/BtbN/FFmpeg-Builds/releases?page=4">https://github.com/BtbN/FFmpeg-Builds/releases?page=4</a></p><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20240106113003741.png" alt="image-20240106113003741"></p><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20240106113104030.png" alt="image-20240106113104030"></p><h3 id="5-MySQL-—–-ERR-1273-Unknown-collation-‘utf8mb4-0900-ai-ci’"><a href="#5-MySQL-—–-ERR-1273-Unknown-collation-‘utf8mb4-0900-ai-ci’" class="headerlink" title="5.  MySQL —–[ERR] 1273 - Unknown collation: ‘utf8mb4_0900_ai_ci’"></a>5.  MySQL —–[ERR] 1273 - Unknown collation: ‘utf8mb4_0900_ai_ci’</h3><p>原因：这是8.0以上的新版本数据库的编码，旧版本不支持</p><p>更新数据库版本或者更改为旧版本支持的编码格式</p><p>推荐：更改编码格式</p><p>复制数据库脚本到word，全部替换为utf8mb4_unicode_ci</p><h3 id="6-SpringBoot项目启动命令过长！-Error-running-Application-Command-line-is-too-long-Shorten-the-command-line-via-JAR-manifest-or-via-a-classpath-file-and-rerun"><a href="#6-SpringBoot项目启动命令过长！-Error-running-Application-Command-line-is-too-long-Shorten-the-command-line-via-JAR-manifest-or-via-a-classpath-file-and-rerun" class="headerlink" title="6.  SpringBoot项目启动命令过长！-Error running Application. Command line is too long. Shorten the command line via JAR manifest or via a classpath file and rerun"></a>6.  SpringBoot项目启动命令过长！-Error running Application. Command line is too long. Shorten the command line via JAR manifest or via a classpath file and rerun</h3><ol><li>点击项目启动配置项</li><li><em>shorten command line</em> 选项选择 JAR manifest 或者 classpath file 选项</li><li>重新启动工程运行即可</li></ol><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/1709906746564-f5718283-4321-4e77-982e-a4c22333aa3a.png"></p><h3 id="7-sha256加盐加密踩坑"><a href="#7-sha256加盐加密踩坑" class="headerlink" title="7. sha256加盐加密踩坑"></a>7. sha256加盐加密踩坑</h3><p>注册：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">QByteArray salt = QCryptographicHash::<span class="built_in">hash</span>(QByteArray::<span class="built_in">number</span>(QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">1000000000</span>)), QCryptographicHash::Sha256);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; salt &lt;&lt; endl;</span><br><span class="line">QByteArray passwordHash = QCryptographicHash::<span class="built_in">hash</span>((password + salt).<span class="built_in">toUtf8</span>(), QCryptographicHash::Sha256);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; passwordHash;</span><br><span class="line"></span><br><span class="line">QString sql = <span class="string">&quot;INSERT INTO users (username, salt ,password_hash) VALUES (:username,:salt, :password_hash )&quot;</span>;</span><br><span class="line">QSqlQuery query;</span><br><span class="line"></span><br><span class="line">query.<span class="built_in">prepare</span>(sql);</span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="string">&quot;:username&quot;</span>, userName);</span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="string">&quot;:salt&quot;</span>, salt.<span class="built_in">toHex</span>()); </span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="string">&quot;:password_hash&quot;</span>, passwordHash.<span class="built_in">toHex</span>());</span><br></pre></td></tr></table></figure><p>注册时存储在数据库中的salt是经过了从ByteArray经过toHex()的转换，登录的时候不要将salt取出来后直接toByteArray()否则这样的盐值是无法读取的，而是需要将salt以字符串的形式读取，然后使用ByteArray::fromHex()转换为ByteArray</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> QByteArray storedHash = query.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toByteArray</span>();</span><br><span class="line"><span class="type">const</span> QString salt111 = query.<span class="built_in">value</span>(<span class="number">1</span>).<span class="built_in">toString</span>();</span><br><span class="line"><span class="type">const</span> QByteArray salt = QByteArray::<span class="built_in">fromHex</span>(salt<span class="number">111.</span><span class="built_in">toUtf8</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用相同的哈希算法和盐值对用户提供的密码进行哈希处理  </span></span><br><span class="line">QByteArray passwordHash = QCryptographicHash::<span class="built_in">hash</span>((password + salt).<span class="built_in">toUtf8</span>(), QCryptographicHash::Sha256).<span class="built_in">toHex</span>();</span><br><span class="line"><span class="comment">// 比较存储的哈希值和计算的哈希值是否相同  </span></span><br><span class="line"><span class="keyword">if</span> (passwordHash==storedHash) &#123;</span><br><span class="line">    <span class="comment">// 哈希值匹配，登录成功  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-Qtimer踩坑"><a href="#8-Qtimer踩坑" class="headerlink" title="8.  Qtimer踩坑"></a>8.  Qtimer踩坑</h3><p>点击 <code>startBtn</code> 时，如果 <code>timer</code> 已经处于活动状态（即已经在计时），那么它不会停止并重新开始计时，而是会继续计时直到达到设定的时间间隔（在这个例子中是1000毫秒）。如果希望点击 <code>startBtn</code> 时能够重置计时器（即无论它是否正在计时，都停止当前计时并重新开始），需要在启动计时器之前先调用 <code>stop()</code> 方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QTimer* timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">connect</span>(timer, &amp;QTimer::timeout, []() &#123; <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;hhhhhhhhhh&quot;</span>; &#125;);</span><br><span class="line"><span class="built_in">connect</span>(ui.stopBtn, &amp;QPushButton::clicked, timer, &amp;QTimer::stop);</span><br><span class="line"><span class="built_in">connect</span>(ui.startBtn, &amp;QPushButton::clicked, <span class="keyword">this</span>, [<span class="keyword">this</span>, timer]() &#123;</span><br><span class="line">    <span class="comment">// 无论timer是否正在计时，都先停止它  </span></span><br><span class="line">    timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">    <span class="comment">// 然后重新启动计时器  </span></span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h3 id="9-Windows文件系统重定向问题"><a href="#9-Windows文件系统重定向问题" class="headerlink" title="9. Windows文件系统重定向问题"></a>9. Windows文件系统重定向问题</h3><p>现象：</p><p>今天做项目的时候发现了一个奇怪的问题，我的项目是32位的Qt程序，需求是要将一个程序运行目录下的一个dll文件拷贝到C:&#x2F;Windows&#x2F;System32目录下，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QString sourcePath = QApplication::<span class="built_in">applicationDirPath</span>() + <span class="string">&quot;/wintun.dll&quot;</span>;</span><br><span class="line">QString destinationPath = <span class="string">&quot;C:/Windows/System32/wintun.dll&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isDestinationExists = QFile::<span class="built_in">exists</span>(destinationPath);</span><br><span class="line"><span class="type">bool</span> isSourceExists = QFile::<span class="built_in">exists</span>(sourcePath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isSourceExists) QFile::<span class="built_in">copy</span>(sourcePath, destinationPath);</span><br></pre></td></tr></table></figure><p>这是很简单的一个代码，仅仅是将文件简单的复制到目标位置，但是在目标路径上死活没看到文件，isDestinationExists和isSourceExists都是true，执行QFile::copy(sourcePath, destinationPath)也是true，当我是用remove()函数尝试删除destinationPath文件后，再次运行，isDestinationExists返回的是false，证明目标文件已经被删除了，在C盘的其他目录下如C:&#x2F;Windows&#x2F;System都是成功的能拷贝成功，而且QFile::copy(sourcePath, destinationPath)也是true，使用的是管理员打开，证明不存在权限问题。</p><p>这是由于Windows的文件系统重定向导致的。%windir%\System32 目录是为 64 位 Windows 上的 64 位应用程序保留的。 创建 64 位版本的 DLL 时，大多数 DLL 文件名未更改，因此 32 位版本的 DLL 存储在不同的目录中。 WOW64 通过使用 <em>文件系统重定向程序</em>来隐藏此差异。</p><p>在大多数情况下，每当 32 位应用程序尝试访问 %windir%\System32、%windir%\lastgood\system32 或 %windir%\regedit.exe时，访问都会重定向到特定于体系结构的路径。</p><p>如：</p><ol><li>有一个 64 位的 DLL 文件放在 <code>C:\Windows\System32\example.dll</code>，同时有一个 32 位的 DLL 文件放在 <code>C:\Windows\SysWOW64\example.dll</code>。</li><li>当一个 32 位应用程序尝试 <code>LoadLibrary</code> 去加载 <code>C:\Windows\System32\example.dll</code>，实际上它会加载 <code>C:\Windows\SysWOW64\example.dll</code>，因为系统的重定向机制将请求指向了 <code>SysWOW64</code>。</li></ol><p>如图所示：</p><p><img src="https://gitee.com/ou-qingshen/markdown/raw/master/image-20240929214652413.png" alt="image-20240929214652413"></p><p>而我的程序，也正是被强大的Windows重定向到了C:\Windows\SysWOW64目录下</p><p>解决办法：</p><ol><li>64位程序访问32位系统目录：若要检索 32 位系统目录的名称，64 位应用程序应使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/wow64apiset/nf-wow64apiset-getsystemwow64directory2a"><strong>GetSystemWow64Directory2</strong></a> 函数 (Windows 10版本 1511) 或 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/wow64apiset/nf-wow64apiset-getsystemwow64directorya"><strong>GetSystemWow64Directory</strong></a> 函数。</li><li>32位程序访问64位系统目录：<strong>32 位应用程序可以通过将 %windir%\Sysnative 替换为 %windir%\System32 来访问本机系统目录。 WOW64 将 Sysnative 识别为用于指示文件系统不应重定向访问的特殊别名，官方建议使用此机制绕过文件系统重定向。</strong> 应用程序也可以使用 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/wow64apiset/nf-wow64apiset-wow64disablewow64fsredirection"><strong>Wow64DisableWow64FsRedirection、Wow64EnableWow64FsRedirection</strong></a> 和 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/wow64apiset/nf-wow64apiset-wow64revertwow64fsredirection"><strong>Wow64RevertWow64FsRedirection 函数来控制 WOW64</strong></a> 文件系统重定向程序。 禁用文件系统重定向会影响调用线程执行的所有文件操作，因此仅当单个 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea"><strong>CreateFile</strong></a> 调用需要时才禁用它，并在函数返回后立即重新启用。 长时间禁用文件系统重定向可能会阻止 32 位应用程序加载系统 DLL，从而导致应用程序失败。</li></ol><p>在我们的例子当中，根据官方建议的做法，32位程序想要访问64位的系统目录，需要通过 <code>C:\Windows\Sysnative\example.dll</code> 访问。</p><p>第二种做法是利用windows的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Wow64Redirection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PVOID OldValue;</span><br><span class="line">    <span class="comment">//禁止文件系统重定向</span></span><br><span class="line">   <span class="built_in">Wow64DisableWow64FsRedirection</span>(&amp;OldValue)) &#123;</span><br><span class="line">       <span class="comment">//现在进入的是C:\\Windows\\System32目录下</span></span><br><span class="line">        <span class="keyword">if</span> (QFile::<span class="built_in">exists</span>(<span class="string">&quot;C:\\Windows\\System32\\wintun.dll&quot;</span>)) &#123;</span><br><span class="line">        QFile::<span class="built_in">copy</span>(QFile::<span class="built_in">copy</span>( QApplication::<span class="built_in">applicationDirPath</span>() + <span class="string">&quot;/wintun.dll&quot;</span>, <span class="string">&quot;C:\\Windows\\System32\\wintun.dll&quot;</span>););</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//打开文件系统重定向</span></span><br><span class="line">    <span class="built_in">Wow64RevertWow64FsRedirection</span>(OldValue);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="开发技巧"><a href="#开发技巧" class="headerlink" title="开发技巧"></a>开发技巧</h1><p>x’x’x’x’x’x’x’x’x’xx’x’x’x’x’xx’x’x’x’x</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Qt相关&quot;&gt;&lt;a href=&quot;#Qt相关&quot; class=&quot;headerlink&quot; title=&quot;Qt相关&quot;&gt;&lt;/a&gt;Qt相关&lt;/h1&gt;&lt;h3 id=&quot;1-编码问题&quot;&gt;&lt;a href=&quot;#1-编码问题&quot; class=&quot;headerlink&quot; title=&quot;1. 编码</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://cpp-memory-leaks.github.io/2024/12/05/hello-world/"/>
    <id>https://cpp-memory-leaks.github.io/2024/12/05/hello-world/</id>
    <published>2024-12-05T13:55:29.018Z</published>
    <updated>2024-12-06T16:30:49.423Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
