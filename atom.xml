<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stack Overflow</title>
  
  
  <link href="https://cpp-memory-leaks.github.io/atom.xml" rel="self"/>
  
  <link href="https://cpp-memory-leaks.github.io/"/>
  <updated>2025-08-22T15:58:15.266Z</updated>
  <id>https://cpp-memory-leaks.github.io/</id>
  
  <author>
    <name>OQS</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CppRestSDK编译ASIO版本过程</title>
    <link href="https://cpp-memory-leaks.github.io/2025/08/21/CppRestSDK%E7%BC%96%E8%AF%91ASIO%E7%89%88%E6%9C%AC%E8%BF%87%E7%A8%8B/"/>
    <id>https://cpp-memory-leaks.github.io/2025/08/21/CppRestSDK%E7%BC%96%E8%AF%91ASIO%E7%89%88%E6%9C%AC%E8%BF%87%E7%A8%8B/</id>
    <published>2025-08-21T13:25:28.000Z</published>
    <updated>2025-08-22T15:58:15.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CppRestSDK编译ASIO版本过程"><a href="#CppRestSDK编译ASIO版本过程" class="headerlink" title="CppRestSDK编译ASIO版本过程"></a>CppRestSDK编译ASIO版本过程</h1><h2 id="1-下载源码"><a href="#1-下载源码" class="headerlink" title="1. 下载源码"></a>1. 下载源码</h2><p>使用git命令下载cpprest代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b v2.10.12 https://github.com/microsoft/cpprestsdk.git</span><br></pre></td></tr></table></figure><h2 id="2-修改下载的源码"><a href="#2-修改下载的源码" class="headerlink" title="2. 修改下载的源码"></a>2. 修改下载的源码</h2><h3 id="2-1-修复CMakeLists文件Bug"><a href="#2-1-修复CMakeLists文件Bug" class="headerlink" title="2.1 修复CMakeLists文件Bug"></a>2.1 修复CMakeLists文件Bug</h3><p>cpprestsdk的2.10.12版本的CMakeLists是有bug的，asio异步所需要的threadpool.cpp文件只有不排除websocket库的情况下才会链接到项目。显然目前项目是不需要websocket的，所以得强制让threadpool链接到项目里去，否则报无法解析的外部符号。</p><p>需要根据GitHub上该开源库的pull request修改：</p><ul><li>修改 <code>Release/src/CmakeLists.txt</code> 文件</li><li>修改 <code>Release/src/pplx/threadpool.cpp</code> 文件</li></ul><p>参考链接：<a href="https://github.com/microsoft/cpprestsdk/pull/1466/files">https://github.com/microsoft/cpprestsdk/pull/1466/files</a></p><h3 id="2-2-修改警告设置"><a href="#2-2-修改警告设置" class="headerlink" title="2.2 修改警告设置"></a>2.2 修改警告设置</h3><p>Release下的CMakeLists文件的第18行，默认开启将警告视为报错，cmake不会报错，但make的时候会将所有的warning都会作为错误抛出，需要将ON改为OFF。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原代码</span></span><br><span class="line"><span class="keyword">set</span>(WERROR <span class="keyword">ON</span> CACHE BOOL <span class="string">&quot;Treat Warnings as Errors.&quot;</span>)</span><br><span class="line"><span class="comment"># 修改为</span></span><br><span class="line"><span class="keyword">set</span>(WERROR <span class="keyword">OFF</span> CACHE BOOL <span class="string">&quot;Treat Warnings as Errors.&quot;</span>)</span><br></pre></td></tr></table></figure><p>或者可以在cmake命令中将该宏设置为OFF：<code>-DWERROR=OFF</code></p><p>参考链接：<a href="https://github.com/microsoft/cpprestsdk/issues/1290">https://github.com/microsoft/cpprestsdk/issues/1290</a></p><h2 id="3-编写cmake命令"><a href="#3-编写cmake命令" class="headerlink" title="3. 编写cmake命令"></a>3. 编写cmake命令</h2><h3 id="3-1-Windows"><a href="#3-1-Windows" class="headerlink" title="3.1 Windows"></a>3.1 Windows</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&quot;D:\software\CMake\bin\cmake.exe&quot; ^</span><br><span class="line"> -DCMAKE_BUILD_TYPE=Debug ^</span><br><span class="line"> -G&quot;Visual Studio 15 2017 Win64&quot; ^</span><br><span class="line"> -DOPENSSL_ROOT_DIR=&quot;D:/DevThirdpartyLib_2017/Openssl/openssl-1.1.1g/&quot; ^</span><br><span class="line"> -DOPENSSL_LIBRARIES=&quot;D:/DevThirdpartyLib_2017/Openssl/openssl-1.1.1g/lib64&quot; ^</span><br><span class="line"> -DOPENSSL_SSL_LIBRARY=&quot;D:/DevThirdpartyLib_2017/Openssl/openssl-1.1.1g/lib64/libssl.lib&quot; ^</span><br><span class="line"> -DOPENSSL_CRYPTO_LIBRARY=&quot;D:/DevThirdpartyLib_2017/Openssl/openssl-1.1.1g/lib64/libcrypto.lib&quot; ^</span><br><span class="line"> -DOPENSSL_INCLUDE_DIR=&quot;D:/DevThirdpartyLib_2017/Openssl/openssl-1.1.1g/include&quot; ^</span><br><span class="line"> -DZLIB_INCLUDE_DIR=&quot;D:/DevThirdpartyLib_2017/Zlib/zlib_1_2_11/include&quot; ^</span><br><span class="line"> -DZLIB_LIBRARY=&quot;D:/DevThirdpartyLib_2017/Zlib/zlib_1_2_11/lib64/zlibd1.lib&quot; ^</span><br><span class="line"> -DCPPREST_EXCLUDE_WEBSOCKETS:BOOL=ON ^</span><br><span class="line"> -DBoost_INCLUDE_DIRS=&quot;D:/DevThirdpartyLib_2017/boost/boost_1_68&quot; ^</span><br><span class="line"> -DBOOST_LIBRARYDIR=&quot;D:/DevThirdpartyLib_2017/boost/boost_1_68/lib/x64&quot; ^</span><br><span class="line"> -DBOOST_ROOT=&quot;D:/DevThirdpartyLib_2017/boost/boost_1_68&quot; ^</span><br><span class="line"> -DBoost_SYSTEM_LIBRARY_DEBUG=&quot;D:/DevThirdpartyLib_2017/boost/boost_1_68/lib/x64/libboost_system-vc141-mt-gd-x64-1_68.lib&quot; ^</span><br><span class="line"> -DBoost_DATE_TIME_LIBRARY_DEBUG=&quot;D:/DevThirdpartyLib_2017/boost/boost_1_68/lib/x64/libboost_date_time-vc141-mt-gd-x64-1_68.lib&quot; ^</span><br><span class="line"> -DBoost_REGEX_LIBRARY_DEBUG=&quot;D:/DevThirdpartyLib_2017/boost/boost_1_68/lib/x64/libboost_regex-vc141-mt-gd-x64-1_68.lib&quot; ^</span><br><span class="line"> -DCPPREST_HTTP_CLIENT_IMPL:STRING=&quot;asio&quot; ^</span><br><span class="line"> -DCPPREST_HTTP_LISTENER_IMPL:STRING=&quot;asio&quot; ^</span><br><span class="line"> -DBUILD_TESTS:BOOL=OFF ^</span><br><span class="line"> -DBUILD_SAMPLES:BOOL=OFF</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><code>D:\software\CMake\bin\cmake.exe</code> 替换为实际的cmake安装路径</li><li><code>-DCMAKE_BUILD_TYPE</code> 和 <code>Win64</code> 根据所需Debug还是Release替换</li><li>在Windows上指定boost的根目录路径没生效，可能是由于boost的lib命名过于复杂，所以直接指定了所需要的库</li><li><code>-DCPPREST_EXCLUDE_WEBSOCKETS:BOOL=ON</code> 这个宏是为了排除websocket模块</li><li><code>-DCPPREST_HTTP_CLIENT_IMPL:STRING=&quot;asio&quot; -DCPPREST_HTTP_LISTENER_IMPL:STRING=&quot;asio&quot;</code> 是为了让cmake将cpprest的请求和监听底层实现指定为使用boost.asio</li><li><code>-DBUILD_TESTS:BOOL=OFF -DBUILD_SAMPLES:BOOL=OFF</code> 不要生成不必要的sample项目解决方案</li></ul><blockquote><p><strong>注意：</strong> 生成的sln的配置可能还不完善，一些库的路径可能是不对的，有问题的还需要配置一下。</p></blockquote><h3 id="3-2-Linux"><a href="#3-2-Linux" class="headerlink" title="3.2 Linux"></a>3.2 Linux</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cmake \</span><br><span class="line">  -DCMAKE_INSTALL_PREFIX=/root/oqs/cpprestsdk_build/cpprestsdk \</span><br><span class="line">  -DCMAKE_BUILD_TYPE=Release \</span><br><span class="line">  -DCPPREST_EXCLUDE_WEBSOCKETS=ON \</span><br><span class="line">  -DZLIB_INCLUDE_DIR=/root/oqs/cpprestsdk_build/zlib/include \</span><br><span class="line">  -DZLIB_LIBRARY=/root/oqs/cpprestsdk_build/zlib/lib/libz.so \</span><br><span class="line">  -DZLIB_ROOT_DIR=/root/oqs/cpprestsdk_build/zlib/ \</span><br><span class="line">  -DOPENSSL_ROOT_DIR=/root/oqs/cpprestsdk_build/openssl/ \</span><br><span class="line">  -DOPENSSL_INCLUDE_DIR=/root/oqs/cpprestsdk_build/openssl/include \</span><br><span class="line">  -DBOOST_LIBRARYDIR=/root/oqs/cpprestsdk_build/boost/lib \</span><br><span class="line">  -DBOOST_ROOT=/root/oqs/cpprestsdk_build/boost/include \</span><br><span class="line">  -DCPPREST_HTTP_CLIENT_IMPL:STRING=<span class="string">&quot;asio&quot;</span> \</span><br><span class="line">  -DCPPREST_HTTP_LISTENER_IMPL:STRING=<span class="string">&quot;asio&quot;</span> \</span><br><span class="line">  -DBUILD_TESTS:BOOL=OFF \</span><br><span class="line">  -DBUILD_SAMPLES:BOOL=OFF</span><br></pre></td></tr></table></figure><p>宏的作用跟Windows上的大差不差。</p><h2 id="4-编译"><a href="#4-编译" class="headerlink" title="4. 编译"></a>4. 编译</h2><h3 id="4-1-Windows"><a href="#4-1-Windows" class="headerlink" title="4.1 Windows"></a>4.1 Windows</h3><p>直接用Visual Studio</p><h3 id="4-2-Linux"><a href="#4-2-Linux" class="headerlink" title="4.2 Linux"></a>4.2 Linux</h3><p>使用make命令或者 <code>make -j8</code>（多线程编译）</p><h2 id="5-使用"><a href="#5-使用" class="headerlink" title="5. 使用"></a>5. 使用</h2><h3 id="5-1-Linux和Windows都需要修改的地方"><a href="#5-1-Linux和Windows都需要修改的地方" class="headerlink" title="5.1 Linux和Windows都需要修改的地方"></a>5.1 Linux和Windows都需要修改的地方</h3><p><strong>CPPRest配置：</strong></p><p>cpprest的ssl_context函数是根据这个宏决定是否打开的，在Windows上使用asio版本的cpprest，需要在项目上根据需要在代码或者预处理器上加上这两个宏：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPPREST_FORCE_HTTP_CLIENT_ASIO</span><br><span class="line">CPPREST_FORCE_HTTP_LISTENER_ASIO</span><br></pre></td></tr></table></figure><p><strong>gSOAP配置：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WITH_IPV6 </span><br><span class="line">WITH_NO_IPV6_V6ONLY</span><br></pre></td></tr></table></figure><h3 id="5-2-Windows特定配置"><a href="#5-2-Windows特定配置" class="headerlink" title="5.2 Windows特定配置"></a>5.2 Windows特定配置</h3><p>在Windows上使用boost，由于boost自身有文件引用了winsock.h头文件，且我们的项目中stdafx.h中可能已经通过某些宏或者直接添加了该头文件，导致编译过程会报：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WinSock.h has already been included</span><br></pre></td></tr></table></figure><p>解决方案：</p><ol><li>将stdafx.h中引入该头文件的代码注释掉</li><li>在项目方案加上该宏：<code>WIN32_LEAN_AND_MEAN</code></li></ol><p>参考链接：<a href="https://stackoverflow.com/questions/30731173/error-winsock-h-has-already-been-included-boost-windows-qt">https://stackoverflow.com/questions/30731173/error-winsock-h-has-already-been-included-boost-windows-qt</a></p><p><strong>IPv6地址格式：</strong> IPv6地址注意要带上中括号 <code>[]</code></p><h3 id="5-3-Linux特定配置"><a href="#5-3-Linux特定配置" class="headerlink" title="5.3 Linux特定配置"></a>5.3 Linux特定配置</h3><p><strong>IPv6地址格式：</strong> 在Linux上，IPv6地址是不需要添加中括号的，否则会解析失败。</p><p><strong>双栈支持配置：</strong></p><p>在Linux上使用PF_UNSPEC在getaddrinfo后会得到INET（IPv4），这不是期望的结果。期望的效果是得到PF_INET6+WITH_NO_IPV6_V6ONLY（也就是WITH_IPV6 WITH_NO_IPV6_V6ONLY）从而达到双栈的效果。</p><p>原因是PF_UNSPEC在Linux上通过getaddrinfo获取协议族过程中，找到协议后（无论是IPv4还是IPv6）就直接返回了。</p><p><strong>修改方法：</strong></p><p>在 <code>stdsoap.cpp</code> 的第5714行将：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hints.ai_family = PF_UNSPEC</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hints.ai_family = PF_INET6</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 在Windows上同样修改也没发现同样的问题，所以应该可以不区分平台。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CppRestSDK编译ASIO版本过程&quot;&gt;&lt;a href=&quot;#CppRestSDK编译ASIO版本过程&quot; class=&quot;headerlink&quot; title=&quot;CppRestSDK编译ASIO版本过程&quot;&gt;&lt;/a&gt;CppRestSDK编译ASIO版本过程&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="C++" scheme="https://cpp-memory-leaks.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>使用libheif库读取heic文件的缩略图</title>
    <link href="https://cpp-memory-leaks.github.io/2025/03/17/%E4%BD%BF%E7%94%A8libheif%E5%BA%93%E8%AF%BB%E5%8F%96heic%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%A9%E7%95%A5%E5%9B%BE/"/>
    <id>https://cpp-memory-leaks.github.io/2025/03/17/%E4%BD%BF%E7%94%A8libheif%E5%BA%93%E8%AF%BB%E5%8F%96heic%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%A9%E7%95%A5%E5%9B%BE/</id>
    <published>2025-03-17T12:18:50.000Z</published>
    <updated>2025-08-21T14:55:25.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用libheif库读取heic文件的缩略图"><a href="#使用libheif库读取heic文件的缩略图" class="headerlink" title="使用libheif库读取heic文件的缩略图"></a>使用libheif库读取heic文件的缩略图</h1><h2 id="1-先使用vcpkg安装libheif库"><a href="#1-先使用vcpkg安装libheif库" class="headerlink" title="1.先使用vcpkg安装libheif库"></a>1.先使用vcpkg安装libheif库</h2><p>在开始之前，我们需要安装 libheif 库。通过 vcpkg 工具可以方便地安装所需的依赖，根据实际需求选择适合的位数以及动态库或静态库版本。</p><p>安装命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install libheif:x86-windows-static</span><br><span class="line">vcpkg install libheif:x64-windows-static</span><br></pre></td></tr></table></figure><p>完成安装后，确保正确配置 vcpkg 环境，能够被 CMake 或其他构建工具找到。</p><h2 id="2-解码缩略图和解码原图的区别"><a href="#2-解码缩略图和解码原图的区别" class="headerlink" title="2.解码缩略图和解码原图的区别"></a>2.解码缩略图和解码原图的区别</h2><p>在处理 HEIC 格式文件时，缩略图解码和原图解码的使用场景有所不同。以下从资源占用和代码实现两方面进行比较。</p><p>1.解码原图</p><p>解码原图时，图像数据会被完全加载到内存中，适合用于查看高清图片或后续进行深度处理。但这也意味着需要更多的内存和 CPU 资源。</p><img src="/2025/03/17/%E4%BD%BF%E7%94%A8libheif%E5%BA%93%E8%AF%BB%E5%8F%96heic%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%A9%E7%95%A5%E5%9B%BE/%E8%A7%A3%E7%A0%81%E5%8E%9F%E5%9B%BE%E5%8D%A0%E7%94%A8%E7%9A%84cpu%E5%92%8C%E5%86%85%E5%AD%98.gif" class="" title="解码原图占用的cpu和内存"><p>2.解码缩略图</p><p>如果仅用于预览或快速浏览，可以选择解码缩略图。这种方法占用资源更少，加载速度更快，非常适合需要快速显示大量图片的场景。</p><img src="/2025/03/17/%E4%BD%BF%E7%94%A8libheif%E5%BA%93%E8%AF%BB%E5%8F%96heic%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%A9%E7%95%A5%E5%9B%BE/%E5%8A%A0%E8%BD%BD%E7%BC%A9%E7%95%A5%E5%9B%BE%E5%8D%A0%E7%94%A8%E7%9A%84cpu%E5%92%8C%E5%86%85%E5%AD%98.gif" class="" title="加载缩略图占用的cpu和内存"><p>解码原图（查看图片使用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heifToQPixmap</span><span class="params">(<span class="type">const</span> QString&amp; filePath, QPixmap&amp; pixmap)</span> </span>&#123;</span><br><span class="line">QString extension = <span class="built_in">QFileInfo</span>(filePath).<span class="built_in">suffix</span>().<span class="built_in">toLower</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (extension == <span class="string">&quot;jpg&quot;</span> || extension == <span class="string">&quot;jpeg&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!pixmap.<span class="built_in">load</span>(filePath)) &#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to load JPG image.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::string filePathStd = filePath.<span class="built_in">toStdString</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">heif_context</span>* ctx = <span class="built_in">heif_context_alloc</span>();</span><br><span class="line"><span class="keyword">if</span> (!ctx) &#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to allocate HEIF context.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">heif_error</span> err = <span class="built_in">heif_context_read_from_file</span>(ctx, filePathStd.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line"><span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to read HEIF file: &quot;</span> + std::<span class="built_in">string</span>(err.message));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">heif_image_handle</span>* handle = <span class="literal">nullptr</span>;</span><br><span class="line">err = <span class="built_in">heif_context_get_primary_image_handle</span>(ctx, &amp;handle);</span><br><span class="line"><span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line"><span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to get primary image handle: &quot;</span> + std::<span class="built_in">string</span>(err.message));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">heif_image</span>* img = <span class="literal">nullptr</span>;</span><br><span class="line">err = <span class="built_in">heif_decode_image</span>(handle, &amp;img, heif_colorspace_RGB, heif_chroma_interleaved_RGBA, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line"><span class="built_in">heif_image_handle_release</span>(handle);</span><br><span class="line"><span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to decode HEIF image: &quot;</span> + std::<span class="built_in">string</span>(err.message));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> width = <span class="built_in">heif_image_get_width</span>(img, heif_channel_interleaved);</span><br><span class="line"><span class="type">int</span> height = <span class="built_in">heif_image_get_height</span>(img, heif_channel_interleaved);</span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span>* data = <span class="built_in">heif_image_get_plane_readonly</span>(img, heif_channel_interleaved, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">QVector&lt;uchar&gt; <span class="title">buffer</span><span class="params">(width * height * <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="built_in">memcpy</span>(buffer.<span class="built_in">data</span>(), data, buffer.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="function">QImage <span class="title">image</span><span class="params">(buffer.data(), width, height, QImage::Format_RGBA8888)</span></span>;</span><br><span class="line">pixmap = QPixmap::<span class="built_in">fromImage</span>(image);</span><br><span class="line"></span><br><span class="line"><span class="built_in">heif_image_release</span>(img);</span><br><span class="line"><span class="built_in">heif_image_handle_release</span>(handle);</span><br><span class="line"><span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解码缩略图（供预览使用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">loadHeicThumbnail</span><span class="params">(<span class="type">const</span> QString&amp; filePath, QPixmap&amp; thumbnail)</span> </span>&#123;</span><br><span class="line">QString extension = <span class="built_in">QFileInfo</span>(filePath).<span class="built_in">suffix</span>().<span class="built_in">toLower</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (extension == <span class="string">&quot;jpg&quot;</span> || extension == <span class="string">&quot;jpeg&quot;</span>) &#123;</span><br><span class="line"><span class="function">QImageReader <span class="title">reader</span><span class="params">(filePath)</span></span>;</span><br><span class="line">reader.<span class="built_in">setAutoTransform</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">QSize originalSize = reader.<span class="built_in">size</span>(); </span><br><span class="line"><span class="keyword">if</span> (originalSize.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Failed to read image size:&quot;</span> &lt;&lt; reader.<span class="built_in">errorString</span>() &lt;&lt; filePath;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">QSize scaledSize = originalSize.<span class="built_in">scaled</span>(<span class="built_in">QSize</span>(originalSize/<span class="number">20</span>), Qt::KeepAspectRatio);</span><br><span class="line"></span><br><span class="line">reader.<span class="built_in">setScaledSize</span>(scaledSize);</span><br><span class="line"></span><br><span class="line">QImage image = reader.<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">if</span> (image.<span class="built_in">isNull</span>()) &#123;</span><br><span class="line"><span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;Failed to load image:&quot;</span> &lt;&lt; reader.<span class="built_in">errorString</span>() &lt;&lt; filePath;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thumbnail = QPixmap::<span class="built_in">fromImage</span>(image);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">heif_context* ctx = <span class="built_in">heif_context_alloc</span>();</span><br><span class="line">heif_error err = <span class="built_in">heif_context_read_from_file</span>(ctx, filePath.<span class="built_in">toStdString</span>().<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Failed to read HEIF file: &quot;</span>;</span><br><span class="line"><span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">heif_image_handle* handle = <span class="literal">nullptr</span>;</span><br><span class="line">err = <span class="built_in">heif_context_get_primary_image_handle</span>(ctx, &amp;handle);</span><br><span class="line"><span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Failed to get primary image handle: &quot;</span>;</span><br><span class="line"><span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">heif_image_handle* thumbnail_handle = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">int</span> num_thumbnails = <span class="built_in">heif_image_handle_get_number_of_thumbnails</span>(handle);</span><br><span class="line"><span class="keyword">if</span> (num_thumbnails &gt; <span class="number">0</span>) &#123;</span><br><span class="line">heif_item_id thumbnail_id;</span><br><span class="line"><span class="built_in">heif_image_handle_get_list_of_thumbnail_IDs</span>(handle, &amp;thumbnail_id, <span class="number">1</span>);</span><br><span class="line">err = <span class="built_in">heif_image_handle_get_thumbnail</span>(handle, thumbnail_id, &amp;thumbnail_handle);</span><br><span class="line"><span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Failed to get thumbnail handle: &quot;</span>;</span><br><span class="line"><span class="built_in">heif_image_handle_release</span>(handle);</span><br><span class="line"><span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码缩略图</span></span><br><span class="line">heif_image* thumbnail_image = <span class="literal">nullptr</span>;</span><br><span class="line">err = <span class="built_in">heif_decode_image</span>(thumbnail_handle, &amp;thumbnail_image, heif_colorspace_RGB, heif_chroma_interleaved_RGB, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Failed to decode thumbnail: &quot;</span> &lt;&lt; err.message;</span><br><span class="line"><span class="built_in">heif_image_handle_release</span>(thumbnail_handle);</span><br><span class="line"><span class="built_in">heif_image_handle_release</span>(handle);</span><br><span class="line"><span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> width = <span class="built_in">heif_image_get_width</span>(thumbnail_image, heif_channel_interleaved);</span><br><span class="line"><span class="type">int</span> height = <span class="built_in">heif_image_get_height</span>(thumbnail_image, heif_channel_interleaved);</span><br><span class="line"><span class="type">int</span> stride;</span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span>* data = <span class="built_in">heif_image_get_plane_readonly</span>(thumbnail_image, heif_channel_interleaved, &amp;stride);</span><br><span class="line"><span class="function">QImage <span class="title">image</span><span class="params">(data, width, height, stride, QImage::Format_RGB888)</span></span>; \</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (image.<span class="built_in">isNull</span>()) &#123;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Failed to convert HEIF thumbnail to QImage.&quot;</span>;</span><br><span class="line"><span class="built_in">heif_image_release</span>(thumbnail_image);</span><br><span class="line"><span class="built_in">heif_image_handle_release</span>(thumbnail_handle);</span><br><span class="line"><span class="built_in">heif_image_handle_release</span>(handle);</span><br><span class="line"><span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thumbnail = QPixmap::<span class="built_in">fromImage</span>(image.<span class="built_in">copy</span>());<span class="comment">//不使用copy data释放掉后内存访问冲突</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">heif_image_release</span>(thumbnail_image);</span><br><span class="line"><span class="built_in">heif_image_handle_release</span>(thumbnail_handle);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;No thumbnails found in the HEIF file.&quot;</span>;</span><br><span class="line"><span class="built_in">heif_image_handle_release</span>(handle);</span><br><span class="line"><span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">heif_image_handle_release</span>(handle);</span><br><span class="line"><span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-测试代码"><a href="#3-测试代码" class="headerlink" title="3.测试代码"></a>3.测试代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QImage&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPixmap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libheif/heif.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">QImage <span class="title">heifToQImage</span><span class="params">(<span class="type">const</span> std::string&amp; filePath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 libheif 句柄</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">heif_context</span>* ctx = <span class="built_in">heif_context_alloc</span>();</span><br><span class="line">    <span class="keyword">if</span> (!ctx) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to allocate HEIF context.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 HEIF 文件</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">heif_error</span> err = <span class="built_in">heif_context_read_from_file</span>(ctx, filePath.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line">        <span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to read HEIF file: &quot;</span> + std::<span class="built_in">string</span>(err.message));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取主图像句柄</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">heif_image_handle</span>* handle = <span class="literal">nullptr</span>;</span><br><span class="line">    err = <span class="built_in">heif_context_get_primary_image_handle</span>(ctx, &amp;handle);</span><br><span class="line">    <span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line">        <span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to get primary image handle: &quot;</span> + std::<span class="built_in">string</span>(err.message));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码图像</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">heif_image</span>* img = <span class="literal">nullptr</span>;</span><br><span class="line">    err = <span class="built_in">heif_decode_image</span>(handle, &amp;img, heif_colorspace_RGB, heif_chroma_interleaved_RGBA, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line">        <span class="built_in">heif_image_handle_release</span>(handle);</span><br><span class="line">        <span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to decode HEIF image: &quot;</span> + std::<span class="built_in">string</span>(err.message));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取图像数据</span></span><br><span class="line">    <span class="type">int</span> width = <span class="built_in">heif_image_get_width</span>(img, heif_channel_interleaved);</span><br><span class="line">    <span class="type">int</span> height = <span class="built_in">heif_image_get_height</span>(img, heif_channel_interleaved);</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span>* data = <span class="built_in">heif_image_get_plane_readonly</span>(img, heif_channel_interleaved, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建缓冲区并复制数据</span></span><br><span class="line">    <span class="function">QVector&lt;uchar&gt; <span class="title">buffer</span><span class="params">(width * height * <span class="number">4</span>)</span></span>; <span class="comment">// RGBA8888，每像素4字节</span></span><br><span class="line">    <span class="built_in">memcpy</span>(buffer.<span class="built_in">data</span>(), data, buffer.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为 QImage</span></span><br><span class="line">    <span class="function">QImage <span class="title">qimage</span><span class="params">(buffer.data(), width, height, QImage::Format_RGBA8888)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="built_in">heif_image_release</span>(img);</span><br><span class="line">    <span class="built_in">heif_image_handle_release</span>(handle);</span><br><span class="line">    <span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> qimage.<span class="built_in">copy</span>(); <span class="comment">// 确保 QImage 独立持有数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        QImage image = <span class="built_in">heifToQImage</span>(<span class="string">&quot;C:/Users/lianx/Pictures/IMG_0001.HEIC&quot;</span>);</span><br><span class="line"></span><br><span class="line">        QLabel label;</span><br><span class="line">        label.<span class="built_in">setPixmap</span>(QPixmap::<span class="built_in">fromImage</span>(image));</span><br><span class="line">        label.<span class="built_in">setScaledContents</span>(<span class="literal">true</span>);</span><br><span class="line">        label.<span class="built_in">resize</span>(image.<span class="built_in">size</span>()/<span class="number">2</span>);</span><br><span class="line">        label.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-效果如图"><a href="#4-效果如图" class="headerlink" title="4.效果如图"></a>4.效果如图</h2><p><img src="/2025/03/17/%E4%BD%BF%E7%94%A8libheif%E5%BA%93%E8%AF%BB%E5%8F%96heic%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%A9%E7%95%A5%E5%9B%BE/image-20241225235523540.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用libheif库读取heic文件的缩略图&quot;&gt;&lt;a href=&quot;#使用libheif库读取heic文件的缩略图&quot; class=&quot;headerlink&quot; title=&quot;使用libheif库读取heic文件的缩略图&quot;&gt;&lt;/a&gt;使用libheif库读取heic文件的缩</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Qt中各种图像的格式转换以及与cv::Mat图像格式之间的转换</title>
    <link href="https://cpp-memory-leaks.github.io/2025/01/22/Qt%E4%B8%AD%E5%90%84%E7%A7%8D%E5%9B%BE%E5%83%8F%E7%9A%84%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%BB%A5%E5%8F%8A%E4%B8%8Ecv-Mat%E5%9B%BE%E5%83%8F%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <id>https://cpp-memory-leaks.github.io/2025/01/22/Qt%E4%B8%AD%E5%90%84%E7%A7%8D%E5%9B%BE%E5%83%8F%E7%9A%84%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%BB%A5%E5%8F%8A%E4%B8%8Ecv-Mat%E5%9B%BE%E5%83%8F%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%BD%AC%E6%8D%A2/</id>
    <published>2025-01-21T16:33:34.000Z</published>
    <updated>2025-08-22T15:59:39.895Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 Qt 与 OpenCV 联合开发时，常常需要在 <code>QImage</code> 和 <code>cv::Mat</code> 之间进行图像格式转换。两者的图像格式不同，因此理解 <strong><code>QImage::Format</code> 与 <code>cv::Mat</code> 类型的对应关系</strong> 非常关键。以下是常见格式的对应关系表：</p><h2 id="1-QImage-Format-与-cv-Mat-类型对照表："><a href="#1-QImage-Format-与-cv-Mat-类型对照表：" class="headerlink" title="1. QImage::Format 与 cv::Mat 类型对照表："></a>1. <code>QImage::Format</code> 与 <code>cv::Mat</code> 类型对照表：</h2><table><thead><tr><th align="left">QImage::Format</th><th align="left">描述</th><th align="left">对应的 <code>cv::Mat</code> 类型</th><th>通道顺序</th></tr></thead><tbody><tr><td align="left"><code>QImage::Format_RGB888</code></td><td align="left">24-bit RGB（每像素3字节）</td><td align="left"><code>CV_8UC3</code></td><td>RGB → OpenCV中是BGR</td></tr><tr><td align="left"><code>QImage::Format_BGR888</code></td><td align="left">24-bit BGR（Qt 5.14+）</td><td align="left"><code>CV_8UC3</code></td><td>BGR</td></tr><tr><td align="left"><code>QImage::Format_ARGB32</code></td><td align="left">32-bit ARGB（Alpha在高字节）</td><td align="left"><code>CV_8UC4</code></td><td>BGRA（OpenCV里是BGRA）</td></tr><tr><td align="left"><code>QImage::Format_ARGB32_Premultiplied</code></td><td align="left">预乘Alpha的32位ARGB</td><td align="left"><code>CV_8UC4</code></td><td>BGRA（需额外处理Alpha）</td></tr><tr><td align="left"><code>QImage::Format_RGB32</code></td><td align="left">32-bit RGB（Alpha总为255）</td><td align="left"><code>CV_8UC4</code></td><td>BGRA（Alpha恒为255）</td></tr><tr><td align="left"><code>QImage::Format_Grayscale8</code></td><td align="left">8-bit 灰度图（Qt 5.5+）</td><td align="left"><code>CV_8UC1</code></td><td>灰度</td></tr><tr><td align="left"><code>QImage::Format_Indexed8</code></td><td align="left">8-bit索引图（常见于灰度图）</td><td align="left"><code>CV_8UC1</code></td><td>灰度</td></tr></tbody></table><h2 id="2-OpenCV图像底层"><a href="#2-OpenCV图像底层" class="headerlink" title="2. OpenCV图像底层"></a>2. OpenCV图像底层</h2><p>OpenCV 中的 <code>cv::Mat</code> 图像类型（type）是一个 <strong>整数类型常量（int）</strong>，这个整数中编码了两个关键信息：</p><ol><li><strong>每个通道的数据类型（depth）</strong></li><li><strong>通道数（channels）</strong></li></ol><p><strong>本质上的编码方式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type = (depth &amp; <span class="number">0x7</span>) + ((channels - <span class="number">1</span>) &lt;&lt; <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p> <strong>depth 和 channels 的取值</strong></p><table><thead><tr><th>数据类型</th><th>depth 宏常量值</th><th>二进制值</th><th>含义</th></tr></thead><tbody><tr><td><code>CV_8U</code></td><td>0</td><td>000</td><td>8-bit unsigned char</td></tr><tr><td><code>CV_8S</code></td><td>1</td><td>001</td><td>8-bit signed char</td></tr><tr><td><code>CV_16U</code></td><td>2</td><td>010</td><td>16-bit unsigned short</td></tr><tr><td><code>CV_16S</code></td><td>3</td><td>011</td><td>16-bit signed short</td></tr><tr><td><code>CV_32S</code></td><td>4</td><td>100</td><td>32-bit signed int</td></tr><tr><td><code>CV_32F</code></td><td>5</td><td>101</td><td>32-bit float</td></tr><tr><td><code>CV_64F</code></td><td>6</td><td>110</td><td>64-bit double</td></tr></tbody></table><p> <strong>通道数的编码方式：</strong></p><p>通道数编码在高位部分，每个通道是 <code>(channels - 1) &lt;&lt; 3</code>：</p><table><thead><tr><th>通道数（C）</th><th><code>(channels-1)&lt;&lt;3</code></th><th>最终编码中的通道部分</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>00000000</td></tr><tr><td>2</td><td>8</td><td>00001000</td></tr><tr><td>3</td><td>16</td><td>00010000</td></tr><tr><td>4</td><td>24</td><td>00011000</td></tr></tbody></table><p><strong>举例：<code>CV_8UC3</code> 是怎么计算出来的？</strong></p><ul><li><code>CV_8U</code> 的值是 <code>0</code></li><li><code>C3</code> 表示通道数是 3 → <code>(3-1)&lt;&lt;3 = 16</code></li><li>所以 <code>CV_8UC3 = 0 + 16 = 16</code></li></ul><blockquote><p><code>cv::Mat::type()</code> 返回的值就是这个整数（16）。</p></blockquote><p>再举几个：</p><table><thead><tr><th>宏定义</th><th>值</th><th>分解</th></tr></thead><tbody><tr><td><code>CV_8UC1</code></td><td>0</td><td><code>CV_8U + ((1-1)&lt;&lt;3)</code></td></tr><tr><td><code>CV_8UC2</code></td><td>8</td><td><code>CV_8U + ((2-1)&lt;&lt;3)</code></td></tr><tr><td><code>CV_8UC3</code></td><td>16</td><td><code>CV_8U + ((3-1)&lt;&lt;3)</code></td></tr><tr><td><code>CV_8UC4</code></td><td>24</td><td><code>CV_8U + ((4-1)&lt;&lt;3)</code></td></tr><tr><td><code>CV_16UC1</code></td><td>2</td><td><code>CV_16U + ((1-1)&lt;&lt;3)</code></td></tr><tr><td><code>CV_16UC3</code></td><td>18</td><td><code>CV_16U + ((3-1)&lt;&lt;3)</code></td></tr><tr><td><code>CV_32FC1</code></td><td>5</td><td><code>CV_32F + ((1-1)&lt;&lt;3)</code></td></tr><tr><td><code>CV_32FC3</code></td><td>21</td><td><code>CV_32F + ((3-1)&lt;&lt;3)</code></td></tr></tbody></table><h3 id="2-1-OpenCV-图像类型解释"><a href="#2-1-OpenCV-图像类型解释" class="headerlink" title="2.1 OpenCV 图像类型解释"></a>2.1 OpenCV 图像类型解释</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">====================== OpenCV 图像类型解剖 ======================</span><br><span class="line"></span><br><span class="line">类型格式：   CV_&lt;bit-depth&gt;&#123;U|S|F&#125;C&lt;channels&gt;</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">- CV         : OpenCV 类型前缀</span><br><span class="line">- bit-depth  : 每个通道的位深（<span class="number">8</span>/<span class="number">16</span>/<span class="number">32</span>/<span class="number">64</span>）</span><br><span class="line">- U/S/F      : </span><br><span class="line">    U = <span class="type">unsigned</span>（无符号整数） → uchar/ushort</span><br><span class="line">    S = <span class="type">signed</span>（有符号整数）   → <span class="type">char</span>/<span class="type">short</span>/<span class="type">int</span></span><br><span class="line">    F = <span class="type">float</span>（浮点数）        → <span class="type">float</span>/<span class="type">double</span></span><br><span class="line">- C&lt;channels&gt;: 通道数（C1~C4）</span><br><span class="line"></span><br><span class="line">====================== 常见类型举例 ========================</span><br><span class="line"></span><br><span class="line">CV_8UC1  → <span class="number">8</span>位无符号灰度图       → uchar 灰度图</span><br><span class="line">CV_8UC3  → <span class="number">8</span>位无符号彩色图（BGR）→ uchar 彩色图（BGR）</span><br><span class="line">CV_8UC4  → <span class="number">8</span>位无符号<span class="number">4</span>通道（BGRA）→ uchar BGRA 图</span><br><span class="line"></span><br><span class="line">CV_16UC1 → <span class="number">16</span>位无符号灰度图      → ushort 深度图、医学图像</span><br><span class="line">CV_16SC1 → <span class="number">16</span>位有符号灰度图      → <span class="type">short</span> 常用于梯度图、滤波</span><br><span class="line">CV_32FC1 → <span class="number">32</span>位浮点灰度图        → <span class="type">float</span> 图像处理、光流</span><br><span class="line">CV_64FC4 → <span class="number">64</span>位浮点<span class="number">4</span>通道图        → <span class="type">double</span> 高频计算图</span><br><span class="line"></span><br><span class="line">==================== 底层编码机制 =======================</span><br><span class="line"></span><br><span class="line">OpenCV 图像类型实际是一个整数，编码方式如下：</span><br><span class="line"></span><br><span class="line">type = (depth &amp; <span class="number">0x7</span>) + ((channels - <span class="number">1</span>) &lt;&lt; <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">depth 类型编码：</span><br><span class="line">    CV_8U  = <span class="number">0</span>   → <span class="type">unsigned</span> <span class="type">char</span></span><br><span class="line">    CV_8S  = <span class="number">1</span>   → <span class="type">char</span></span><br><span class="line">    CV_16U = <span class="number">2</span>   → <span class="type">unsigned</span> <span class="type">short</span></span><br><span class="line">    CV_16S = <span class="number">3</span>   → <span class="type">short</span></span><br><span class="line">    CV_32S = <span class="number">4</span>   → <span class="type">int</span></span><br><span class="line">    CV_32F = <span class="number">5</span>   → <span class="type">float</span></span><br><span class="line">    CV_64F = <span class="number">6</span>   → <span class="type">double</span></span><br><span class="line"></span><br><span class="line">通道数编码：(channels - <span class="number">1</span>) &lt;&lt; <span class="number">3</span></span><br><span class="line">    C1 = <span class="number">0</span> &lt;&lt; <span class="number">3</span> = <span class="number">0</span></span><br><span class="line">    C2 = <span class="number">1</span> &lt;&lt; <span class="number">3</span> = <span class="number">8</span></span><br><span class="line">    C3 = <span class="number">2</span> &lt;&lt; <span class="number">3</span> = <span class="number">16</span></span><br><span class="line">    C4 = <span class="number">3</span> &lt;&lt; <span class="number">3</span> = <span class="number">24</span></span><br><span class="line"></span><br><span class="line">例：CV_16UC3 = <span class="number">2</span>(depth) + (<span class="number">3</span><span class="number">-1</span>)&lt;&lt;<span class="number">3</span> = <span class="number">2</span> + <span class="number">16</span> = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">==========================================================</span><br><span class="line"></span><br><span class="line">小技巧：</span><br><span class="line"><span class="type">int</span> depth    = <span class="built_in">CV_MAT_DEPTH</span>(mat.<span class="built_in">type</span>());    <span class="comment">// 数据类型</span></span><br><span class="line"><span class="type">int</span> channels = <span class="built_in">CV_MAT_CN</span>(mat.<span class="built_in">type</span>());       <span class="comment">// 通道数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2-图像类型解剖图"><a href="#2-2-图像类型解剖图" class="headerlink" title="2.2 图像类型解剖图"></a>2.2 图像类型解剖图</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">        ┌──────────────┐</span><br><span class="line">        │ CV_16UC3     │</span><br><span class="line">        └─────┬────────┘</span><br><span class="line">              │</span><br><span class="line">     ┌────────▼────────────┐</span><br><span class="line">     │ CV_&lt;Depth&gt;&lt;C&gt;&lt;N&gt;    │</span><br><span class="line">     │                    │</span><br><span class="line">     │ Depth: <span class="number">16U</span>         │ → <span class="type">unsigned</span> <span class="type">short</span>（<span class="number">16</span>位无符号）</span><br><span class="line">     │ C: C3              │ → 三通道（一般 BGR）</span><br><span class="line">     └────────────────────┘</span><br><span class="line"></span><br><span class="line">底层编码：</span><br><span class="line">    depth = CV_16U = <span class="number">2</span>（<span class="number">0000</span> <span class="number">0010</span>）</span><br><span class="line">    channels = <span class="number">3</span> → (<span class="number">3</span><span class="number">-1</span>)&lt;&lt;<span class="number">3</span> = <span class="number">16</span>（<span class="number">0001</span> <span class="number">0000</span>）</span><br><span class="line">    → 最终类型 = <span class="number">2</span> + <span class="number">16</span> = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">    CV_16UC3 = <span class="number">18</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-图像格式转换"><a href="#3-图像格式转换" class="headerlink" title="3. 图像格式转换"></a>3. 图像格式转换</h2><h3 id="3-1cv-Mat-转-QImage"><a href="#3-1cv-Mat-转-QImage" class="headerlink" title="3.1cv::Mat 转 QImage"></a>3.1<code>cv::Mat</code> 转 <code>QImage</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QImage <span class="title">Mat2QImage</span><span class="params">(<span class="type">const</span> cv::Mat&amp; mat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (mat.<span class="built_in">type</span>()) &#123;</span><br><span class="line">    <span class="keyword">case</span> CV_8UC1: <span class="comment">// 灰度图</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QImage</span>(mat.data, mat.cols, mat.rows, mat.step, QImage::Format_Grayscale8).<span class="built_in">copy</span>();</span><br><span class="line">    <span class="keyword">case</span> CV_8UC3: <span class="comment">// 彩色图（BGR）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QImage</span>(mat.data, mat.cols, mat.rows, mat.step, QImage::Format_RGB888).<span class="built_in">rgbSwapped</span>().<span class="built_in">copy</span>();</span><br><span class="line">    <span class="keyword">case</span> CV_8UC4: <span class="comment">// BGRA 图</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QImage</span>(mat.data, mat.cols, mat.rows, mat.step, QImage::Format_ARGB32).<span class="built_in">copy</span>();</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QImage</span>(); <span class="comment">// 不支持的格式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-QImage-转-cv-Mat"><a href="#3-2-QImage-转-cv-Mat" class="headerlink" title="3.2 QImage 转 cv::Mat"></a>3.2 <code>QImage</code> 转 <code>cv::Mat</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">QImage2Mat</span><span class="params">(<span class="type">const</span> QImage&amp; image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (image.format()) &#123;</span><br><span class="line">    <span class="keyword">case</span> QImage::Format_RGB888:</span><br><span class="line">        <span class="keyword">return</span> cv::<span class="built_in">Mat</span>(image.<span class="built_in">height</span>(), image.<span class="built_in">width</span>(), CV_8UC3,</span><br><span class="line">                       <span class="built_in">const_cast</span>&lt;uchar*&gt;(image.<span class="built_in">bits</span>()), image.<span class="built_in">bytesPerLine</span>()).<span class="built_in">clone</span>();</span><br><span class="line">    <span class="keyword">case</span> QImage::Format_BGR888:</span><br><span class="line">        <span class="keyword">return</span> cv::<span class="built_in">Mat</span>(image.<span class="built_in">height</span>(), image.<span class="built_in">width</span>(), CV_8UC3,</span><br><span class="line">                       <span class="built_in">const_cast</span>&lt;uchar*&gt;(image.<span class="built_in">bits</span>()), image.<span class="built_in">bytesPerLine</span>()).<span class="built_in">clone</span>();</span><br><span class="line">    <span class="keyword">case</span> QImage::Format_ARGB32:</span><br><span class="line">    <span class="keyword">case</span> QImage::Format_RGB32:</span><br><span class="line">        <span class="keyword">return</span> cv::<span class="built_in">Mat</span>(image.<span class="built_in">height</span>(), image.<span class="built_in">width</span>(), CV_8UC4,</span><br><span class="line">                       <span class="built_in">const_cast</span>&lt;uchar*&gt;(image.<span class="built_in">bits</span>()), image.<span class="built_in">bytesPerLine</span>()).<span class="built_in">clone</span>();</span><br><span class="line">    <span class="keyword">case</span> QImage::Format_Grayscale8:</span><br><span class="line">    <span class="keyword">case</span> QImage::Format_Indexed8:</span><br><span class="line">        <span class="keyword">return</span> cv::<span class="built_in">Mat</span>(image.<span class="built_in">height</span>(), image.<span class="built_in">width</span>(), CV_8UC1,</span><br><span class="line">                       <span class="built_in">const_cast</span>&lt;uchar*&gt;(image.<span class="built_in">bits</span>()), image.<span class="built_in">bytesPerLine</span>()).<span class="built_in">clone</span>();</span><br><span class="line">    <span class="keyword">case</span> QImage::Format_Grayscale16: &#123;</span><br><span class="line">        <span class="keyword">return</span> cv::<span class="built_in">Mat</span>(image.<span class="built_in">height</span>(), image.<span class="built_in">width</span>(), CV_16UC1,</span><br><span class="line">                       <span class="built_in">const_cast</span>&lt;uchar*&gt;(image.<span class="built_in">bits</span>()), image.<span class="built_in">bytesPerLine</span>()).<span class="built_in">clone</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> cv::<span class="built_in">Mat</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-注意事项："><a href="#4-注意事项：" class="headerlink" title="4. 注意事项："></a>4. 注意事项：</h2><ul><li><code>QImage::Format_RGB888</code> 和 OpenCV 的 <code>CV_8UC3</code> 通道顺序不同（OpenCV默认是 BGR），所以常需要 <code>.rgbSwapped()</code>。</li><li><code>QImage::Format_RGB32</code> 实际也是 BGRA 格式，只不过 Alpha 通道为 255，OpenCV 也按 4 通道处理。</li><li><code>ARGB32_Premultiplied</code> 通常要特别处理 Alpha 通道（不常用）。</li><li>为了避免内存共享带来的问题，建议 <code>.copy()</code> 或 <code>.clone()</code>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在使用 Qt 与 OpenCV 联合开发时，常常需要在 &lt;code&gt;QImage&lt;/code&gt; 和 &lt;code&gt;cv::Mat&lt;/code&gt; 之间进行图像格式转换。两者的图像格式不同，因此理解 &lt;strong&gt;&lt;code&gt;QImage::Format&lt;/code&gt; 与 &lt;c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Qt使用libheif库显示苹果的heic图片</title>
    <link href="https://cpp-memory-leaks.github.io/2024/12/25/Qt%E4%BD%BF%E7%94%A8libheif%E5%BA%93%E6%98%BE%E7%A4%BA%E8%8B%B9%E6%9E%9C%E7%9A%84heic%E5%9B%BE%E7%89%87/"/>
    <id>https://cpp-memory-leaks.github.io/2024/12/25/Qt%E4%BD%BF%E7%94%A8libheif%E5%BA%93%E6%98%BE%E7%A4%BA%E8%8B%B9%E6%9E%9C%E7%9A%84heic%E5%9B%BE%E7%89%87/</id>
    <published>2024-12-25T12:17:31.000Z</published>
    <updated>2025-08-22T15:59:28.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Qt使用libheif库显示苹果的heic图片"><a href="#Qt使用libheif库显示苹果的heic图片" class="headerlink" title="Qt使用libheif库显示苹果的heic图片"></a>Qt使用libheif库显示苹果的heic图片</h1><h2 id="1-先使用vcpkg安装libheif库"><a href="#1-先使用vcpkg安装libheif库" class="headerlink" title="1.先使用vcpkg安装libheif库"></a>1.先使用vcpkg安装libheif库</h2><p>自己根据需要选择位数以及动态库还是静态库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install libheif:x86-windows-static</span><br><span class="line">vcpkg install libheif:x64-windows-static</span><br></pre></td></tr></table></figure><h2 id="2-直接上代码"><a href="#2-直接上代码" class="headerlink" title="2.直接上代码"></a>2.直接上代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QImage&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPixmap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libheif/heif.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">QImage <span class="title">heifToQImage</span><span class="params">(<span class="type">const</span> std::string&amp; filePath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 libheif 句柄</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">heif_context</span>* ctx = <span class="built_in">heif_context_alloc</span>();</span><br><span class="line">    <span class="keyword">if</span> (!ctx) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to allocate HEIF context.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 HEIF 文件</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">heif_error</span> err = <span class="built_in">heif_context_read_from_file</span>(ctx, filePath.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line">        <span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to read HEIF file: &quot;</span> + std::<span class="built_in">string</span>(err.message));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取主图像句柄</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">heif_image_handle</span>* handle = <span class="literal">nullptr</span>;</span><br><span class="line">    err = <span class="built_in">heif_context_get_primary_image_handle</span>(ctx, &amp;handle);</span><br><span class="line">    <span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line">        <span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to get primary image handle: &quot;</span> + std::<span class="built_in">string</span>(err.message));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码图像</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">heif_image</span>* img = <span class="literal">nullptr</span>;</span><br><span class="line">    err = <span class="built_in">heif_decode_image</span>(handle, &amp;img, heif_colorspace_RGB, heif_chroma_interleaved_RGBA, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (err.code != heif_error_Ok) &#123;</span><br><span class="line">        <span class="built_in">heif_image_handle_release</span>(handle);</span><br><span class="line">        <span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to decode HEIF image: &quot;</span> + std::<span class="built_in">string</span>(err.message));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取图像数据</span></span><br><span class="line">    <span class="type">int</span> width = <span class="built_in">heif_image_get_width</span>(img, heif_channel_interleaved);</span><br><span class="line">    <span class="type">int</span> height = <span class="built_in">heif_image_get_height</span>(img, heif_channel_interleaved);</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span>* data = <span class="built_in">heif_image_get_plane_readonly</span>(img, heif_channel_interleaved, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建缓冲区并复制数据</span></span><br><span class="line">    <span class="function">QVector&lt;uchar&gt; <span class="title">buffer</span><span class="params">(width * height * <span class="number">4</span>)</span></span>; <span class="comment">// RGBA8888，每像素4字节</span></span><br><span class="line">    <span class="built_in">memcpy</span>(buffer.<span class="built_in">data</span>(), data, buffer.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为 QImage</span></span><br><span class="line">    <span class="function">QImage <span class="title">qimage</span><span class="params">(buffer.data(), width, height, QImage::Format_RGBA8888)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="built_in">heif_image_release</span>(img);</span><br><span class="line">    <span class="built_in">heif_image_handle_release</span>(handle);</span><br><span class="line">    <span class="built_in">heif_context_free</span>(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> qimage.<span class="built_in">copy</span>(); <span class="comment">// 确保 QImage 独立持有数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        QImage image = <span class="built_in">heifToQImage</span>(<span class="string">&quot;C:/Users/lianx/Pictures/IMG_0001.HEIC&quot;</span>);</span><br><span class="line"></span><br><span class="line">        QLabel label;</span><br><span class="line">        label.<span class="built_in">setPixmap</span>(QPixmap::<span class="built_in">fromImage</span>(image));</span><br><span class="line">        label.<span class="built_in">setScaledContents</span>(<span class="literal">true</span>);</span><br><span class="line">        label.<span class="built_in">resize</span>(image.<span class="built_in">size</span>()/<span class="number">2</span>);</span><br><span class="line">        label.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-效果如图"><a href="#3-效果如图" class="headerlink" title="3.效果如图"></a>3.效果如图</h2><img src="/2024/12/25/Qt%E4%BD%BF%E7%94%A8libheif%E5%BA%93%E6%98%BE%E7%A4%BA%E8%8B%B9%E6%9E%9C%E7%9A%84heic%E5%9B%BE%E7%89%87/image-20241225235523540.png" class="" title="image-20241225235523540">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Qt使用libheif库显示苹果的heic图片&quot;&gt;&lt;a href=&quot;#Qt使用libheif库显示苹果的heic图片&quot; class=&quot;headerlink&quot; title=&quot;Qt使用libheif库显示苹果的heic图片&quot;&gt;&lt;/a&gt;Qt使用libheif库显示苹果的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>QCheckBox的三态复选框和反选</title>
    <link href="https://cpp-memory-leaks.github.io/2024/12/25/QCheckBox%E7%9A%84%E4%B8%89%E6%80%81%E5%A4%8D%E9%80%89%E6%A1%86%E5%92%8C%E5%8F%8D%E9%80%89/"/>
    <id>https://cpp-memory-leaks.github.io/2024/12/25/QCheckBox%E7%9A%84%E4%B8%89%E6%80%81%E5%A4%8D%E9%80%89%E6%A1%86%E5%92%8C%E5%8F%8D%E9%80%89/</id>
    <published>2024-12-25T11:10:56.000Z</published>
    <updated>2025-08-22T16:04:46.602Z</updated>
    
    <content type="html"><![CDATA[<h1 id="QCheckBox的三态复选框以及反选"><a href="#QCheckBox的三态复选框以及反选" class="headerlink" title="QCheckBox的三态复选框以及反选"></a>QCheckBox的三态复选框以及反选</h1><p>在使用这个控件的时候，需求有可能是：<strong>点击复选框实线反选，并且选中项目的时候需要显示未选中、部分选中和全选</strong>。在这个需求当中，首先想到的是直接启用三态复选框，但是点击的时候就变成了可以点三次，这就和反选冲突了。</p><h2 id="1-QCheckBox的三种状态："><a href="#1-QCheckBox的三种状态：" class="headerlink" title="1.QCheckBox的三种状态："></a>1.QCheckBox的三种状态：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">CheckState</span> &#123;</span><br><span class="line">    Unchecked,</span><br><span class="line">    PartiallyChecked,</span><br><span class="line">    Checked</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-如何启用三态复选框"><a href="#2-如何启用三态复选框" class="headerlink" title="2.如何启用三态复选框"></a>2.如何启用三态复选框</h2><p>使用setTristate(true)即可开启，使用void QCheckBox::setCheckState(<a href="../qtcore/qt.html#CheckState-enum">Qt::CheckState</a> <em>state</em>)参数为Qt::PartiallyChecked也会启用三态</p><img src="/2024/12/25/QCheckBox%E7%9A%84%E4%B8%89%E6%80%81%E5%A4%8D%E9%80%89%E6%A1%86%E5%92%8C%E5%8F%8D%E9%80%89/image-20241225165142718.png" class="" title="image-20241225165142718"><h2 id="3-如何实现需求"><a href="#3-如何实现需求" class="headerlink" title="3.如何实现需求"></a>3.如何实现需求</h2><p>显示选中状态：选择项目的时候根据选中情况设置QCheckBox的状态（如在QListView中可以通过QItemSelectionModel::selectionChanged信号实时统计）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (selectedItems == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ui-&gt;checkBox_select-&gt;<span class="built_in">setCheckState</span>(Qt::Unchecked);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (selectedItems &lt; totalItems)</span><br><span class="line">&#123;</span><br><span class="line">ui-&gt;checkBox_select-&gt;<span class="built_in">setCheckState</span>(Qt::PartiallyChecked);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ui-&gt;checkBox_select-&gt;<span class="built_in">setCheckState</span>(Qt::Checked);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反选：点击checkBox后关掉三态，当你再次触发selectionChanged时三态复选框重新启用，即可实现实时选中及反选功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ui-&gt;checkBox_select, &amp;QCheckBox::clicked, <span class="keyword">this</span>, &amp;MainWindow::selectAll);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PhoneToPCPage::selectAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ui-&gt;checkBox_select-&gt;<span class="built_in">setTristate</span>(<span class="literal">false</span>);</span><br><span class="line">QListView* listView = <span class="built_in">getListView</span>();</span><br><span class="line"><span class="keyword">if</span> (listView == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">QItemSelectionModel* selectionModel = listView-&gt;<span class="built_in">selectionModel</span>();</span><br><span class="line">QAbstractItemModel* model = listView-&gt;<span class="built_in">model</span>();</span><br><span class="line"><span class="type">bool</span> selectAll = ui-&gt;checkBox_select-&gt;<span class="built_in">checkState</span>() == Qt::Checked;</span><br><span class="line"><span class="keyword">if</span> (selectAll) &#123;</span><br><span class="line">QItemSelection selection;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; model-&gt;<span class="built_in">rowCount</span>(); ++row) &#123;</span><br><span class="line">QModelIndex index = model-&gt;<span class="built_in">index</span>(row, <span class="number">0</span>);</span><br><span class="line">selection.<span class="built_in">select</span>(index, index);</span><br><span class="line">&#125;</span><br><span class="line">selectionModel-&gt;<span class="built_in">select</span>(selection, QItemSelectionModel::Select);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">selectionModel-&gt;<span class="built_in">clearSelection</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-效果图"><a href="#3-效果图" class="headerlink" title="3.效果图"></a>3.效果图</h2><img src="/2024/12/25/QCheckBox%E7%9A%84%E4%B8%89%E6%80%81%E5%A4%8D%E9%80%89%E6%A1%86%E5%92%8C%E5%8F%8D%E9%80%89/image-20241225170603608.png" class="" title="image-20241225170603608"><img src="/2024/12/25/QCheckBox%E7%9A%84%E4%B8%89%E6%80%81%E5%A4%8D%E9%80%89%E6%A1%86%E5%92%8C%E5%8F%8D%E9%80%89/image-20241225170618346.png" class="" title="image-20241225170618346"><img src="/2024/12/25/QCheckBox%E7%9A%84%E4%B8%89%E6%80%81%E5%A4%8D%E9%80%89%E6%A1%86%E5%92%8C%E5%8F%8D%E9%80%89/image-20241225170629562.png" class="" title="image-20241225170629562">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;QCheckBox的三态复选框以及反选&quot;&gt;&lt;a href=&quot;#QCheckBox的三态复选框以及反选&quot; class=&quot;headerlink&quot; title=&quot;QCheckBox的三态复选框以及反选&quot;&gt;&lt;/a&gt;QCheckBox的三态复选框以及反选&lt;/h1&gt;&lt;p&gt;在使</summary>
      
    
    
    
    <category term="Qt" scheme="https://cpp-memory-leaks.github.io/categories/Qt/"/>
    
    
  </entry>
  
  <entry>
    <title>Qt高性能列表控件之QListView的使用及优点</title>
    <link href="https://cpp-memory-leaks.github.io/2024/12/17/Qt%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%97%E8%A1%A8%E6%8E%A7%E4%BB%B6%E4%B9%8BQListView%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E4%BC%98%E7%82%B9/"/>
    <id>https://cpp-memory-leaks.github.io/2024/12/17/Qt%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%97%E8%A1%A8%E6%8E%A7%E4%BB%B6%E4%B9%8BQListView%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E4%BC%98%E7%82%B9/</id>
    <published>2024-12-17T07:16:36.000Z</published>
    <updated>2025-08-22T15:43:53.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Qt高性能列表控件之QListView的使用及优点"><a href="#Qt高性能列表控件之QListView的使用及优点" class="headerlink" title="Qt高性能列表控件之QListView的使用及优点"></a>Qt高性能列表控件之QListView的使用及优点</h1><h2 id="1-高性能列表如何能实线高性能？"><a href="#1-高性能列表如何能实线高性能？" class="headerlink" title="1.高性能列表如何能实线高性能？"></a>1.高性能列表如何能实线高性能？</h2><p>高性能列表无非就解决两个痛点：</p><p><strong>数据存放在哪里</strong></p><p><strong>数据如何展示</strong></p><p>为何QListWidget就不能高性能呢？<code>QListWidget</code> 是一个方便的控件，它内部管理了一个项目列表，并提供了一些简单的接口来添加、删除和修改这些项目。但<strong>没有对数据存储和数据展示进行过多的优化</strong>，这种方式适合于简单的应用场景，其中列表的大小不会很大，因为每个项目都会被存储为一个 <code>QListWidgetItem</code> 对象。</p><p>在QListView体系里，<strong>QAbstractListModel</strong>解决的是“<strong>数据存哪</strong>”，解决的是第一个问题，而<strong>QAbstractItemDelegate</strong>解决的是数据“<strong>如何展示</strong>”，解决的是第二个问题。</p><h2 id="2-QListView和QAbstractListModel解决数据存哪"><a href="#2-QListView和QAbstractListModel解决数据存哪" class="headerlink" title="2.QListView和QAbstractListModel解决数据存哪"></a>2.QListView和QAbstractListModel解决数据存哪</h2><p>这里就不从QAbstractListModel派生写自定义的类了，直接使用Qt从QAbstractListModel派生的类QStandardItemModel</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化QListView</span></span><br><span class="line">QListView* photoListViewphotoListView = <span class="keyword">new</span> <span class="built_in">QListView</span>(<span class="keyword">this</span>);</span><br><span class="line">photoListView-&gt;<span class="built_in">setViewMode</span>(QListView::IconMode);</span><br><span class="line">photoListView-&gt;<span class="built_in">setResizeMode</span>(QListView::Adjust);</span><br><span class="line">photoListView-&gt;<span class="built_in">setIconSize</span>(<span class="built_in">QSize</span>(<span class="number">150</span>, <span class="number">150</span>));</span><br><span class="line">photoListView-&gt;<span class="built_in">setSpacing</span>(<span class="number">10</span>);</span><br><span class="line">photoListView-&gt;<span class="built_in">setSelectionMode</span>(QAbstractItemView::ExtendedSelection);</span><br><span class="line">photoListView-&gt;<span class="built_in">setUniformItemSizes</span>(<span class="literal">true</span>);</span><br><span class="line">photoListView-&gt;<span class="built_in">setVerticalScrollBarPolicy</span>(Qt::ScrollBarAlwaysOff);</span><br><span class="line">photoListView-&gt;<span class="built_in">setAttribute</span>(Qt::WA_Hover); <span class="comment">// 启用 Hover 事件</span></span><br><span class="line">photoListView-&gt;<span class="built_in">viewport</span>()-&gt;<span class="built_in">setAttribute</span>(Qt::WA_Hover);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化QStandardItemModel</span></span><br><span class="line">QStandardItemModel* m_photoModel = <span class="keyword">new</span> <span class="built_in">QStandardItemModel</span>(<span class="keyword">this</span>);</span><br><span class="line">ui-&gt;listView_Photos-&gt;<span class="built_in">setItemDelegate</span>(<span class="keyword">new</span> <span class="built_in">PhotoDelegate</span>(ui-&gt;listView_Photos));<span class="comment">//这是解决数据如何展示的</span></span><br><span class="line">ui-&gt;listView_Photos-&gt;<span class="built_in">model</span>()-&gt;<span class="built_in">removeRows</span>(<span class="number">0</span>, ui-&gt;listView_Photos-&gt;<span class="built_in">model</span>()-&gt;<span class="built_in">rowCount</span>(<span class="built_in">QModelIndex</span>()));</span><br><span class="line"><span class="comment">//模拟数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> photoInfo : m_vecPhoto) &#123;</span><br><span class="line">QStandardItem* item = <span class="keyword">new</span> QStandardItem;</span><br><span class="line">item-&gt;<span class="built_in">setEditable</span>(<span class="literal">false</span>);</span><br><span class="line">item-&gt;<span class="built_in">setData</span>(<span class="string">&quot;:/images/Demo.png&quot;</span>, Qt::UserRole);</span><br><span class="line"><span class="comment">//item-&gt;setData(photoInfo.duration,Qt::UserRole);</span></span><br><span class="line">item-&gt;<span class="built_in">setData</span>(photoInfo.fileName, Qt::UserRole + <span class="number">1</span>);</span><br><span class="line">item-&gt;<span class="built_in">setData</span>(photoInfo.width + <span class="string">&quot;x&quot;</span> + photoInfo.height, Qt::UserRole + <span class="number">2</span>);</span><br><span class="line">item-&gt;<span class="built_in">setData</span>(photoInfo.dateCreated, Qt::UserRole + <span class="number">3</span>);</span><br><span class="line">item-&gt;<span class="built_in">setData</span>(photoInfo.fileSize, Qt::UserRole + <span class="number">4</span>);</span><br><span class="line">item-&gt;<span class="built_in">setData</span>(photoInfo.dir, Qt::UserRole + <span class="number">5</span>);</span><br><span class="line"><span class="comment">//将数据存放到QStandardItemModel里面</span></span><br><span class="line">m_photoModel-&gt;<span class="built_in">appendRow</span>(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-QListView和QAbstractItemDelegate解决数据如何展示"><a href="#3-QListView和QAbstractItemDelegate解决数据如何展示" class="headerlink" title="3.QListView和QAbstractItemDelegate解决数据如何展示"></a>3.QListView和QAbstractItemDelegate解决数据如何展示</h2><p>QStyledItemDelegate是从QAbstractItemDelegate派生的类，<strong>QListView的View模型采用的是paint函数来呈现，paint的形式用起来更复杂，但性能天花板更高</strong>。这就是QListView的性能如此高的原因。</p><p>包括了IconMode以及ListMode的显示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhotoDelegate</span> : <span class="keyword">public</span> QStyledItemDelegate &#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ViewMode</span> &#123; ListMode, GridMode &#125;;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">PhotoDelegate</span><span class="params">(QListView* parent = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">: QStyledItemDelegate(parent) &#123;</span></span><br><span class="line">listView = parent;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paint</span><span class="params">(QPainter* painter, <span class="type">const</span> QStyleOptionViewItem&amp; option, <span class="type">const</span> QModelIndex&amp; index)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">painter-&gt;<span class="built_in">save</span>();</span><br><span class="line">painter-&gt;<span class="built_in">setRenderHint</span>(QPainter::Antialiasing);</span><br><span class="line">QListView::ViewMode viewMode = listView-&gt;<span class="built_in">viewMode</span>();</span><br><span class="line"><span class="function">QPixmap <span class="title">pixmap</span><span class="params">(index.data(Qt::UserRole).toString())</span></span>;</span><br><span class="line"><span class="comment">//图片信息</span></span><br><span class="line">QString fileName = index.<span class="built_in">data</span>(Qt::UserRole + <span class="number">1</span>).<span class="built_in">toString</span>();</span><br><span class="line">QString fileReso = index.<span class="built_in">data</span>(Qt::UserRole + <span class="number">2</span>).<span class="built_in">toString</span>();</span><br><span class="line">QString fileDate = index.<span class="built_in">data</span>(Qt::UserRole + <span class="number">3</span>).<span class="built_in">toString</span>();</span><br><span class="line">QString fileSize = index.<span class="built_in">data</span>(Qt::UserRole + <span class="number">4</span>).<span class="built_in">toString</span>();</span><br><span class="line"></span><br><span class="line">QRect iconRect = <span class="built_in">QRect</span>(option.rect.<span class="built_in">left</span>() + <span class="number">5</span>, option.rect.<span class="built_in">top</span>() + <span class="number">5</span>, <span class="number">50</span>, <span class="number">50</span>); <span class="comment">// 图标区域</span></span><br><span class="line">QRect nameRect = <span class="built_in">QRect</span>(iconRect.<span class="built_in">right</span>() - <span class="number">50</span>, option.rect.<span class="built_in">top</span>() + <span class="number">100</span>, option.rect.<span class="built_in">width</span>(), <span class="number">20</span>); <span class="comment">// 文件名</span></span><br><span class="line">QRect dateRect = <span class="built_in">QRect</span>(iconRect.<span class="built_in">right</span>() - <span class="number">50</span>, option.rect.<span class="built_in">top</span>() + <span class="number">120</span>, option.rect.<span class="built_in">width</span>(), <span class="number">20</span>); <span class="comment">// 日期</span></span><br><span class="line">QRect sizeRect = <span class="built_in">QRect</span>(iconRect.<span class="built_in">right</span>() - <span class="number">50</span>, option.rect.<span class="built_in">top</span>() + <span class="number">140</span>, option.rect.<span class="built_in">width</span>(), <span class="number">20</span>); <span class="comment">// 大小</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isSelected = option.state &amp; QStyle::State_Selected;</span><br><span class="line"><span class="type">bool</span> isHovered = option.state &amp; QStyle::State_MouseOver;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (viewMode == QListView::ViewMode::IconMode)</span><br><span class="line">&#123;</span><br><span class="line">QString filePath = index.<span class="built_in">data</span>(Qt::UserRole).<span class="built_in">value</span>&lt;QString&gt;();</span><br><span class="line">QRect imageRect = option.rect;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置图片为正方形，填充区域</span></span><br><span class="line"><span class="type">int</span> size = <span class="built_in">qMin</span>(imageRect.<span class="built_in">width</span>(), imageRect.<span class="built_in">height</span>());</span><br><span class="line"><span class="function">QRect <span class="title">squareRect</span><span class="params">(imageRect.topLeft(), QSize(size, size))</span></span>;</span><br><span class="line">squareRect.<span class="built_in">moveCenter</span>(imageRect.<span class="built_in">center</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抗锯齿</span></span><br><span class="line">painter-&gt;<span class="built_in">setRenderHint</span>(QPainter::Antialiasing);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 裁剪，绘图</span></span><br><span class="line">QPainterPath clipPath;</span><br><span class="line">clipPath.<span class="built_in">addRoundedRect</span>(squareRect, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">painter-&gt;<span class="built_in">setClipPath</span>(clipPath);</span><br><span class="line">painter-&gt;<span class="built_in">drawPixmap</span>(squareRect, pixmap, pixmap.<span class="built_in">rect</span>());</span><br><span class="line"><span class="keyword">if</span> (!isSelected)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 图标</span></span><br><span class="line"><span class="function">QPixmap <span class="title">checkIcon</span><span class="params">(<span class="string">&quot;:/images/unselect.png&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">QRect <span class="title">checkRect</span><span class="params">(squareRect.topRight() - QPoint(SELECT_ICON_SIZE + <span class="number">5</span>, <span class="number">-5</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">QSize(SELECT_ICON_SIZE, SELECT_ICON_SIZE))</span></span>;</span><br><span class="line">painter-&gt;<span class="built_in">drawPixmap</span>(checkRect, checkIcon);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制选中时的边框和勾选图标</span></span><br><span class="line"><span class="keyword">if</span> (isSelected) &#123;</span><br><span class="line"><span class="comment">// 蓝框</span></span><br><span class="line">painter-&gt;<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(<span class="built_in">QColor</span>(<span class="number">41</span>, <span class="number">95</span>, <span class="number">204</span>), <span class="number">3</span>));</span><br><span class="line">painter-&gt;<span class="built_in">drawRoundedRect</span>(squareRect, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图标</span></span><br><span class="line"><span class="function">QPixmap <span class="title">checkIcon</span><span class="params">(<span class="string">&quot;:/images/selected.png&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">QRect <span class="title">checkRect</span><span class="params">(squareRect.topRight() - QPoint(SELECT_ICON_SIZE + <span class="number">5</span>, <span class="number">-5</span>), QSize(SELECT_ICON_SIZE, SELECT_ICON_SIZE))</span></span>;</span><br><span class="line">painter-&gt;<span class="built_in">drawPixmap</span>(checkRect, checkIcon);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isHovered)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 蓝框</span></span><br><span class="line">painter-&gt;<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(<span class="built_in">QColor</span>(<span class="number">41</span>, <span class="number">95</span>, <span class="number">204</span>), <span class="number">3</span>));</span><br><span class="line">painter-&gt;<span class="built_in">drawRoundedRect</span>(squareRect, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">painter-&gt;<span class="built_in">setPen</span>(Qt::black);</span><br><span class="line">painter-&gt;<span class="built_in">drawText</span>(nameRect, Qt::AlignLeft | Qt::AlignVCenter, fileName);</span><br><span class="line">painter-&gt;<span class="built_in">drawText</span>(dateRect, Qt::AlignLeft | Qt::AlignVCenter, fileDate);</span><br><span class="line">painter-&gt;<span class="built_in">drawText</span>(sizeRect, Qt::AlignLeft | Qt::AlignVCenter, fileSize);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (viewMode == QListView::ViewMode::ListMode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//listView-&gt;setSpacing(5);</span></span><br><span class="line"><span class="keyword">if</span> (isHovered)</span><br><span class="line">&#123;</span><br><span class="line">QRect <span class="built_in">fileRect</span>(option.rect.<span class="built_in">topLeft</span>(), option.rect.<span class="built_in">size</span>());</span><br><span class="line"><span class="type">int</span> borderRadius = <span class="number">10</span>; <span class="comment">// 圆角的半径</span></span><br><span class="line"></span><br><span class="line">painter-&gt;<span class="built_in">setPen</span>(Qt::NoPen); <span class="comment">// 去掉边框</span></span><br><span class="line">painter-&gt;<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">235</span>, <span class="number">241</span>, <span class="number">255</span>)); <span class="comment">// 设置填充颜色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆角背景</span></span><br><span class="line">painter-&gt;<span class="built_in">drawRoundedRect</span>(fileRect, borderRadius, borderRadius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选中状态边框</span></span><br><span class="line"><span class="keyword">if</span> (isSelected) &#123;</span><br><span class="line"><span class="function">QRect <span class="title">fileRect</span><span class="params">(option.rect.topLeft(), option.rect.size())</span></span>;</span><br><span class="line"><span class="type">int</span> borderRadius = <span class="number">10</span>; <span class="comment">// 圆角的半径</span></span><br><span class="line">painter-&gt;<span class="built_in">setPen</span>(Qt::NoPen);</span><br><span class="line"><span class="comment">// 设置背景颜色</span></span><br><span class="line">painter-&gt;<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">235</span>, <span class="number">241</span>, <span class="number">255</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制带圆角的背景</span></span><br><span class="line">painter-&gt;<span class="built_in">drawRoundedRect</span>(fileRect, borderRadius, borderRadius);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制选中图标</span></span><br><span class="line">QRect checkIconRect = <span class="built_in">QRect</span>(option.rect.<span class="built_in">left</span>() + <span class="number">15</span>, option.rect.<span class="built_in">top</span>() + <span class="number">20</span>, SELECT_ICON_SIZE, SELECT_ICON_SIZE);</span><br><span class="line"><span class="function">QPixmap <span class="title">checkIcon</span><span class="params">(<span class="string">&quot;:/images/selected.png&quot;</span>)</span></span>;</span><br><span class="line">painter-&gt;<span class="built_in">drawPixmap</span>(checkIconRect, checkIcon);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">QRect checkIconRect = <span class="built_in">QRect</span>(option.rect.<span class="built_in">left</span>() + <span class="number">15</span>, option.rect.<span class="built_in">top</span>() + <span class="number">20</span>, SELECT_ICON_SIZE, SELECT_ICON_SIZE);</span><br><span class="line"><span class="function">QPixmap <span class="title">checkIcon</span><span class="params">(<span class="string">&quot;:/images/unselect.png&quot;</span>)</span></span>;</span><br><span class="line">painter-&gt;<span class="built_in">drawPixmap</span>(checkIconRect, checkIcon);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制区域</span></span><br><span class="line">QRect iconRect = <span class="built_in">QRect</span>(option.rect.<span class="built_in">left</span>() + <span class="number">45</span>, option.rect.<span class="built_in">top</span>() + <span class="number">7</span>, <span class="number">44</span>, <span class="number">44</span>); <span class="comment">// 图标区域</span></span><br><span class="line">QRect nameRect = <span class="built_in">QRect</span>(iconRect.<span class="built_in">right</span>() + <span class="number">40</span>, option.rect.<span class="built_in">top</span>() + <span class="number">20</span>, <span class="number">200</span>, <span class="number">20</span>); <span class="comment">// 文件名</span></span><br><span class="line">QRect resoRect = <span class="built_in">QRect</span>(nameRect.<span class="built_in">right</span>() + <span class="number">40</span>, option.rect.<span class="built_in">top</span>() + <span class="number">20</span>, <span class="number">100</span>, <span class="number">20</span>); <span class="comment">// 分辨率</span></span><br><span class="line">QRect dateRect = <span class="built_in">QRect</span>(resoRect.<span class="built_in">right</span>() + <span class="number">40</span>, option.rect.<span class="built_in">top</span>() + <span class="number">20</span>, <span class="number">200</span>, <span class="number">20</span>); <span class="comment">// 日期</span></span><br><span class="line">QRect sizeRect = <span class="built_in">QRect</span>(dateRect.<span class="built_in">right</span>() + <span class="number">40</span>, option.rect.<span class="built_in">top</span>() + <span class="number">20</span>, <span class="number">100</span>, <span class="number">20</span>); <span class="comment">// 大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制圆角图标</span></span><br><span class="line"><span class="type">int</span> borderRadius = <span class="number">10</span>;</span><br><span class="line">QPainterPath path;</span><br><span class="line">path.<span class="built_in">addRoundedRect</span>(iconRect, borderRadius, borderRadius);</span><br><span class="line"></span><br><span class="line">painter-&gt;<span class="built_in">save</span>();</span><br><span class="line"><span class="comment">// 抗锯齿</span></span><br><span class="line">painter-&gt;<span class="built_in">setRenderHint</span>(QPainter::Antialiasing, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 裁剪区域</span></span><br><span class="line">painter-&gt;<span class="built_in">setClipPath</span>(path);</span><br><span class="line">painter-&gt;<span class="built_in">drawPixmap</span>(iconRect, pixmap);</span><br><span class="line">painter-&gt;<span class="built_in">restore</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制文件名、日期和大小</span></span><br><span class="line">painter-&gt;<span class="built_in">setPen</span>(Qt::black);</span><br><span class="line">painter-&gt;<span class="built_in">drawText</span>(nameRect, Qt::AlignLeft | Qt::AlignVCenter, fileName);</span><br><span class="line">painter-&gt;<span class="built_in">setPen</span>(Qt::gray);</span><br><span class="line">painter-&gt;<span class="built_in">drawText</span>(resoRect, Qt::AlignLeft | Qt::AlignVCenter, fileReso);</span><br><span class="line">painter-&gt;<span class="built_in">drawText</span>(dateRect, Qt::AlignLeft | Qt::AlignVCenter, fileDate);</span><br><span class="line"></span><br><span class="line">painter-&gt;<span class="built_in">drawText</span>(sizeRect, Qt::AlignLeft | Qt::AlignVCenter, fileSize);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">painter-&gt;<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">QSize <span class="title">sizeHint</span><span class="params">(<span class="type">const</span> QStyleOptionViewItem&amp; option, <span class="type">const</span> QModelIndex&amp; index)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">Q_UNUSED</span>(index);</span><br><span class="line"><span class="comment">//固定大小</span></span><br><span class="line"><span class="keyword">if</span> (listView-&gt;<span class="built_in">viewMode</span>() == QListView::ViewMode::IconMode) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">QSize</span>(<span class="number">170</span>, <span class="number">170</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  <span class="built_in">QSize</span>(<span class="number">50</span>, <span class="number">60</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">editorEvent</span><span class="params">(QEvent* event, QAbstractItemModel* model, <span class="type">const</span> QStyleOptionViewItem&amp; option,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> QModelIndex&amp; index)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == QEvent::MouseButtonPress) &#123;</span><br><span class="line">QMouseEvent* mouseEvent = <span class="built_in">static_cast</span>&lt;QMouseEvent*&gt;(event);</span><br><span class="line">QListView::ViewMode viewMode = listView-&gt;<span class="built_in">viewMode</span>();</span><br><span class="line"></span><br><span class="line">QRect checkRect;</span><br><span class="line"><span class="keyword">if</span> (viewMode == QListView::ViewMode::IconMode) &#123;</span><br><span class="line">checkRect = <span class="built_in">QRect</span>(option.rect.<span class="built_in">topRight</span>() - <span class="built_in">QPoint</span>(SELECT_ICON_SIZE + <span class="number">5</span>, <span class="number">-5</span>),</span><br><span class="line"><span class="built_in">QSize</span>(SELECT_ICON_SIZE, SELECT_ICON_SIZE));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">checkRect = <span class="built_in">QRect</span>(option.rect.<span class="built_in">left</span>() + <span class="number">15</span>, option.rect.<span class="built_in">top</span>() + <span class="number">20</span>, SELECT_ICON_SIZE, SELECT_ICON_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (checkRect.<span class="built_in">contains</span>(mouseEvent-&gt;<span class="built_in">pos</span>())) &#123;</span><br><span class="line"><span class="type">bool</span> isSelected = index.<span class="built_in">data</span>(Qt::UserRole + <span class="number">15</span>).<span class="built_in">toBool</span>();</span><br><span class="line">model-&gt;<span class="built_in">setData</span>(index, !isSelected, Qt::UserRole + <span class="number">15</span>);</span><br><span class="line">QItemSelectionModel* selectionModel = listView-&gt;<span class="built_in">selectionModel</span>();</span><br><span class="line"><span class="keyword">if</span> (!isSelected) &#123;</span><br><span class="line">selectionModel-&gt;<span class="built_in">select</span>(index, QItemSelectionModel::Select);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">selectionModel-&gt;<span class="built_in">select</span>(index, QItemSelectionModel::Deselect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> QStyledItemDelegate::<span class="built_in">editorEvent</span>(event, model, option, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">QListView* listView;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-效果图"><a href="#4-效果图" class="headerlink" title="4.效果图"></a>4.效果图</h2><img src="/2024/12/17/Qt%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%97%E8%A1%A8%E6%8E%A7%E4%BB%B6%E4%B9%8BQListView%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E4%BC%98%E7%82%B9/image-20241225153907663.png" class="" title="image-20241225153907663"><img src="/2024/12/17/Qt%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%97%E8%A1%A8%E6%8E%A7%E4%BB%B6%E4%B9%8BQListView%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E4%BC%98%E7%82%B9/image-20241225153943414.png" class="" title="image-20241225153943414"><img src="/2024/12/17/Qt%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%97%E8%A1%A8%E6%8E%A7%E4%BB%B6%E4%B9%8BQListView%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E4%BC%98%E7%82%B9/image-20241225154833298.png" class="" title="image-20241225154833298"><img src="/2024/12/17/Qt%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%97%E8%A1%A8%E6%8E%A7%E4%BB%B6%E4%B9%8BQListView%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E4%BC%98%E7%82%B9/image-20241225154855709.png" class="" title="image-20241225154855709">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Qt高性能列表控件之QListView的使用及优点&quot;&gt;&lt;a href=&quot;#Qt高性能列表控件之QListView的使用及优点&quot; class=&quot;headerlink&quot; title=&quot;Qt高性能列表控件之QListView的使用及优点&quot;&gt;&lt;/a&gt;Qt高性能列表控件之Q</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>自定义摇杆</title>
    <link href="https://cpp-memory-leaks.github.io/2024/11/07/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%91%87%E6%9D%86/"/>
    <id>https://cpp-memory-leaks.github.io/2024/11/07/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%91%87%E6%9D%86/</id>
    <published>2024-11-07T02:20:12.000Z</published>
    <updated>2025-08-22T15:59:52.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义摇杆"><a href="#自定义摇杆" class="headerlink" title="自定义摇杆"></a>自定义摇杆</h1><p>今天做项目的时候，接到一个需求，需要做一个摇杆去控制物体的移动，功能还是挺复杂的</p><h2 id="1-功能："><a href="#1-功能：" class="headerlink" title="1.功能："></a>1.功能：</h2><ol><li>点击内圈发送一次对应的方向的信号</li><li>松开鼠标的时候如果在内圈就发送结束信号（第一第二点总结起来就是按下跑，松开停）</li><li>松开的时候如果鼠标位置在外圈，就不发送结束信号，一直跑</li><li>点击结束按钮或者内圈范围都会发送信号</li></ol><h3 id="直接上图"><a href="#直接上图" class="headerlink" title="直接上图"></a>直接上图</h3><p>原始状态：</p><img src="/2024/11/07/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%91%87%E6%9D%86/image-20241225143453202.png" class="" title="image-20241225143453202"><p>持续行走状态：</p><img src="/2024/11/07/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%91%87%E6%9D%86/image-20241225143636849.png" class="" title="image-20241225143636849"><h2 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h2><p>DirectionalControl.h头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DIRECTIONALCONTROL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIRECTIONALCONTROL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMouseEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCheckBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPointF&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectionalControl</span> : <span class="keyword">public</span> QWidget &#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">DirectionButton</span></span><br><span class="line">&#123;</span><br><span class="line">UpButton,</span><br><span class="line">DownButton,</span><br><span class="line">LeftButton,</span><br><span class="line">RightButton,</span><br><span class="line">StopButton</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">DirectionalControl</span><span class="params">(QWidget* parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">resetDragPntPos</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendDirectionChanged</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">directionChanged</span><span class="params">(<span class="type">double</span> angle)</span></span>; <span class="comment">// 信号：方向改变</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">startMove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stopMove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handleClick</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent* event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent* event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent* event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent* event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateDragPntDirection</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">keyReleaseEvent</span><span class="params">(QKeyEvent* event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">keyPressEvent</span><span class="params">(QKeyEvent* event)</span><span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> outerRadius = <span class="number">80</span>; <span class="comment">// 外圈半径</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> innerRadius = <span class="number">45</span>;  <span class="comment">// 内圈半径</span></span><br><span class="line">QPointF center;              <span class="comment">// 中心点</span></span><br><span class="line">QPointF dragPoint;           <span class="comment">// 当前拖动点</span></span><br><span class="line"><span class="type">bool</span> isDragging = <span class="literal">false</span>;     <span class="comment">// 是否正在拖动</span></span><br><span class="line"><span class="type">double</span> m_angle;</span><br><span class="line"><span class="type">bool</span> m_moving = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">QPushButton* stopButton;    <span class="comment">//按钮</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QTimer* m_timer;            <span class="comment">//定时器，控制angleChange()发送频率</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isInsideOuterCircle</span><span class="params">(<span class="type">const</span> QPointF&amp; point)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isInsideInnerCircle</span><span class="params">(<span class="type">const</span> QPointF&amp; point)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calculateDirection</span><span class="params">()</span></span>; <span class="comment">// 计算当前方向</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setupButtons</span><span class="params">()</span></span>;       <span class="comment">// 初始化按钮布局</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DIRECTIONALCONTROL_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DirectionalControl.cpp源代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DirectionalControl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;corecrt_math_defines.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtMath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line"></span><br><span class="line">DirectionalControl::<span class="built_in">DirectionalControl</span>(QWidget* parent)</span><br><span class="line">: <span class="built_in">QWidget</span>(parent), <span class="built_in">center</span>(<span class="number">100</span>, <span class="number">100</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setFixedSize</span>(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line"><span class="built_in">setWindowFlags</span>(Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint);</span><br><span class="line"><span class="built_in">setAttribute</span>(Qt::WA_TranslucentBackground);</span><br><span class="line"><span class="built_in">setFocusPolicy</span>(Qt::StrongFocus);</span><br><span class="line"><span class="comment">//this-&gt;setCursor(Qt::CursorShape::PointingHandCursor);</span></span><br><span class="line">m_timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">dragPoint.<span class="built_in">setX</span>(center.<span class="built_in">x</span>());</span><br><span class="line">dragPoint.<span class="built_in">setY</span>(center.<span class="built_in">y</span>());</span><br><span class="line"></span><br><span class="line">QSize size = <span class="keyword">this</span>-&gt;<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">setupButtons</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;:/qss/resources/qss/DirectionControl.qss&quot;</span>)</span></span>;</span><br><span class="line">QByteArray style;</span><br><span class="line"><span class="keyword">if</span> (file.<span class="built_in">open</span>(QIODevice::ReadOnly))</span><br><span class="line">&#123;</span><br><span class="line">style += file.<span class="built_in">readAll</span>();</span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setStyleSheet</span>(style);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DirectionalControl::resetDragPntPos</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dragPoint.<span class="built_in">setX</span>(center.<span class="built_in">x</span>());</span><br><span class="line">dragPoint.<span class="built_in">setY</span>(center.<span class="built_in">y</span>());</span><br><span class="line"><span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DirectionalControl::sendDirectionChanged</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">emit <span class="title">directionChanged</span><span class="params">(m_angle)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DirectionalControl::setupButtons</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 中心按钮：开始/暂停</span></span><br><span class="line">stopButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">stopButton-&gt;<span class="built_in">move</span>(<span class="number">90</span>, <span class="number">90</span>);</span><br><span class="line">stopButton-&gt;<span class="built_in">setObjectName</span>(<span class="string">&quot;stopButton&quot;</span>);</span><br><span class="line"><span class="built_in">connect</span>(stopButton, &amp;QPushButton::clicked, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">emit <span class="built_in">stopMove</span>();</span><br><span class="line">m_moving = <span class="literal">false</span>;</span><br><span class="line">dragPoint.<span class="built_in">setX</span>(center.<span class="built_in">x</span>());</span><br><span class="line">dragPoint.<span class="built_in">setY</span>(center.<span class="built_in">y</span>());</span><br><span class="line">stopButton-&gt;<span class="built_in">hide</span>();</span><br><span class="line"><span class="built_in">update</span>();</span><br><span class="line">&#125;);</span><br><span class="line">stopButton-&gt;<span class="built_in">hide</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DirectionalControl::paintEvent</span><span class="params">(QPaintEvent* event)</span> </span>&#123;</span><br><span class="line"><span class="built_in">Q_UNUSED</span>(event);</span><br><span class="line"></span><br><span class="line"><span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"><span class="comment">// 抗锯齿</span></span><br><span class="line">painter.<span class="built_in">setRenderHint</span>(QPainter::Antialiasing, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无边框,直接刷色</span></span><br><span class="line">painter.<span class="built_in">setPen</span>(Qt::NoPen);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> QColor <span class="title">outerCircleColor</span><span class="params">(<span class="number">200</span>, <span class="number">220</span>, <span class="number">255</span>, <span class="number">200</span>)</span></span>; <span class="comment">// 外圈颜色</span></span><br><span class="line"><span class="function"><span class="type">const</span> QColor <span class="title">innerCircleColor</span><span class="params">(<span class="number">249</span>, <span class="number">249</span>, <span class="number">249</span>, <span class="number">150</span>)</span></span>; <span class="comment">// 内圈颜色</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> centerDotRadius = <span class="number">3</span>; <span class="comment">// 中心点半径</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dragRadius = <span class="number">15</span>;     <span class="comment">// 拖动点半径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制外圈</span></span><br><span class="line">painter.<span class="built_in">setBrush</span>(outerCircleColor);</span><br><span class="line">painter.<span class="built_in">drawEllipse</span>(center, outerRadius, outerRadius);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制内内圈</span></span><br><span class="line">painter.<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(<span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">150</span>), <span class="number">3</span>));<span class="comment">//外边框</span></span><br><span class="line">painter.<span class="built_in">setBrush</span>(innerCircleColor);</span><br><span class="line">painter.<span class="built_in">drawEllipse</span>(center, dragRadius, dragRadius);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制内圈</span></span><br><span class="line">painter.<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(<span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">150</span>), <span class="number">3</span>));<span class="comment">//外边框</span></span><br><span class="line">painter.<span class="built_in">setBrush</span>(innerCircleColor);</span><br><span class="line">painter.<span class="built_in">drawEllipse</span>(center, innerRadius, innerRadius);</span><br><span class="line"><span class="comment">// 确保 dragPoint 不进入内圈且不超出外圈</span></span><br><span class="line"><span class="type">double</span> dx = dragPoint.<span class="built_in">x</span>() - center.<span class="built_in">x</span>();</span><br><span class="line"><span class="type">double</span> dy = dragPoint.<span class="built_in">y</span>() - center.<span class="built_in">y</span>();</span><br><span class="line"><span class="type">double</span> distance = std::<span class="built_in">sqrt</span>(dx * dx + dy * dy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 dragPoint 超出了外圈，修正到外圈边缘</span></span><br><span class="line"><span class="keyword">if</span> (distance &gt; outerRadius) &#123;</span><br><span class="line"><span class="type">double</span> scale = outerRadius / distance;</span><br><span class="line">dragPoint.<span class="built_in">setX</span>(center.<span class="built_in">x</span>() + dx * scale);</span><br><span class="line">dragPoint.<span class="built_in">setY</span>(center.<span class="built_in">y</span>() + dy * scale);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">painter.<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(<span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)));</span><br><span class="line"><span class="function">QFont <span class="title">font</span><span class="params">(<span class="string">&quot;Arial&quot;</span>, <span class="number">20</span>, QFont::Bold)</span></span>;</span><br><span class="line"><span class="comment">// 设置画笔的字体</span></span><br><span class="line">painter.<span class="built_in">setFont</span>(font);</span><br><span class="line"></span><br><span class="line">painter.<span class="built_in">drawText</span>(<span class="number">87</span>, <span class="number">50</span>, <span class="string">&quot;W&quot;</span>);</span><br><span class="line">painter.<span class="built_in">drawText</span>(<span class="number">28</span>, <span class="number">110</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">painter.<span class="built_in">drawText</span>(<span class="number">90</span>, <span class="number">172</span>, <span class="string">&quot;S&quot;</span>);</span><br><span class="line">painter.<span class="built_in">drawText</span>(<span class="number">152</span>, <span class="number">110</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line"><span class="comment">// 设置画刷颜色为白色并绘制拖动点</span></span><br><span class="line">painter.<span class="built_in">setPen</span>(Qt::NoPen);</span><br><span class="line">painter.<span class="built_in">setBrush</span>(Qt::white);</span><br><span class="line">painter.<span class="built_in">drawEllipse</span>(dragPoint, dragRadius, dragRadius);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在拖动点的中心绘制中心点</span></span><br><span class="line">painter.<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(<span class="built_in">QColor</span>(<span class="number">0</span>, <span class="number">117</span>, <span class="number">255</span>), <span class="number">5</span>));</span><br><span class="line">painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">0</span>, <span class="number">117</span>, <span class="number">255</span>));</span><br><span class="line">painter.<span class="built_in">drawEllipse</span>(dragPoint, centerDotRadius, centerDotRadius);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DirectionalControl::mousePressEvent</span><span class="params">(QMouseEvent* event)</span> </span>&#123;</span><br><span class="line">QPointF pos = event-&gt;<span class="built_in">pos</span>();</span><br><span class="line"><span class="comment">//if (isInsideOuterCircle(pos) &amp;&amp; isInsideInnerCircle(pos)) &#123;</span></span><br><span class="line">isDragging = <span class="literal">true</span>;</span><br><span class="line">dragPoint = pos;</span><br><span class="line"><span class="function">emit <span class="title">startMove</span><span class="params">()</span></span>;</span><br><span class="line">m_moving = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">calculateDirection</span>();</span><br><span class="line"><span class="built_in">sendDirectionChanged</span>();</span><br><span class="line"><span class="comment">// 限制拖动点到外圈的范围</span></span><br><span class="line"><span class="type">double</span> dx = pos.<span class="built_in">x</span>() - center.<span class="built_in">x</span>();</span><br><span class="line"><span class="type">double</span> dy = pos.<span class="built_in">y</span>() - center.<span class="built_in">y</span>();</span><br><span class="line"><span class="type">double</span> distance = std::<span class="built_in">sqrt</span>(dx * dx + dy * dy);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (distance &lt; innerRadius) &#123;</span><br><span class="line"><span class="function">emit <span class="title">handleClick</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">m_timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">connect</span>(m_timer, &amp;QTimer::timeout, <span class="keyword">this</span>, &amp;DirectionalControl::sendDirectionChanged, Qt::<span class="built_in">ConnectionType</span>(Qt::AutoConnection | Qt::UniqueConnection));</span><br><span class="line"><span class="built_in">update</span>();</span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DirectionalControl::mouseMoveEvent</span><span class="params">(QMouseEvent* event)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isDragging) &#123;</span><br><span class="line">QPointF pos = event-&gt;<span class="built_in">pos</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限制拖动点到外圈的范围</span></span><br><span class="line"><span class="type">double</span> dx = pos.<span class="built_in">x</span>() - center.<span class="built_in">x</span>();</span><br><span class="line"><span class="type">double</span> dy = pos.<span class="built_in">y</span>() - center.<span class="built_in">y</span>();</span><br><span class="line"><span class="type">double</span> distance = std::<span class="built_in">sqrt</span>(dx * dx + dy * dy);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (distance &gt; outerRadius) &#123;</span><br><span class="line"><span class="comment">// 将拖动点限制在外圈的边界</span></span><br><span class="line"><span class="type">double</span> scale = outerRadius / distance;</span><br><span class="line">dragPoint.<span class="built_in">setX</span>(center.<span class="built_in">x</span>() + dx * scale);</span><br><span class="line">dragPoint.<span class="built_in">setY</span>(center.<span class="built_in">y</span>() + dy * scale);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*else if (distance &gt; innerRadius)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">dragPoint.setX(center.x());</span></span><br><span class="line"><span class="comment">dragPoint.setY(center.y());</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">dragPoint = pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">calculateDirection</span>();</span><br><span class="line"><span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DirectionalControl::mouseReleaseEvent</span><span class="params">(QMouseEvent* event)</span> </span>&#123;</span><br><span class="line"><span class="built_in">Q_UNUSED</span>(event);</span><br><span class="line">isDragging = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// TODO 点击内圈跑一步，点击外圈持续跑</span></span><br><span class="line"><span class="comment">// 释放时恢复到中心</span></span><br><span class="line"><span class="comment">// dragPoint = center;</span></span><br><span class="line"></span><br><span class="line">QPointF pos = event-&gt;<span class="built_in">pos</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限制拖动点到外圈的范围</span></span><br><span class="line"><span class="type">double</span> dx = pos.<span class="built_in">x</span>() - center.<span class="built_in">x</span>();</span><br><span class="line"><span class="type">double</span> dy = pos.<span class="built_in">y</span>() - center.<span class="built_in">y</span>();</span><br><span class="line"><span class="type">double</span> distance = std::<span class="built_in">sqrt</span>(dx * dx + dy * dy);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (distance &gt; innerRadius) &#123;</span><br><span class="line"><span class="comment">// 将拖动点限制在外圈的边界</span></span><br><span class="line"><span class="type">double</span> distanceFromCenter = (outerRadius + innerRadius) / <span class="number">2</span>;</span><br><span class="line">dragPoint.<span class="built_in">setX</span>(center.<span class="built_in">x</span>() +</span><br><span class="line">distanceFromCenter * std::<span class="built_in">cos</span>(<span class="built_in">qDegreesToRadians</span>(m_angle)));</span><br><span class="line">dragPoint.<span class="built_in">setY</span>(center.<span class="built_in">y</span>() -</span><br><span class="line">distanceFromCenter * std::<span class="built_in">sin</span>(<span class="built_in">qDegreesToRadians</span>(m_angle)));</span><br><span class="line">stopButton-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (distance &lt; innerRadius)<span class="comment">//拖动点释放前在内圈，就停止</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">calculateDirection</span>();</span><br><span class="line">dragPoint.<span class="built_in">setX</span>(center.<span class="built_in">x</span>());</span><br><span class="line">dragPoint.<span class="built_in">setY</span>(center.<span class="built_in">y</span>());</span><br><span class="line">stopButton-&gt;<span class="built_in">hide</span>();</span><br><span class="line"><span class="function">emit <span class="title">stopMove</span><span class="params">()</span></span>;</span><br><span class="line">m_moving = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*else &#123;</span></span><br><span class="line"><span class="comment">dragPoint = pos;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">/*double distanceFromCenter = (outerRadius + innerRadius) / 2;</span></span><br><span class="line"><span class="comment">dragPoint.setX(center.x() +</span></span><br><span class="line"><span class="comment">distanceFromCenter * std::cos(qDegreesToRadians(m_angle)));</span></span><br><span class="line"><span class="comment">dragPoint.setY(center.y() -</span></span><br><span class="line"><span class="comment">distanceFromCenter * std::sin(qDegreesToRadians(m_angle)));*/</span></span><br><span class="line">m_timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line"><span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DirectionalControl::updateDragPntDirection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> distanceFromCenter = (outerRadius + innerRadius) / <span class="number">2</span>;</span><br><span class="line">dragPoint.<span class="built_in">setX</span>(center.<span class="built_in">x</span>() + distanceFromCenter * std::<span class="built_in">cos</span>(<span class="built_in">qDegreesToRadians</span>(m_angle)));</span><br><span class="line">dragPoint.<span class="built_in">setY</span>(center.<span class="built_in">y</span>() - distanceFromCenter * std::<span class="built_in">sin</span>(<span class="built_in">qDegreesToRadians</span>(m_angle)));</span><br><span class="line"><span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DirectionalControl::keyPressEvent</span><span class="params">(QKeyEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QWidget::<span class="built_in">keyPressEvent</span>(event);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 防止重复触发按键，这是官方文档的描述</span></span><br><span class="line"><span class="comment">* bool QKeyEvent::isAutoRepeat() const</span></span><br><span class="line"><span class="comment">* Returns true if this event comes from an auto-repeating key; </span></span><br><span class="line"><span class="comment">* returns false if it comes from an initial key press.</span></span><br><span class="line"><span class="comment">* Note that if the event is a multiple-key compressed event that is partly due to auto-repeat,</span></span><br><span class="line"><span class="comment">* this function could return either true or false indeterminately.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (event-&gt;<span class="built_in">isAutoRepeat</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (event-&gt;<span class="built_in">key</span>()) &#123;</span><br><span class="line"><span class="keyword">case</span> Qt::Key_W:</span><br><span class="line">m_angle = <span class="number">90</span>;</span><br><span class="line"><span class="built_in">sendDirectionChanged</span>();</span><br><span class="line"><span class="function">emit <span class="title">handleClick</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">emit <span class="title">startMove</span><span class="params">()</span></span>;</span><br><span class="line">stopButton-&gt;<span class="built_in">show</span>();</span><br><span class="line">m_moving = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">updateDragPntDirection</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Qt::Key_A:</span><br><span class="line">m_angle = <span class="number">180</span>;</span><br><span class="line"><span class="built_in">sendDirectionChanged</span>();</span><br><span class="line"><span class="function">emit <span class="title">handleClick</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">emit <span class="title">startMove</span><span class="params">()</span></span>;</span><br><span class="line">stopButton-&gt;<span class="built_in">show</span>();</span><br><span class="line">m_moving = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">updateDragPntDirection</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Qt::Key_S:</span><br><span class="line">m_angle = <span class="number">270</span>;</span><br><span class="line"><span class="built_in">sendDirectionChanged</span>();</span><br><span class="line"><span class="function">emit <span class="title">handleClick</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">emit <span class="title">startMove</span><span class="params">()</span></span>;</span><br><span class="line">stopButton-&gt;<span class="built_in">show</span>();</span><br><span class="line">m_moving = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">updateDragPntDirection</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Qt::Key_D:</span><br><span class="line">m_angle = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">sendDirectionChanged</span>();</span><br><span class="line"><span class="function">emit <span class="title">handleClick</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">emit <span class="title">startMove</span><span class="params">()</span></span>;</span><br><span class="line">stopButton-&gt;<span class="built_in">show</span>();</span><br><span class="line">m_moving = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">updateDragPntDirection</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 标记事件为已处理</span></span><br><span class="line">event-&gt;<span class="built_in">accept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DirectionalControl::keyReleaseEvent</span><span class="params">(QKeyEvent* event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QWidget::<span class="built_in">keyReleaseEvent</span>(event);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只处理非自动重复的松键事件</span></span><br><span class="line"><span class="keyword">if</span> (event-&gt;<span class="built_in">isAutoRepeat</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (event-&gt;<span class="built_in">key</span>()) &#123;</span><br><span class="line"><span class="keyword">case</span> Qt::Key_W:</span><br><span class="line"><span class="function">emit <span class="title">stopMove</span><span class="params">()</span></span>;</span><br><span class="line">m_moving = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">resetDragPntPos</span>();</span><br><span class="line">stopButton-&gt;<span class="built_in">hide</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Qt::Key_A:</span><br><span class="line"><span class="function">emit <span class="title">stopMove</span><span class="params">()</span></span>;</span><br><span class="line">m_moving = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">resetDragPntPos</span>();</span><br><span class="line">stopButton-&gt;<span class="built_in">hide</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Qt::Key_S:</span><br><span class="line"><span class="function">emit <span class="title">stopMove</span><span class="params">()</span></span>;</span><br><span class="line">m_moving = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">resetDragPntPos</span>();</span><br><span class="line">stopButton-&gt;<span class="built_in">hide</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Qt::Key_D:</span><br><span class="line"><span class="function">emit <span class="title">stopMove</span><span class="params">()</span></span>;</span><br><span class="line">m_moving = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">resetDragPntPos</span>();</span><br><span class="line">stopButton-&gt;<span class="built_in">hide</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Qt::Key_Space:</span><br><span class="line"><span class="function">emit <span class="title">stopMove</span><span class="params">()</span></span>;</span><br><span class="line">m_moving = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">resetDragPntPos</span>();</span><br><span class="line">stopButton-&gt;<span class="built_in">hide</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记事件为已处理</span></span><br><span class="line">event-&gt;<span class="built_in">accept</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DirectionalControl::isInsideOuterCircle</span><span class="params">(<span class="type">const</span> QPointF&amp; point)</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> dx = point.<span class="built_in">x</span>() - center.<span class="built_in">x</span>();</span><br><span class="line"><span class="type">double</span> dy = point.<span class="built_in">y</span>() - center.<span class="built_in">y</span>();</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">sqrt</span>(dx * dx + dy * dy) &lt;= outerRadius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DirectionalControl::isInsideInnerCircle</span><span class="params">(<span class="type">const</span> QPointF&amp; point)</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> dx = point.<span class="built_in">x</span>() - center.<span class="built_in">x</span>();</span><br><span class="line"><span class="type">double</span> dy = point.<span class="built_in">y</span>() - center.<span class="built_in">y</span>();</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">sqrt</span>(dx * dx + dy * dy) &lt;= innerRadius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DirectionalControl::calculateDirection</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> dx = dragPoint.<span class="built_in">x</span>() - center.<span class="built_in">x</span>();</span><br><span class="line"><span class="comment">// Y 轴正方向向下，所以取反</span></span><br><span class="line"><span class="type">double</span> dy = center.<span class="built_in">y</span>() - dragPoint.<span class="built_in">y</span>();</span><br><span class="line"><span class="type">double</span> angle = std::<span class="built_in">atan2</span>(dy, dx) * (<span class="number">180.0</span> / M_PI);</span><br><span class="line"><span class="comment">// 保证角度为 0-360 度</span></span><br><span class="line"><span class="keyword">if</span> (angle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">angle += <span class="number">360.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_angle = angle;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;自定义摇杆&quot;&gt;&lt;a href=&quot;#自定义摇杆&quot; class=&quot;headerlink&quot; title=&quot;自定义摇杆&quot;&gt;&lt;/a&gt;自定义摇杆&lt;/h1&gt;&lt;p&gt;今天做项目的时候，接到一个需求，需要做一个摇杆去控制物体的移动，功能还是挺复杂的&lt;/p&gt;
&lt;h2 id=&quot;1-功能：</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++代码规范</title>
    <link href="https://cpp-memory-leaks.github.io/2024/08/07/Cpp%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://cpp-memory-leaks.github.io/2024/08/07/Cpp%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</id>
    <published>2024-08-07T10:57:16.000Z</published>
    <updated>2025-08-22T16:00:23.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.  概述"></a>1.  <strong>概述</strong></h2><p>命名，是计算机史上最难的问题之一，有很多书本都有专门的章节讨论命名规范的问题，鄙人写的总结，是作为一名刚毕业的黄毛小子从刚工作开始积累的，可能没有那些名著写的那么详细，但是贵在真实，我觉得还是有点使用价值的。</p><p>我觉得给代码命名有三要：</p><ol><li>要有区分度</li><li>要有辨识度</li><li>要够详细（最少的字表达最清楚的意思）</li></ol><p><strong>不要造字</strong>，你不是仓颉，英语里面有约定俗成的名称缩写，如info-&gt;infomation。</p><p><strong>不要为了规范而规范。</strong></p><p>目的：<strong>不影响理解、不产生歧义、不增加维护成本足以</strong></p><p>旨在<strong>提高代码的可读性、可维护性</strong>，特此制定本规范。参考《Googe C++ Stye Guide》以及《Effective C++》等规范基础上，结合项目开发经验，汇总整理成本规范。</p><h2 id="2-头文件"><a href="#2-头文件" class="headerlink" title="2.  头文件"></a>2.  <strong>头文件</strong></h2><h3 id="2-1-头文件保护"><a href="#2-1-头文件保护" class="headerlink" title="2.1   头文件保护"></a>2.1   <strong>头文件保护</strong></h3><p>所有头文件都应该使用**#define**防止头文件被重复包含，命名格式为<FieName>_H，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><h3 id="2-2-前置声明"><a href="#2-2-前置声明" class="headerlink" title="2.2  前置声明"></a>2.2  <strong>前置声明</strong></h3><p>“前置声明”是类、函数和模板的纯粹声明，没伴随着其定义。</p><p>在头文件中进行前置声明，可以减少**#incude**的数量，避免多重包含，减少头文件展开的次数，有效的提高编译效率。对于库工程使用前置声明，可以减少内部类的导出。</p><p><strong>注意：前置类型的类是不完全类型，只能定义指向该类型的指针或引用，或者声明(但不能定义)以不完全类型作为参数或者返回类型的函数。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incude <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="comment">// #incude &lt;QJsonVaue&gt;</span></span><br><span class="line"><span class="comment">// #incude &lt;QJsonObject&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用前置声明形式代替</span></span><br><span class="line">cass QJsonVaue;</span><br><span class="line">cass QJsonObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 库工程不希望导出的内部类才使用前置声明</span></span><br><span class="line">cass IDictionaryPrivate;</span><br><span class="line">cass SVSEMSHARE_EXPORT IDictionary : pubic QObject</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"></span><br><span class="line">pubic:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> QString&amp; key, <span class="type">const</span> QJsonVaue&amp; vaue)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> QJsonObject&amp; vaus)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-3-内联函数"><a href="#2-3-内联函数" class="headerlink" title="2.3  内联函数"></a>2.3  <strong>内联函数</strong></h3><p>当函数被声明为内联函数之后，编译器会将其内联展开，而不是按通常的函数调用机制进行调用。</p><p><strong>只要当函数只有10行甚至更少时才将其定义为内联函数</strong>，只有内联的函数体较小，内联该函数才可以令目标代码更加高效。对于存取函数以及其他函数比较短，性能关键的函数，鼓励使用内联。</p><p><strong>注意：不要内联包含循环或switch语句的函数，可能导致增加代码大小。</strong></p><h3 id="2-4-incude的路径及次序"><a href="#2-4-incude的路径及次序" class="headerlink" title="2.4  #incude的路径及次序"></a>2.4  <strong>#incude的路径及次序</strong></h3><p>项目内的头文件按照项目源代码目录树结构排列，头文件包含顺序<strong>项目内头文件</strong>、<strong>其他库头文件</strong>、<strong>Qt库</strong>、<strong>C++库</strong>、C库，通过空行分隔相关头文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 项目内头文件</span></span><br><span class="line"><span class="meta">#incude <span class="string">&quot;Base/NameSpace.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他库头文件</span></span><br><span class="line"><span class="meta">#incude <span class="string">&quot;foo/bar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Qt库头文件</span></span><br><span class="line"><span class="meta">#incude <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++库头文件</span></span><br><span class="line"><span class="meta">#incude <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C库头文件</span></span><br><span class="line"><span class="meta">#incude <span class="string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="3-作用域"><a href="#3-作用域" class="headerlink" title="3. 作用域"></a>3. <strong>作用域</strong></h2><h3 id="3-1-命名空间"><a href="#3-1-命名空间" class="headerlink" title="3.1  命名空间"></a>3.1  <strong>命名空间</strong></h3><p>命名空间将全局作用域细分为独立的、具名的作用域，可以有效防止全局作用域的命名冲突。举例来说，两个不同项目的全局作用域都有一个类Foo，这样在编译或运行时会造成冲突。如果每个项目将代码置于不同命名空间中，project1::Foo和project2::Foo作为不同符号自然不会冲突。命名方式参考<a href="#_%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%91%BD%E5%90%8D">7.7 命名空间命名</a>，使用方式如下：</p><p>全局定义宏包括了以下，所有项目内开发头文件均包含以下内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NameSpace.h</span></span><br><span class="line"><span class="comment">/** 命名空间定义</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIQTEK_NAMESPACE ciqtek</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 命名空间开始</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEGIN_NAMESPACE_CIQTEK namespace CIQTEK_NAMESPACE &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 命名空间结束</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> END_NAMESPACE_CIQTEK &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 命名空间修饰符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIQTEK_QUAIFIER     ::CIQTEK_NAMESPACE::</span></span><br></pre></td></tr></table></figure><p>根据全局定义宏文件，头文件以及源文件遵循以下规则编写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h文件</span></span><br><span class="line">BEGIN_NAMESPACE_CIQTEK</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有声明(前置声明除外)都置于命名空间中</span></span><br><span class="line">cass MyCass</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">END_NAMESPACE_CIQTEK</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp文件</span></span><br><span class="line">BEGIN_NAMESPACE_CIQTEK</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义都至于命名空间中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyCass::Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BEGIN_NAMESPACE_CIQTEK</span><br></pre></td></tr></table></figure><p><strong>结论：</strong></p><p>不建议使用using指示引入整个命名空间的标识符号，在.cpp和.h文件的函数、方法或者类中，可以使用using声明；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在.cpp文件中</span></span><br><span class="line"><span class="comment">// .h文件的话,必须在函数,方法或类的内部使用</span></span><br><span class="line"><span class="keyword">using</span> ::foo::bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不建议 -- 污染命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> foo;</span><br></pre></td></tr></table></figure><p><strong>不要在头文件中使用命名空间别名</strong>，因为头文件的别名对包含了该头文件的所有人可见，所以递归包含到其他头文件里；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用别名缩短常用的命名空间——可以在.cpp文件</span></span><br><span class="line"><span class="comment">// .h文件的话,必须在函数,方法或类的内部使用,否则污染命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> fbz = ::foo::bar::baz;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在.h文件里</span></span><br><span class="line"><span class="keyword">namespace</span> ibrarian &#123;</span><br><span class="line"><span class="comment">// 以下别名在所有包含了该头文件的文件中生效</span></span><br><span class="line"><span class="keyword">namespace</span> pd_s = ::pipeine_diagnostics::sidetabe;</span><br><span class="line"></span><br><span class="line"><span class="function">inine <span class="type">void</span> <span class="title">my_inine_function</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 在函数(方法)使用命名别名,限制在函数中</span></span><br><span class="line"><span class="keyword">namespace</span> fbz = ::foo::bar::baz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace ibrarian</span></span><br></pre></td></tr></table></figure><h3 id="3-2-非成员函数、静态成员函数和全局函数"><a href="#3-2-非成员函数、静态成员函数和全局函数" class="headerlink" title="3.2  非成员函数、静态成员函数和全局函数"></a>3.2  <strong>非成员函数、静态成员函数和全局函数</strong></h3><p>使用静态成员函数或命名空间内的非成员函数，尽量不要用裸的全局函数。将一些列函数直接至于命名空间，不要用类的静态函数模拟出命名空间的效果，类的静态方法应该和类的实例或数据紧密相关。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="keyword">namespace</span> foo_bar &#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;  <span class="comment">// namespace foo_bar</span></span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐,类的内部并没有静态变量,类的实体也没具体功能</span></span><br><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line">cass FooBar </span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></table></figure><h3 id="3-3-局部变量"><a href="#3-3-局部变量" class="headerlink" title="3.3  局部变量"></a>3.3  <strong>局部变量</strong></h3><p>尽量将函数变量<strong>尽可能置于最小作用域内，并在变量声明时进行初始化</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line">i = <span class="built_in">f</span>(); <span class="comment">// 不推荐——初始化和声明分离</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> j = <span class="built_in">g</span>(); <span class="comment">// 推荐——初始化时声明</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">// 不推荐——用花括号初始化更好</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 推荐——v 一开始就初始化</span></span><br></pre></td></tr></table></figure><p>属于whie和for语句的变量尽量在这些语句中正常地声明，这样变量的作用域就被限制在这些语句中了，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在作用域内声明</span></span><br><span class="line"><span class="built_in">whie</span> (<span class="type">const</span> <span class="type">char</span>* p = <span class="built_in">strchr</span>(str, <span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">str = p + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果变量是一个对象,则不适用该方法</span></span><br><span class="line"><span class="comment">// 低效的实现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    Foo f;                  <span class="comment">// 构造函数和析构函数分别调用 1000000 次!</span></span><br><span class="line">    f.<span class="built_in">DoSomething</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应该作用域外声明</span></span><br><span class="line">Foo f;                      <span class="comment">// 构造函数和析构函数只调用 1 次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    f.<span class="built_in">DoSomething</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-类"><a href="#4-类" class="headerlink" title="4. 类"></a>4. <strong>类</strong></h2><h3 id="4-1-构造函数的职责"><a href="#4-1-构造函数的职责" class="headerlink" title="4.1  构造函数的职责"></a>4.1  <strong>构造函数的职责</strong></h3><p><strong>构造函数不得调用虚函数</strong>，如果在构造函数内调用了自身的虚函数，这类调用是不会重定向到子类的虚函数实现的，即当前没有子类化实现，存在隐患。<strong>构造函数不能报告一个非致命错误</strong>，即<strong>构造函数必须成功</strong>，不然会获得一个初始化失败的对象，有可能进入不正常的状态。</p><p>如果对象需要进行初始化，考虑使用明确的<strong>init()<strong>方法或使用</strong>工厂模式</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">cass Foo </span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="function">boo <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init方法形式, 需要在类的注释里说明用法</span></span><br><span class="line">&#123;</span><br><span class="line">    Foo *foo = <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line">    <span class="keyword">if</span> (!foo-&gt;<span class="built_in">init</span>()) &#123;</span><br><span class="line">        deete foo;</span><br><span class="line">        foo = nuptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐,容易误用 — 工厂方法</span></span><br><span class="line">cass Foo </span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="function"><span class="type">static</span> Foo *<span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Foo *foo = <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line">        <span class="keyword">if</span> (!foo-&gt;<span class="built_in">init</span>()) &#123;</span><br><span class="line">            deete foo;</span><br><span class="line">            foo = nuptr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> foo;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    Foo *foo = Foo::<span class="built_in">create</span>();</span><br><span class="line">    <span class="keyword">if</span>(nuptr != foo) &#123; <span class="comment">// 功能逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-初始化"><a href="#4-2-初始化" class="headerlink" title="4.2  初始化"></a>4.2  <strong>初始化</strong></h3><p>如果类中定义了成员变量，则必须在类中为每个类提供初始化函数或定义一个构造函数。若未声明构造函数，则编译器会生成一个默认的构造函数，这有可能导致某些成员未被初始化或初始化未不恰当的值。</p><p>所以，<strong>确保构造函数将对象的每一个成员变量进行了初始化，且初始化顺序和声明顺序保持一致。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">cass PhoneNumber &#123; ... &#125;;</span><br><span class="line">cass ABEntry </span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="built_in">ABEntry</span>(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> std::string &amp;address,</span><br><span class="line">            <span class="type">const</span> std::ist&lt;PhoneNumber&gt;&amp; phones);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;</span><br><span class="line">    std::string theAddress;</span><br><span class="line">    std::ist&lt;PhoneNumber&gt; thePhones;</span><br><span class="line">    <span class="type">int</span> numTimesConsuted;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐写法 —— 会导致多调用赋值操作函数降低效率</span></span><br><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> std::string &amp;address,</span><br><span class="line">                 <span class="type">const</span> std::ist&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">&#123;</span><br><span class="line">    theName = name;             <span class="comment">// 这些是赋值操作</span></span><br><span class="line">    theAddress = address;       <span class="comment">// 而非初始化</span></span><br><span class="line">    thePhones = phones;</span><br><span class="line">    numTimesConsuted = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐写法 —— 只调用拷贝构造函数</span></span><br><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> std::string &amp;address,</span><br><span class="line">                 <span class="type">const</span> std::ist&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">    : <span class="built_in">theName</span>(name),            <span class="comment">// 这些是初始化操作</span></span><br><span class="line">      <span class="built_in">theAddress</span>(address),</span><br><span class="line">      <span class="built_in">thePhones</span>(phones),</span><br><span class="line">      <span class="built_in">numTimesConsuted</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者在类的成员变量声明时进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cass PhoneNumber &#123; ... &#125;;</span><br><span class="line">cass ABEntry </span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="comment">// 不需要对变量进行初始化</span></span><br><span class="line">    <span class="built_in">ABEntry</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">ABEntry</span>(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> std::string &amp;address,</span><br><span class="line">            <span class="type">const</span> std::ist&lt;PhoneNumber&gt;&amp; phones) </span><br><span class="line">    : <span class="built_in">theName</span>(name), <span class="built_in">theAddress</span>(address),      <span class="comment">// 重复操作,会覆盖初值</span></span><br><span class="line">      <span class="built_in">thePhones</span>(phones), <span class="built_in">numTimesConsuted</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 在声明时就初始化成员变量</span></span><br><span class="line">    std::string theName&#123;<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">    std::string theAddress&#123;<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">    std::ist&lt;PhoneNumber&gt; thePhones&#123;&#125;;</span><br><span class="line">    <span class="type">int</span> numTimesConsuted = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-3-显式构造函数"><a href="#4-3-显式构造函数" class="headerlink" title="4.3  显式构造函数"></a>4.3  <strong>显式构造函数</strong></h3><p>对于单个参数的构造函数，不要定义为隐式类型转换，使用C++关键字<strong>expicit</strong>。</p><p><strong>隐式类型转换：</strong>即允许某种类型(称作 源类型)的对象被用于需要另一种类型(称作 目的类型)。例如将一个int类型的参数传递给需要doube类型的函数。通常只有一个参数的构造函数，被看作是一种隐式转换。</p><p>除了单参数构造函数外，也适用于除第一个参数以外的其他参数都具有默认参数的构造函数，例如Foo::Foo(string name, int id &#x3D; 42)。<strong>拷贝和移动构造函数</strong>不需要被标记为expicit，因为它们并不进行类型转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cass Foo </span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="comment">// 以下都需要进行expicit进行显示转换</span></span><br><span class="line">    <span class="function">expicit <span class="title">Foo</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a)</span></span>;</span><br><span class="line">    <span class="function">expicit <span class="title">Foo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> a, <span class="type">const</span> <span class="type">int</span> b = <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 不需要使用expicit</span></span><br><span class="line"><span class="built_in">Foo</span>(<span class="type">const</span> <span class="type">int</span> a, <span class="type">const</span> foat b);</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;);        <span class="comment">// 拷贝构造</span></span><br><span class="line">    <span class="built_in">Foo</span>(Foo&amp;&amp;);             <span class="comment">// 移动构造</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当设计目的用于其他类型进行透明封装的类来说，隐式类型转换是合适的，例如QJsonVaue和QVariant。</p><h3 id="4-4-结构体-VS类"><a href="#4-4-结构体-VS类" class="headerlink" title="4.4  结构体 VS类"></a>4.4  结构体 VS类</h3><p>在C++中struct和cass关键词几乎含义一样。对两个关键字进行进一步规定是，<strong>struct用来定义包含数据的被动式对象，也可以包含相关的常量</strong>。但除了存取数据成员以外，没有别的操作函数功能。并且<strong>存取功能通过直接访问位域，而非函数调用</strong>。除了构<strong>造函数、析构函数、initiaize初始化数据、reset重置数据、operator&#x3D;&#x3D;数据对比操作符重载等</strong>类似用于设定数据成员的函数外，不能提供其他功能函数<strong>。</strong>如果需要更多函数功能，使用cass代替struct。</p><h3 id="4-5-接口"><a href="#4-5-接口" class="headerlink" title="4.5  接口"></a>4.5  <strong>接口</strong></h3><p>当一个类满足以下要求时，称之为纯接口。类应以I为开头命名，如IFoo。</p><ul><li>只有纯虚函数(“&#x3D;0”)和静态函数(析构函数除外)；</li><li>没有定义任何构造函数。如果有，也不能带有参数，并且必须为<strong>protected</strong>；</li><li>如果它是一个子类，也只能从满足上述条件的类继承。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类为非接口类</span></span><br><span class="line">cass Foo</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误 —— 基类非接口类</span></span><br><span class="line">cass IBar : pubic Foo</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="function">virtua <span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有纯虚函数 </span></span><br><span class="line">cass IProcessCommunicationCaback</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="function">virtua <span class="type">void</span> <span class="title">onConnected</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function">virtua <span class="type">void</span> <span class="title">onDisconnected</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承于接口类才能定义为接口类</span></span><br><span class="line">cass IBar : pubic IProcessCommunicationCaback</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="function">virtua <span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以I为前缀可以提醒该类为纯接口类，这一点对于<strong>多重继承</strong>尤其重要。</p><p>​    由于接口类不能被直接实例化，为确保接口类的所有实现可被正确销毁，必须为之声明<strong>虚析构函数</strong>。</p><h3 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6  继承"></a>4.6  继承</h3><p>当子类继承基类时，子类包含了父基类所有数据及操作的定义。继承主要用于两种场景：实现继承，子类继承父类的实现代码；接口继承，子类仅继承父类的接口名称。</p><p><strong>尽量使用pubic继承，不要使用private继承，而应该替换成把类的实例作为成员对象的方式</strong>。避免过度使用继承，要尽量做到只在“是一种”的情况下使用继承，例如QFrame是“是一种”控件，QFrame继承于QWidget。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cass Foo </span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cass Bar : <span class="keyword">private</span> Foo <span class="comment">// 禁止</span></span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; <span class="built_in">foo</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cass Bar</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; f.<span class="built_in">foo</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Foo f&#123;&#125;;    <span class="comment">// 应该以类的成员变量形式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果类确定存在继承关系，作为基类应该将<strong>析构函数</strong>声明为virtua。相反，当类的设计目的不是作为基类，或不具有多态性，就不将析构函数声明为<strong>virtua</strong>。而当类中存在虚函数，则析构函数也应该声明为<strong>virtua</strong>。</p><p><strong>注意：析构函数与构造函数相同，也不应该调用虚函数或者发生错误。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为基类,必须将析构函数声明为virtua</span></span><br><span class="line">cass Base</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    virtua ~<span class="built_in">Base</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cass Derived : pubic Base</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类中存在virtua函数,必须将析构函数声明为virtua</span></span><br><span class="line">cass Foo</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    virtua ~<span class="built_in">Foo</span>();       <span class="comment">// 定义虚函数foo,析构函数声明为virtua</span></span><br><span class="line">    <span class="function">virtua <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-7-多重继承"><a href="#4-7-多重继承" class="headerlink" title="4.7  多重继承"></a>4.7  多重继承</h3><p>只有以下情况允许多重继承：<strong>只有一个基类是非抽象类，其他基类都是以I为前缀的纯接口类。</strong>继承顺序应从非抽象类，再到纯接口类的顺序进行继承。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">cass Foo</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cass Bar</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cass IBar</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="function">virtua <span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误 —— Foo和Bar都是非抽象类</span></span><br><span class="line">cass Baz : pubic Foo, pubic Bar</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确 —— Foo为非抽象类,IBar为纯接口类</span></span><br><span class="line">cass Baz : pubic Foo, pubic IBar</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-8-声明顺序"><a href="#4-8-声明顺序" class="headerlink" title="4.8  声明顺序"></a>4.8  声明顺序</h3><p>类的访问控制区段的声明为：pubic:、protected:、private:。如果某区段没有内容可以不声明，注释方式参考<a href="#_%E6%B3%A8%E9%87%8A">8. 注释</a>。每个区段内的声明通常按以下顺序：</p><ul><li>typedefs和枚举</li><li>常量</li><li>构造函数</li><li>析构函数</li><li>成员函数，包含静态成员函数</li><li>槽函数(公有继承后跟信号)</li><li>数据成员，包含静态数据成员</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">cass Foo : pubic QObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Q_OBJECT</span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(<span class="type">int</span> m_foo READ foo)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">pubic:</span></span><br><span class="line"><span class="function">    // 公有成员</span></span><br><span class="line"><span class="function">    Foo();</span></span><br><span class="line">    ~<span class="built_in">Foo</span>();</span><br><span class="line">    <span class="comment">// 成员函数，包含静态成员函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">pubic Q_SOTS:</span><br><span class="line">    <span class="comment">// 公有槽函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sotFoo</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">Q_SIGNAS:</span><br><span class="line">    <span class="comment">// 信号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">signaFoo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 保护成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Q_SOTS:</span><br><span class="line">    <span class="comment">// 保护槽函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sotBar</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">baz</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> Q_SOTS:</span><br><span class="line">    <span class="comment">// 私有槽函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sotBar</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有成员,友元类</span></span><br><span class="line">    <span class="type">int</span> m_foo;</span><br><span class="line">    <span class="keyword">friend</span> cass faz;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-9-存取控制"><a href="#4-9-存取控制" class="headerlink" title="4.9  存取控制"></a>4.9  <strong>存取控制</strong></h3><p>将<strong>所有数据成员</strong>声明为<strong>private</strong>，并根据需要提供响应的存取函数。静态常量数据成员可以不是私有成员。</p><p>存取函数一般在头文件中定义为内联函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cass Foo</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="function">inine <span class="type">int</span> <span class="title">getBar</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">inine <span class="type">void</span> <span class="title">setBar</span><span class="params">(<span class="type">const</span> <span class="type">int</span> vaue)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_bar;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-函数"><a href="#5-函数" class="headerlink" title="5. 函数"></a>5. <strong>函数</strong></h2><p>函数命名规则参考<a href="#_%E5%87%BD%E6%95%B0%E5%91%BD%E5%90%8D">7.6函数命名</a>。</p><h3 id="5-1-参数"><a href="#5-1-参数" class="headerlink" title="5.1  参数"></a>5.1  <strong>参数</strong></h3><p>函数的参数顺序为：输入参数在前，输出参数包含输入输出参数在后</p><p>C&#x2F;C++中的函数参数可能是输入参数，也可能是输出参数，或者是输入输出参数。输入参数通常是<strong>const值传递</strong>或者const引用或指针*，输出参数或输入输出参数则为<strong>非const指针或引用</strong>。更多说明参考<a href="#_const%E7%94%A8%E6%B3%95">6.4 const用法</a>。</p><p>在加入新参数时不要因为它们时新参数就置于参数列表最后，而是仍然要按照输入参数在前，输入参数在后的原则。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cass Foo</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line">    <span class="comment">// 内置类型输入参数或者ST的迭代器,用const值传递</span></span><br><span class="line">    <span class="comment">// baz作为输出参数用非const指针形式传入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> <span class="type">int</span> bar, foat *baz)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *bar, foat *baz)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> std::vector::iterator iter, foat *baz)</span></span>;</span><br><span class="line">    <span class="comment">// 当输入参数为对象,则用const引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> std::string&amp; bar, foat *baz)</span></span>;<span class="comment">// 推荐—直观看出输入/输出参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> std::string&amp; bar, foat &amp;baz)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：这一条不是硬性规定，属于推荐写法，实际情况复杂时，可以进行更改。</strong></p><h3 id="5-2-编写简短函数"><a href="#5-2-编写简短函数" class="headerlink" title="5.2  编写简短函数"></a>5.2  <strong>编写简短函数</strong></h3><p>函数的编写尽量简练。目的是使函数实现的逻辑结构化、清晰化，便于阅读与维护。</p><p>如果函数行数太多(超过40行，后成为长函数)，可以考虑将长函数拆分成几个短函数，是函数尽量简短，便于阅读和维护。</p><p><strong>注意：长函数按照具体情况而定，例如对于部分if和switch逻辑，分支过长就不遵行本条规定。</strong></p><h2 id="6-其他C-特性"><a href="#6-其他C-特性" class="headerlink" title="6.  其他C++特性"></a>6.  <strong>其他C++特性</strong></h2><h3 id="6-1-异常"><a href="#6-1-异常" class="headerlink" title="6.1  异常"></a>6.1  <strong>异常</strong></h3><p><strong>禁止C++异常机制</strong>，所有错误都应该通过错误值在函数之间传递并做出相应判断，而不应该通过异常进行错误处理。<strong>例外：在接管C++语言本身抛出的异常(例如new失败、ST)、第三方库(例如Qt)抛出的异常时，可以使用异常机制</strong>。</p><p>面对异常首先考虑是否为操作错误，例如参数范围问题，应该在代码进行入参检测；例如Qt库中出现私有类指针为野指针，应该从析构问题解决；这些问题都不应该从接异常解决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> en = ...;</span><br><span class="line"><span class="type">char</span> *p = nuptr;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">char</span>[en];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (bad_aoc) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-类型转换"><a href="#6-2-类型转换" class="headerlink" title="6.2 类型转换"></a>6.2 <strong>类型转换</strong></h3><p>使用C++的类型转换，如static_cast&lt;&gt;()。而不是使用int y &#x3D; (int)x或int y &#x3D; int(x)等转换形式。即<strong>不要使用C风格进行类型转换，而应该使用C++风格</strong>。</p><ul><li>用static_cast替代C风格的值转换，或某个类的指针需要明确向上转换为父类指针；</li><li>用const_cast去掉const限定符；</li><li>用reinterpret_cast指针类型和整型和其他类型指针进行转换；</li><li>用dynamic_cast转换存在继承关系的对象。</li></ul><h3 id="6-3-前置自增和自减"><a href="#6-3-前置自增和自减" class="headerlink" title="6.3  前置自增和自减"></a>6.3  <strong>前置自增和自减</strong></h3><p>**对于迭代器和其他模板类型使用前缀形式(++i)*的自增、自减运算符，对于简单数值(非对象)，两种都无所谓**。在不考虑返回值的情况，前置自增(++i)通常要比后置自增(i++)效率更高。因为后置自增(或自减)需要对表达式的值i进行一次拷贝。如果i是迭代器或其他非数值类型，拷贝的代价比较大。所以推荐使用前置自增。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector vec;</span><br><span class="line"><span class="keyword">for</span>(std::vector::iterator iter = vec.<span class="built_in">begin</span>();</span><br><span class="line">    iter != vec.<span class="built_in">end</span>(); ++iter); <span class="comment">// 推荐 —— 效率更高</span></span><br><span class="line"><span class="keyword">for</span>(std::vector::iterator iter = vec.<span class="built_in">begin</span>();</span><br><span class="line">    iter != vec.<span class="built_in">end</span>(); iter++); <span class="comment">// 不推荐 —— 需要进行多次拷贝构造</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 简单数值(内置类型),两者均可</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++); </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i); <span class="comment">// 更推荐,保证习惯一致</span></span><br></pre></td></tr></table></figure><h3 id="6-4-const用法"><a href="#6-4-const用法" class="headerlink" title="6.4  const用法"></a>6.4  <strong>const用法</strong></h3><p>const变量、数据成员、函数和参数为编译时进行类型检测增加了一道屏障，便于尽早发现问题，参考<a href="#_%E5%8F%82%E6%95%B0">5.1 参数</a>。因此尽可能的情况下使用const，参考：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cass Bar&#123;&#125;;</span><br><span class="line">cass Foo</span><br><span class="line">&#123;</span><br><span class="line">pubic:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getBar</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_bar; &#125; <span class="comment">// 访问函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setBar</span><span class="params">(<span class="type">const</span> <span class="type">int</span> b)</span></span>; &#123; m_bar = b &#125;; <span class="comment">// 函数传入不会修改的参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sum</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">getBar</span>() + m_CONST_VAUE; &#125; <span class="comment">// 未调用非const函数</span></span><br><span class="line"><span class="function"><span class="type">const</span> Bar&amp; <span class="title">getCBar</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_cBar; &#125; <span class="comment">// 返回const引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_bar;</span><br><span class="line">Bar m_cBar;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> m_CONST_VAUE = <span class="number">10</span>; <span class="comment">// 构造之后不会修改的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>如果函数不会修改传入的引用或指针类型参数，该参数应声明为const；</li><li>尽可能将函数声明为const。访问函数应该总是const。其他不会修改任何数据成员，未调用非const函数，返回数据成员为指针或引用也应该声明成const；</li><li>如果数据成员在对象构造之后不再发生变化，可将其定义未const。</li></ul><h3 id="6-5-预处理宏"><a href="#6-5-预处理宏" class="headerlink" title="6.5   预处理宏"></a>6.5   <strong>预处理宏</strong></h3><p>宏意味着你和编译器看到的代码时不同的，这可能会导致异常行为，而且宏具有全局作用域。尽量<strong>以内联函数、枚举和常量代替宏定义</strong>。命名规则参考<a href="#_%E5%B8%B8%E9%87%8F%E5%91%BD%E5%90%8D">7.5 常量命名</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const替换#define</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASPECT_RATIO 1.653</span></span><br><span class="line"><span class="type">const</span> doube ASPECT_RATIO = <span class="number">1.653</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AUTHOR_NAME <span class="string">&quot;Scott Meyers&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> std::string <span class="title">AUTHOR_NAME</span><span class="params">(<span class="string">&quot;Scott Meyers&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inine替换#define</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CA_WITH_MAX(a,b) f((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">CA_WITH_MAX</span>(++a, b);       <span class="comment">// a被累加两次</span></span><br><span class="line"><span class="built_in">CA_WITH_MAX</span>(++a, b + <span class="number">10</span>);  <span class="comment">// a被累加一次</span></span><br><span class="line"><span class="function">tempate&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">inine <span class="type">void</span> <span class="title">caWithMax</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// enum替换#define</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_TURNS 5</span></span><br><span class="line">cass CostEstimate </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> scores[NUM_TURNS];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cass CostEstimate </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; NumTurns = <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="type">int</span> scores[NumTurns];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-6-sieof"><a href="#6-6-sieof" class="headerlink" title="6.6  sieof"></a>6.6  <strong>sieof</strong></h3><p>尽可能用sizeof(varname)代替sizeof(type)。使用sizeof(varname)时因为当代码中变量类型改变时会自动更新。当用sizeof(type)处理不涉及任何变量的代码，比如处理来自外部或内部的数据格式时，sizeof(varname)就不适用了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Struct data;</span><br><span class="line"><span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="built_in">sizeof</span>(data));     <span class="comment">// 推荐 —— 当data改成其他类型时不影响运行</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="built_in">sizeof</span>(Struct));   <span class="comment">// 不推荐 —— 改为其他类型未做修改可能导致BUG</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不适用sizeof(varname)情况</span></span><br><span class="line"><span class="keyword">if</span> (raw_size &lt; <span class="built_in">sizeof</span>(<span class="type">int</span>)) &#123;</span><br><span class="line">    <span class="built_in">OG</span>(ERROR) &lt;&lt; <span class="string">&quot;compressed record not big enough for count:&quot;</span> &lt;&lt; raw_size;</span><br><span class="line">    <span class="keyword">return</span> fase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-7-auto"><a href="#6-7-auto" class="headerlink" title="6.7  auto"></a>6.7  <strong>auto</strong></h3><p>C++11中，若变量被声明为auto，类型就会被自动匹配成初始化表达式的类型。用auto绕过繁琐的类型名，只要可读性好就可以使用，但不要用在局部变量之外的地方。<strong>auto不要用在初始化列表</strong>，会导致歧义，同时要注意区分*<em>auto</em>和const* *<strong>auto</strong>&amp;*。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 涉及模板类或命名空间时,类型名会很复杂</span></span><br><span class="line">sparse_hash_map&lt;string, <span class="type">int</span>&gt;::iterator iter = m.<span class="built_in">find</span>(va);</span><br><span class="line"><span class="comment">// 修改为auto显得直观(因为iter一般是迭代器变量,即m的迭代器)</span></span><br><span class="line"><span class="keyword">auto</span> iter = m.<span class="built_in">find</span>(va);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有auto的话，我们不得不在同一个表达式出现两次类型名</span></span><br><span class="line">diagnostics::ErrorStatus* status = <span class="keyword">new</span> diagnostics::<span class="built_in">ErrorStatus</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line"><span class="comment">// 使用auto就简单且不会有歧义</span></span><br><span class="line"><span class="keyword">auto</span> status = <span class="keyword">new</span> diagnostics::<span class="built_in">ErrorStatus</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> i = x.<span class="built_in">ookup</span>(key); <span class="comment">// 不推荐 —— 代码不能直观看出i是何种类型</span></span><br><span class="line">vector&lt;string&gt; v;</span><br><span class="line"><span class="keyword">auto</span> s1 = v[<span class="number">0</span>]; <span class="comment">// 创建一份v[0]的拷贝</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; s2 = v[<span class="number">0</span>]; <span class="comment">// s2是v[0]的一个引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// auto不要用在初始化列表</span></span><br><span class="line"><span class="keyword">auto</span> d = &#123;<span class="number">1.23</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> d&#123;<span class="number">1.23</span>&#125;;           <span class="comment">// d是std::initiazer_ist&lt;doube&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> d = doube&#123;<span class="number">1.23</span>&#125;;  <span class="comment">// d是doube,并非std::initiazer_ist</span></span><br></pre></td></tr></table></figure><h3 id="6-8-lambda表达式"><a href="#6-8-lambda表达式" class="headerlink" title="6.8  lambda表达式"></a>6.8  <strong>lambda表达式</strong></h3><p>ambda表达式是创建匿名函数对象的一种简易途径，常用于把函数当参数传递，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Weight</span>(x) &lt; <span class="built_in">Weight</span>(y);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当ambda变量需要捕获识，<strong>禁止使用通用捕获，将所有的捕获都显式写出来</strong>，增加可读性。使用引用捕获时，变量名和&amp;之间不留空格</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">[=](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x + n; &#125;    <span class="comment">// 不推荐—使用默认捕获</span></span><br><span class="line">[n](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x + n; &#125;    <span class="comment">// 推荐—显式捕获n写出来</span></span><br><span class="line">[&amp;n](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x + n; &#125;    <span class="comment">// &amp;和n不留空格</span></span><br></pre></td></tr></table></figure><p>ambda表达式用于参数传递时，如果函数体超过五行，应当将ambda表达式转换为std::function对象；如果是作为connect的槽函数，则改用函数的形式。</p><h2 id="7-命名约定"><a href="#7-命名约定" class="headerlink" title="7.  命名约定"></a>7.  <strong>命名约定</strong></h2><p>命名的风格能让我们在不需要去查找类型声明的条件下快速了解某个名字代表的含义：<strong>类型、变量、函数、常量、宏、信号、槽函数</strong>等等。</p><h3 id="7-1-通用命名约定"><a href="#7-1-通用命名约定" class="headerlink" title="7.1  通用命名约定"></a>7.1  <strong>通用命名约定</strong></h3><p>名称由<strong>字母、数字以及下划线组合而成，且第一位不能为数字，小驼峰命名方式</strong>。</p><p>尽量使用描述性的命名，少用缩写(除了一些广泛接受的缩写，例如iter表示迭代器、用T表示模板参数)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> priceCountReader;       <span class="comment">// 无缩写</span></span><br><span class="line"><span class="type">int</span> numError;               <span class="comment">// &quot;num&quot;是常见的缩写</span></span><br><span class="line"><span class="type">int</span> numDNSConnection;       <span class="comment">// DNS是都知道的概念</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;                      <span class="comment">// 不清楚作用和意义</span></span><br><span class="line"><span class="type">int</span> nCompConns;             <span class="comment">// 缩写不知道代表何种意思</span></span><br><span class="line"><span class="type">int</span> wgcConnections;         <span class="comment">// &quot;wgc&quot;是何种意思</span></span><br><span class="line"><span class="type">int</span> pcReader;               <span class="comment">// &quot;pc&quot;可能出现歧义</span></span><br><span class="line"><span class="type">int</span> cstmrID;                <span class="comment">// 缩写若干字母</span></span><br></pre></td></tr></table></figure><h3 id="7-2-文件命名"><a href="#7-2-文件命名" class="headerlink" title="7.2  文件命名"></a>7.2  <strong>文件命名</strong></h3><p>文件命名<strong>使用大驼峰命名方式，定义类和文件名一般成对出现</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NameSpace.h</span></span><br><span class="line"><span class="comment">// 文件名说明作用,如NameSpace.h存放关于NameSpace的声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 命名空间定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIQTEK_NAMESPACE ciqtek</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 命名空间开始</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEGIN_NAMESPACE_CIQTEK namespace CIQTEK_NAMESPACE &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 命名空间结束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> END_NAMESPACE_CIQTEK &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 命名空间修饰符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIQTEK_QUAIFIER     ::CIQTEK_NAMESPACE::</span></span><br><span class="line"><span class="comment">// AgorithmAutogamma.h</span></span><br><span class="line"><span class="comment">// 文件名和类名一一对应,成对存在</span></span><br><span class="line">cass AgorithmAutogamma</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="7-3-类型命名"><a href="#7-3-类型命名" class="headerlink" title="7.3  类型命名"></a>7.3  <strong>类型命名</strong></h3><p>类型命名的<strong>每个单词首字母都是大写，不包含下划线，大驼峰命名方式</strong>。所有类型命名——类、结构体、类型定义(typedef)、枚举、类型模板参数均使用本约定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类和结构体</span></span><br><span class="line">cass UrTabe &#123;&#125;;</span><br><span class="line">cass UrTabeTester &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UrTabeProperties</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> hash_map&lt;UrTabeProperties *, string&gt; PropertiesMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// using 别名</span></span><br><span class="line"><span class="keyword">using</span> PropertiesMap = hash_map&lt;UrTabeProperties *, string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">UrTabeErrors</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型模板参数</span></span><br><span class="line"><span class="function">tempate&lt;<span class="keyword">typename</span> UrInfo&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setUr</span><span class="params">(<span class="type">const</span> UrInfo&amp;)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="7-4-变量命名"><a href="#7-4-变量命名" class="headerlink" title="7.4  变量命名"></a>7.4  <strong>变量命名</strong></h3><p>变量(包含函数参数)和数据成员名<strong>一律用小驼峰命名方式，每行一个变量，单字符的变量只在循环计数中使用</strong>。对于不同作用域的变量遵循以下规则：</p><ul><li>类成员变量须在变量名前加m_前缀。</li><li>局部变量等到需要使用时再定义，且定义是必须要初始化，整数为0，实数用0.0，指针用nuptr，字符(串)用’\0’。</li><li>全局变量命名时须在变量前加g_前缀。</li><li>静态变量名以s_开头。</li></ul><table><thead><tr><th>前缀</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>无</td><td>局部变量(oca)</td><td>odVaue</td></tr><tr><td>m_</td><td>类的成员变量(member)</td><td>int m_width</td></tr><tr><td>ms_</td><td>类的静态成员变量(static member)</td><td>static int ms_initVaue</td></tr><tr><td>s_</td><td>静态变量(static)</td><td>static int s_initVaue</td></tr><tr><td>g_</td><td>外部全局变量</td><td>int g_maxCount</td></tr><tr><td>sg_</td><td>静态全局变量(static goba)</td><td>static int sg_exampe</td></tr><tr><td>gg_</td><td>进程间共享的数据段全局变量(goba goba)</td><td>int gg_shareVaue</td></tr></tbody></table><h3 id="7-5-常量命名"><a href="#7-5-常量命名" class="headerlink" title="7.5  常量命名"></a>7.5  <strong>常量命名</strong></h3><p>常量*<em>不含前缀且应该大写，单词间由下滑线，包含constexpr</em>、const以及宏定义。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> DAYS_IN_AWEEK = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> DAYS_IN_AWEEK = <span class="number">7</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DAYS_IN_AWEEK 7 <span class="comment">// 不推荐写法,命名方式按常量命名规则</span></span></span><br></pre></td></tr></table></figure><h3 id="7-6-函数命名"><a href="#7-6-函数命名" class="headerlink" title="7.6  函数命名"></a>7.6  <strong>函数命名</strong></h3><p>函数命名以及函数参数<strong>都使用小驼峰命名方式，函数名时动词或含有动词的短语，函数参数若非基础数据类型，使用对象引用</strong>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getVaue</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setVaue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> vaue)</span></span>;         <span class="comment">// 基础类型(迭代器)值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setCoor</span><span class="params">(<span class="type">const</span> QCoor&amp; newCoor)</span></span>;  <span class="comment">// 非基础类型引用传递</span></span><br></pre></td></tr></table></figure><p><em>当函数为信号或者槽函数时，应分别在前加上signa*\和sot前缀。</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">signaogWritten</span><span class="params">(<span class="type">const</span> ogeve &amp;eve, <span class="type">const</span> QString &amp;og)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sotogWrite</span><span class="params">(<span class="type">const</span> ogeve &amp;eve, <span class="type">const</span> QString &amp;og)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="7-7-命名空间命名"><a href="#7-7-命名空间命名" class="headerlink" title="7.7   命名空间命名"></a>7.7   <strong>命名空间命名</strong></h3><p>命名空间的名称是名词，<strong>用小写字母命名</strong>，每个单词以下划线分割，例如：ciqtek。</p><h3 id="7-8-枚举命名"><a href="#7-8-枚举命名" class="headerlink" title="7.8  枚举命名"></a>7.8  <strong>枚举命名</strong></h3><p>枚举名和枚举值<strong>都是名词</strong>，和常量或宏规则一致，<strong>枚举值每个字母均为大写，单词之间以下划线间隔，枚举名为大驼峰命名方式</strong>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyCoor</span> <span class="comment">// 枚举名</span></span><br><span class="line">&#123;</span><br><span class="line">    WHITE, <span class="comment">// 枚举值</span></span><br><span class="line">BACK,</span><br><span class="line">SKY_BUE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="7-9-结构体命名"><a href="#7-9-结构体命名" class="headerlink" title="7.9   结构体命名"></a>7.9   <strong>结构体命名</strong></h3><p>结构体中只定义变量，不定义函数。需要定义函数的结构体，转换成类实现。</p><p><strong>结构体名</strong>是名词，<strong>每个单词以大写字母开头，大驼峰命名方式</strong>。<strong>结构体成员</strong>是名词，以<strong>小驼峰命名方式</strong>，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyCoor</span></span><br><span class="line">&#123;</span><br><span class="line">    boo isMyCoor;</span><br><span class="line">    <span class="type">int</span> white;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="7-10-获取器和设置器命名"><a href="#7-10-获取器和设置器命名" class="headerlink" title="7.10   获取器和设置器命名"></a>7.10   <strong>获取器和设置器命名</strong></h3><p>获取器和设置器都是根据约定俗成的命名规则：</p><ul><li>非布尔型的获取器**coor()<strong>或者</strong>getCoor()**；</li><li>布尔型的获取器**isChecked()**；</li><li>设置器**Coor(const Coor&amp; newCoor)**。</li></ul><h3 id="7-11-界面控件命名"><a href="#7-11-界面控件命名" class="headerlink" title="7.11  界面控件命名"></a>7.11  <strong>界面控件命名</strong></h3><p>控件命名应以控件类型结尾，以说明控件的类型，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 界面中有且仅有一种该类型控件</span></span><br><span class="line">QPainTextEdit *textEdit;</span><br><span class="line">Qabe *abe;</span><br><span class="line">QineEdit *ineEdit;</span><br><span class="line"><span class="comment">// 界面中出现多种重复的控件,应将前面补充说明</span></span><br><span class="line">Qabe *contentsabe;</span><br><span class="line">QPushButton *findButton;</span><br><span class="line">QTooBar *fieTooBar;</span><br><span class="line">QComboBox *caseComboBox;</span><br><span class="line">QSpinBox *maxVisibeSpinBox;</span><br><span class="line">QCheckBox *wrapCheckBox;</span><br></pre></td></tr></table></figure><h2 id="8-注释"><a href="#8-注释" class="headerlink" title="8. 注释"></a>8. <strong>注释</strong></h2><p>一般情况下源程序有效注释量必须在20%以上，不易理解的地方都需加上注释，需要简单精炼。</p><h3 id="8-1-注释风格"><a href="#8-1-注释风格" class="headerlink" title="8.1  注释风格"></a>8.1  <strong>注释风格</strong></h3><p>头文件注释风格需要兼容Doxygen注释方式，便于生成说明文档。源文件注释使用&#x2F;&#x2F;或&#x2F;* *&#x2F;都可以。</p><h3 id="8-2-头文件注释"><a href="#8-2-头文件注释" class="headerlink" title="8.2  头文件注释"></a>8.2  <strong>头文件注释</strong></h3><p>头文件注释包括<strong>版权说明、版本号、作者、生成日期、描述信息</strong>等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">**Copyright(C), 2021-2022, Ciqtek Technoogy.</span></span><br><span class="line"><span class="comment">**Version:     1.0</span></span><br><span class="line"><span class="comment">**Author:      dingyy</span></span><br><span class="line"><span class="comment">**Date:        $DATE$</span></span><br><span class="line"><span class="comment">**Description: </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="8-3-类注释"><a href="#8-3-类注释" class="headerlink" title="8.3  类注释"></a>8.3  <strong>类注释</strong></h3><p>类注释<strong>包括描述信息，有必要时需将使用方法加到注释中</strong>。</p><p>简单类只需要包含简要说明信息即可，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief    类描述信息</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>当类需要添加实例代码时候，按以下方式进行备注：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief    类描述信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   Exampe of usage:</span></span><br><span class="line"><span class="comment"> *   @code</span></span><br><span class="line"><span class="comment"> *       示例代码</span></span><br><span class="line"><span class="comment"> *   @endcode</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="8-4-函数注释"><a href="#8-4-函数注释" class="headerlink" title="8.4  函数注释"></a>8.4  <strong>函数注释</strong></h3><p>函数注释主要<strong>包括描述信息、参数信息、返回值以及返回值说明，有必要时加入注解信息</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief          函数名 函数简介</span></span><br><span class="line"><span class="comment"> * @param          形参 参数说明</span></span><br><span class="line"><span class="comment"> * @return         返回说明</span></span><br><span class="line"><span class="comment"> *   @retva 0     (非必要)返回值说明</span></span><br><span class="line"><span class="comment"> *   @retva 1     (非必要)返回值说明</span></span><br><span class="line"><span class="comment"> * @note           (非必要)注释信息</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="8-5-变量注释"><a href="#8-5-变量注释" class="headerlink" title="8.5  变量注释"></a>8.5  <strong>变量注释</strong></h3><p>类的数据成员变量按需进行注释，<strong>全局变量需要注释说明含义及用途</strong>。变量注释<strong>置于变量的上方</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 回归测试用例总数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_TEST_CASES = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><h3 id="8-6-实现注释"><a href="#8-6-实现注释" class="headerlink" title="8.6  实现注释"></a>8.6  <strong>实现注释</strong></h3><p>对于实现代码中巧妙的、隐晦的、重要的地方加以注释。<strong>注意后跟一个空格</strong>。</p><p><strong>巧妙或复杂的代码在代码块上方注释</strong>，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将结果除以2,考虑到x包含加法的进位</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; resut-&gt;<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    x = (x &lt;&lt; <span class="number">8</span>) + (*resut)[i];</span><br><span class="line">    (*resut)[i] = x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    x &amp;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-7-枚举和结构体注释"><a href="#8-7-枚举和结构体注释" class="headerlink" title="8.7  枚举和结构体注释"></a>8.7  <strong>枚举和结构体注释</strong></h3><p>枚举注释需要对<strong>枚举、枚举值</strong>进行说明。</p><p>结构体注释需要对<strong>结构体、成员变量</strong>进行说明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief     日志类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ogeve</span> </span><br><span class="line">&#123;</span><br><span class="line">    OG_EVE_TRACE = <span class="number">0</span>,             <span class="comment">///&lt; TARCE输出 </span></span><br><span class="line">    OG_EVE_DEBUG = <span class="number">10000</span>,         <span class="comment">///&lt; DEBUG输出 </span></span><br><span class="line">    OG_EVE_INFO = <span class="number">20000</span>,          <span class="comment">///&lt; INFO输出 </span></span><br><span class="line">    OG_EVE_WARN = <span class="number">30000</span>,          <span class="comment">///&lt; WARN输出 </span></span><br><span class="line">    OG_EVE_ERROR = <span class="number">40000</span>,         <span class="comment">///&lt; ERROR输出 </span></span><br><span class="line">    OG_EVE_FATA = <span class="number">50000</span>,         <span class="comment">///&lt; FATA输出 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief     自定义颜色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyCoor</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> red;        <span class="comment">///&lt; 红色分量</span></span><br><span class="line">    <span class="type">int</span> green;      <span class="comment">///&lt; 绿色分量</span></span><br><span class="line">    <span class="type">int</span> bue;       <span class="comment">///&lt; 蓝色分量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="8-8-TODO注释"><a href="#8-8-TODO注释" class="headerlink" title="8.8   TODO注释"></a>8.8   <strong>TODO注释</strong></h3><p>对于<strong>临时的、短期的方案，或计划中但未完成的代码，或已实现功能但待优化的代码</strong>使用TODO注释。TODO注释需要<strong>作者、日期</strong>利于后期检索，避免查找困难，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MyCass::test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 计划但未完成</span></span><br><span class="line"><span class="comment">// TODO - Barmaco 2022/01/18 9:59 实现xx相关功能</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO - Barmaco 2022/01/18 9:59 临时方案</span></span><br><span class="line">    <span class="keyword">return</span> (a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyCass::doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// TODO - Barmaco 2022/01/18 9:59 待优化</span></span><br><span class="line">    <span class="type">int</span> x = (x &lt;&lt; <span class="number">8</span>) + (*resut)[i];</span><br><span class="line">    (*resut)[i] = x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    x &amp;= <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="9-格式"><a href="#9-格式" class="headerlink" title="9. 格式"></a>9. <strong>格式</strong></h2><h3 id="9-1-行长度"><a href="#9-1-行长度" class="headerlink" title="9.1  行长度"></a>9.1  <strong>行长度</strong></h3><p>较长的语句(&gt;80字符)要分成多行书写，长表达式要<strong>在较低优先级操作符处划分新行，操作符放在新行之首，逗号放在一行的结束，划分出的新行要进行适当的缩进</strong>，使排版整齐，语句可读，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((taskOne &lt; taskNumber) &amp;&amp; (taskTwo &lt; taskNumber) </span><br><span class="line">    &amp;&amp; (taskThree &lt; taskNumber) &amp;&amp;(taskFour &lt; taskNumber)) &#123;</span><br><span class="line">&#125; <span class="comment">// 操作符放在新行之首</span></span><br><span class="line">boo retva = <span class="built_in">doSomething</span>(averyveryveryveryveryveryongargument1,</span><br><span class="line">                          argument2, argument3); <span class="comment">// 后一行与第一个实参对齐</span></span><br></pre></td></tr></table></figure><h3 id="9-2-文件编码"><a href="#9-2-文件编码" class="headerlink" title="9.2  文件编码"></a>9.2  <strong>文件编码</strong></h3><p>为了统一文件编码，避免开发过程中文件编码混乱问题，文件保存过程中，<strong><em>统一使用UTF-8无签名</em>编码</strong>。编码转换时，默认在UTF-8中转换。</p><p>下载VS插件Force UTF-8(No BOM)，选择第一个点击下载→关闭并重启VS安装插件。</p><p><img src="/CodeStyle/image-20250317195151183.png" alt="image-20250317195151183"></p><h3 id="9-3-缩进"><a href="#9-3-缩进" class="headerlink" title="9.3  缩进"></a>9.3  <strong>缩进</strong></h3><p><strong>使用4个空格进行代码缩进，禁止使用制表符。</strong></p><h3 id="9-4-大括号"><a href="#9-4-大括号" class="headerlink" title="9.4  大括号"></a>9.4  大括号</h3><p>大括号的总结来说有两种使用情况，分别是{ 跟在语句后面空一格或者 { 独占一行，} 独占一行。<br>{ 必须独占一行情况，主要是定义的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bar</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 枚举定义</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Baz</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo::foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>{ 即可独占一行，或者空一格形式，主要是代码逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if语句</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for循环语句</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// while和do-while循环语句</span></span><br><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch-case</span></span><br><span class="line"><span class="keyword">switch</span> (value) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-5-函数调用"><a href="#9-5-函数调用" class="headerlink" title="9.5  函数调用"></a>9.5  函数调用</h3><p>函数调用要么在一行写完调用，要么在圆括号里对参数分行，要么参数另起一行且缩进四格。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常情况</span></span><br><span class="line"><span class="type">bool</span> retval = <span class="built_in">doSomething</span>(argument1, argument2, argument3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同一行放不下,换新行且和第一个实参对齐,左圆括号后和右圆括号前不留空格</span></span><br><span class="line"><span class="type">bool</span> retval = <span class="built_in">doSomething</span>(averyveryveryverylongargument1,</span><br><span class="line">                          argument2, argument3);</span><br><span class="line"><span class="comment">// 模拟层次多的情况</span></span><br><span class="line"><span class="keyword">if</span> (...) &#123;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        <span class="built_in">doSomething</span>(</span><br><span class="line">            argument1, argument2,  <span class="comment">// 4 空格缩进</span></span><br><span class="line">            argument3, argument4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一些参数本身就是略复杂的表达式，那么可以直接创建临时变量描述该表达式，并传递给函数。也可以将某个参数独立成行，添加注释，增加可读性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int my_heuristic = scores[x] * y + bases[x];</span><br><span class="line">bool retval = doSomething(my_heuristic, x, y, z);</span><br><span class="line"></span><br><span class="line">bool retval = doSomething(scores[x] * y + bases[x],  // Score heuristic.</span><br><span class="line">                          x, y, z);</span><br></pre></td></tr></table></figure><p>如果一系列的参数本身就有一定的结构，可以酌情地按其结构来决定参数格式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 3x3 矩阵转换 widget.</span></span><br><span class="line">my_widget.<span class="built_in">Transform</span>(x1, x2, x3,</span><br><span class="line">                    y1, y2, y3,</span><br><span class="line">                    z1, z2, z3);</span><br></pre></td></tr></table></figure><h3 id="9-6-函数声明与定义"><a href="#9-6-函数声明与定义" class="headerlink" title="9.6  函数声明与定义"></a>9.6  函数声明与定义</h3><p><strong>返回类型和函数名放在同一行，参数在放不下时，对形参分行，{ }分别单独占一行。例如：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值、函数名、形参在同一行</span></span><br><span class="line"><span class="function">ReturnType <span class="title">ClassName::FunctionName</span><span class="params">(Type par_name1, Type par_name2)</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// &#123; 独占一行</span></span><br><span class="line">    <span class="built_in">doSomething</span>();</span><br><span class="line">&#125; <span class="comment">// &#125; 独占一行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 形参换行</span></span><br><span class="line"><span class="function">ReturnType <span class="title">ClassName::ReallyLongFunctionName</span><span class="params">(Type par_name1, Type par_name2,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             Type par_name3)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数都放不下,换新行4空格缩进</span></span><br><span class="line"><span class="function">ReturnType <span class="title">LongClassName::ReallyReallyReallyLongFunctionName</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Type par_name1,  <span class="comment">// 4空格缩进</span></span></span></span><br><span class="line"><span class="params"><span class="function">    Type par_name2,</span></span></span><br><span class="line"><span class="params"><span class="function">    Type par_name3)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未被使用参数，或者根据上下文很容易看出用途参数，可以省略参数名。<strong>但是尽量不要省略参数名。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承于Qt的事件的函数,事件参数未被使用,可以省略参数名</span></span><br><span class="line"><span class="comment">// 这种情况大多是因为继承,重写事件而省略参数操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showEvent</span><span class="params">(QShowEvent *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hideEvent</span><span class="params">(QHideEvent *)</span></span>;</span><br><span class="line"><span class="comment">// 需要移除拷贝构造函数或者是赋值操作函数,可以省略参数名</span></span><br><span class="line"><span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">Foo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Foo &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口中形参恒有命名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Rotate</span><span class="params">(<span class="type">double</span> radians)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Rotate</span><span class="params">(<span class="type">double</span> radians)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Circle::Rotate</span><span class="params">(<span class="type">double</span>)</span> </span>&#123;&#125; <span class="comment">// 不推荐 —— 省略会不清楚变量的作用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Circle::Rotate</span><span class="params">(<span class="type">double</span> <span class="comment">/*radians*/</span>)</span> </span>&#123;&#125; <span class="comment">// 推荐 —— 说明变量作用并消除警告</span></span><br></pre></td></tr></table></figure><h3 id="9-7-条件语句"><a href="#9-7-条件语句" class="headerlink" title="9.7  条件语句"></a>9.7  条件语句</h3><p>对基本条件语句不在圆括号内使用空格，if后面空一格，{ 前空一格或换行，} 独立一行，即不跟else或者else if。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123; </span><br><span class="line">    ... <span class="comment">// 缩进四格</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;  <span class="comment">// else或else if另起一行</span></span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果能增强可读性，简短的条件语句允许写在同一行。只有当语句简单并且没有使用else子句时使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == kFoo) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line"><span class="keyword">if</span> (x == kBar) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Bar</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不允许 - 当有 ELSE 分支时 IF 块却写在同一行</span></span><br><span class="line"><span class="keyword">if</span> (x) <span class="built_in">DoThis</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">DoThat</span>();</span><br></pre></td></tr></table></figure><p>如果语句中某个if-else语句使用大括号的话，其他分支也必须要使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可以这样子 - IF 有大括号 ELSE 却没有</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    foo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">bar;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以这样子 - ELSE 有大括号 IF 却没有</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    foo;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要其中一个分支用了大括号, 两个分支都要用上大括号</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    foo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-8-布尔表达式"><a href="#9-8-布尔表达式" class="headerlink" title="9.8  布尔表达式"></a>9.8  布尔表达式</h3><p>如果一个布尔表达式过长，断行方式要<strong>统一为逻辑操作符放在新行的开头。</strong>但逻辑复杂时考虑增加圆括号，增加可读性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (this_one_thing &gt; this_other_thing </span><br><span class="line">    &amp;&amp; (a_third_thing == a_fourth_thing) <span class="comment">// 加入圆括号增加可读性 </span></span><br><span class="line">    &amp;&amp; yet_another &amp;&amp; last_one)          <span class="comment">// 操作符放在开头对齐第一个参数</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-9-switch-case语句"><a href="#9-9-switch-case语句" class="headerlink" title="9.9  switch-case语句"></a>9.9  switch-case语句</h3><p>循环和switch-case语句的 { 可以与关键词在同一行,也可以另起单独一行与 } 对齐。后续代码不作展示说明。<br><strong>switch语句中的case块必须要大括号进行分段，以表明case之间不是连在一起的。switch应该总是包含一个default匹配。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (var) &#123; <span class="comment">// 可以在同一行,也可以另起单独一行与&#125;对齐</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: &#123;  <span class="comment">// 空格缩进四格</span></span><br><span class="line">        ...    <span class="comment">// 空格缩进八格</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: &#123;  <span class="comment">// 可以在同一行,也可以另起单独一行与&#125;对齐</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="literal">false</span>); <span class="comment">// 如果不可能到default可以尝试添加assert语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-10-指针和引用表达式"><a href="#9-10-指针和引用表达式" class="headerlink" title="9.10  指针和引用表达式"></a>9.10  指针和引用表达式</h3><p>**句点或箭头前后不要有空格；指针&#x2F;地址操作符(*，&amp;)之后不能有空格。**例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = *p;</span><br><span class="line">p = &amp;x;</span><br><span class="line">x = r.y;</span><br><span class="line">x = r-&gt;y;</span><br></pre></td></tr></table></figure><p>在声明指针变量或参数时，星号与类型或变量名紧挨都可以：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐——空格前置</span></span><br><span class="line"><span class="type">char</span> *c;</span><br><span class="line"><span class="type">const</span> string &amp;str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐——空格后置</span></span><br><span class="line"><span class="type">char</span>* c;</span><br><span class="line"><span class="type">const</span> string&amp; str;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x, *y;  <span class="comment">// 不推荐——在多重声明中不能使用 &amp; 或 *</span></span><br><span class="line"><span class="type">char</span> * c;  <span class="comment">// 不推荐—— * 两边都有空格</span></span><br><span class="line"><span class="type">const</span> string &amp; str;  <span class="comment">// 不推荐—— &amp; 两边都有空格</span></span><br></pre></td></tr></table></figure><h3 id="9-11-预处理指令"><a href="#9-11-预处理指令" class="headerlink" title="9.11  预处理指令"></a><strong>9.11  预处理指令</strong></h3><p>预处理指令不要缩进, 从行首开始。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐 - 指令从行首开始</span></span><br><span class="line"><span class="keyword">if</span> (lopsided_score) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DISASTER_PENDING      <span class="comment">// 正确 - 从行首开始</span></span></span><br><span class="line">    <span class="built_in">DropEverything</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">BackToNormal</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐 - 指令缩进</span></span><br><span class="line"><span class="keyword">if</span> (lopsided_score) &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> DISASTER_PENDING  <span class="comment">// 差 - &quot;#if&quot; 应该放在行开头</span></span></span><br><span class="line">    <span class="built_in">DropEverything</span>();</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span>                <span class="comment">// 差 - &quot;#endif&quot; 不要缩进</span></span></span><br><span class="line">    <span class="built_in">BackToNormal</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-12-构造函数初始值列表"><a href="#9-12-构造函数初始值列表" class="headerlink" title="9.12  构造函数初始值列表"></a>9.12  <strong>构造函数初始值列表</strong></h3><p>构造函数初始化列表放在<strong>同一行或按四格缩进并排多行。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果所有变量能放在同一行:</span></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">const</span> <span class="type">int</span> var) : <span class="built_in">m_someVar</span>(var) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不能放在同一行,</span></span><br><span class="line"><span class="comment">// 必须置于冒号后, 并缩进 4 个空格</span></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">const</span> <span class="type">int</span> var)</span><br><span class="line">    : <span class="built_in">m_someVar</span>(var), <span class="built_in">m_someOtherVar</span>(var + <span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果初始化列表需要置于多行, 将每一个成员放在单独的一行</span></span><br><span class="line"><span class="comment">// 并逐行对齐</span></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">const</span> <span class="type">int</span> var)</span><br><span class="line">    : <span class="built_in">m_someVar</span>(var),             <span class="comment">// 缩进 4 个空格</span></span><br><span class="line">      <span class="built_in">m_someOtherVar</span>(var + <span class="number">1</span>) </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-13-类格式"><a href="#9-13-类格式" class="headerlink" title="9.13  类格式"></a>9.13  类格式</h3><p><strong>访问控制块关键词的声明不需要缩进。</strong><br>类声明得基本格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> OtherClass </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:      <span class="comment">// 注意没有缩进</span></span><br><span class="line">    <span class="built_in">MyClass</span>();  <span class="comment">// 标准的空格缩进四格</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">const</span> <span class="type">int</span> var)</span></span>;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someFunctionThatDoesNothing</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSomeVar</span><span class="params">(<span class="type">const</span> <span class="type">int</span> var)</span> </span>&#123; m_someVar = var; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">someVar</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_someVar; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">someInternalFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_someVar;</span><br><span class="line">    <span class="type">int</span> m_someOtherVar;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li>所有基类名应在 80 列限制下尽量与子类名放在同一行；</li><li>访问控制块关键词没有缩进，关键词后不要保留空行；</li><li>除第一个关键词 外，其他关键词前要空一行；</li><li>关于声明顺序的规则请参考 4.8 声明顺序 一节</li></ol><h2 id="10-完结撒花"><a href="#10-完结撒花" class="headerlink" title="10  完结撒花"></a>10  完结撒花</h2><p> <strong>正确性 &gt; 稳定性 &gt; 可测试性 &gt; 可读性 &gt; 全局效率 &gt; 局部效率 &gt; 个人习惯。</strong></p><ol><li>正确性，指程序要实现设计 要求的功能；</li><li>稳定性、安全性，指程序稳定、可靠、安全；</li><li>可测试性，指程序要具有良好的可测试性；</li><li>规范&#x2F;可读性，指程序书写风格、命名规则等要符合规范；</li><li>全局效率，指软件系统的整体效率；</li><li>局部效率，指某个模块&#x2F;子模块&#x2F;函数的本身效率；</li><li>个人表达方式&#x2F;个人方便性，指个人编程习惯。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.  概述&quot;&gt;&lt;/a&gt;1.  &lt;strong&gt;概述&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;命名，是计算机史上最难的问题之一，有很多书本都有专门的章节讨论命名规范的问题，鄙人</summary>
      
    
    
    
    <category term="经验" scheme="https://cpp-memory-leaks.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
  </entry>
  
</feed>
